var tipuesearch = {"pages":[{"title":" NumDiff ","text":"NumDiff Brief description NumDiff provides a modern Fortran interface for computing the Jacobian (derivative) matrix of m nonlinear functions which depend on n variables. The Jacobian matrix is required for various applications, including numerical optimization. It can also be used to test the accuracy of gradients computed by other means. The library also provides for computing the sparsity of this matrix, and returning the Jacobian in sparse or dense form. Status This is currently a work in progress. The goal is a comprehensive library that contains a full suite of computationally efficient implementations of algorithms for sparsity determination and numerical differentiation. This code is hosted on GitHub at: https://github.com/jacobwilliams/NumDiff To Do [x] Computing the nonlinear sparsity pattern [x] Specified by the user [x] Assume all elements true [x] Three random points within variable bounds (have the option to specify separate bounds for this purpose) [x] Various order finite different gradient methods [x] 2-point (backward 1, forward 1) [x] 3-point (backward 2, central, forward 2) [x] 4-point (backward 3, backward 2, forward 2, forward 3) [x] 5-point (backward 4, backward 3, central, forward 3, forward 4) [x] 6-point (backward 5, backward 4, backward 3, forward 3, forward 4, forward 5) [x] 7-point (backward 6, backward 5, backward 4, central, forward 4, forward 5, forward 6) [x] 8-point (backward 7, backward 6, backward 5, backward 4, forward 4, forward 5, forward 6, forward 7) [x] 9-point (backward 8, backward 7, backward 6, backward 5, central, forward 5, forward 6, forward 7, forward 8) [x] 11-point (central) [x] 13-point (central) [x] 15-point (central) [x] 17-point (central) [x] Perturbations should respect variable bounds [x] Neville's process [x] Ability to use different methods for different columns [x] Jacobian partitioning to compute multiple columns at the same time [ ] Estimate the optimal perturbation step size [ ] Computing the linear sparsity pattern (constant elements of Jacobian) [ ] Add other gradient methods? [ ] Also compute Hessian matrix? [ ] OpenMP or Coarrays for parallelization [ ] Testing for computational efficiency [ ] General code cleanup Building NumDiff FPM A Fortran Package Manager manifest file is included, so that the library and tests cases can be compiled with FPM. For example: fpm build --profile release\nfpm test --profile release To use NumDiff within your FPM project, add the following to your fpm.toml file: [dependencies] NumDiff = { git = \"https://github.com/jacobwilliams/NumDiff.git\" } or, to use a specific version: [dependencies] NumDiff = { git = \"https://github.com/jacobwilliams/NumDiff.git\" , tag = \"1.7.0\" } To generate the documentation using FORD , run: ford ford.md By default, the library is built with double precision ( real64 ) real values. Explicitly specifying the real kind can be done using the following processor flags: Preprocessor flag Kind Number of bytes REAL32 real(kind=real32) 4 REAL64 real(kind=real64) 8 REAL128 real(kind=real128) 16 For example, to build a single precision version of the library, use: fpm build --profile release --flag \"-DREAL32\" Note that the pyplot-fortran library is a dependency for one of the test cases. FPM will automatically download the right version. Documentation The latest API documentation can be found here . This was generated from the source code using FORD (note that the included build.sh script will also generate these files). License The NumDiff source code and related files and documentation are distributed under a permissive free software license (BSD-style). References J. Oliver, \"An algorithm for numerical differentiation of a function of one real variable\", Journal of Computational and Applied Mathematics 6 (2) (1980) 145-160.  Fortran 77 code from NIST Thomas F. Coleman, Burton S. Garbow, Jorge J. More, \"Algorithm 618: FORTRAN subroutines for estimating sparse Jacobian Matrices\", ACM Transactions on Mathematical Software (TOMS), Volume 10 Issue 3, Sept. 1984, Pages 346-347 G. E. Mullges, F. Uhlig, \"Numerical Algorithms with Fortran\", Springer, 1996. Developer Info Jacob Williams","tags":"home","url":"index.html"},{"title":"fx – NumDiff ","text":"type, private :: fx an [x,f(x)] cached pair. Inherited by type~~fx~~InheritedByGraph type~fx fx type~function_cache function_cache type~function_cache->type~fx c type~numdiff_type numdiff_type type~numdiff_type->type~function_cache cache Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:), allocatable :: x vector of input values real(kind=wp), private, dimension(:), allocatable :: f vector of output functions f(x) note: only the elements indicated by ifs will have valid values. The others will\nbe dummy values. integer, private, dimension(:), allocatable :: ifs elements of f present in the cache\n(this is just an array of the indices\npresent in f ) Source Code type :: fx !! an [x,f(x)] cached pair. private real ( wp ), dimension (:), allocatable :: x !! vector of input values real ( wp ), dimension (:), allocatable :: f !! vector of output functions `f(x)` !! note: only the elements indicated by `ifs` !! will have valid values. The others will !! be dummy values. integer , dimension (:), allocatable :: ifs !! elements of `f` present in the cache !! (this is just an array of the indices !! present in `f`) end type fx","tags":"","url":"type/fx.html"},{"title":"function_cache – NumDiff ","text":"type, public :: function_cache a vector function cache. Inherits type~~function_cache~~InheritsGraph type~function_cache function_cache type~fx fx type~function_cache->type~fx c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~function_cache~~InheritedByGraph type~function_cache function_cache type~numdiff_type numdiff_type type~numdiff_type->type~function_cache cache Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, private :: n = 0 size of x integer, private :: m = 0 size of f type( fx ), private, dimension(:), allocatable :: c the cache of f(x) integer, private :: chunk_size = 100 for resizing vectors\nin the unique function Type-Bound Procedures procedure, public :: initialize => initialize_cache private  subroutine initialize_cache (me, isize, n, m, chunk_size) Initialize the cache. Must be called first before use. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in) :: n number of independant variables (x) integer, intent(in) :: m number of functions (f) integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] procedure, public :: get => get_from_cache private  subroutine get_from_cache (me, x, ifs, i, f, xfound, ffound) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x independant variable vector integer, intent(in), dimension(:) :: ifs elements of f needed integer, intent(out) :: i index in the hash table real(kind=wp), intent(out), dimension(:) :: f f(x) from the cache (if it was found) logical, intent(out) :: xfound if x was found in the cache logical, intent(out), dimension(size(ifs)) :: ffound which ifs were found in the cache procedure, public :: put => put_in_cache private  subroutine put_in_cache (me, i, x, f, ifs) Put a value into the cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: i index in the hash table real(kind=wp), intent(in), dimension(:) :: x independant variable vector (dimension n ) real(kind=wp), intent(in), dimension(:) :: f function vector f(x) (dimension m ) integer, intent(in), dimension(:) :: ifs elements of f to add (should all be >0, <=m ) procedure, public :: destroy => destroy_cache private  subroutine destroy_cache (me) Destroy a cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me procedure, public :: print => print_cache private  subroutine print_cache (me, iunit) Print the contents of the cache. Used for debugging. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: iunit file unit for writing\n(assumed to be opened) Source Code type , public :: function_cache !! a vector function cache. private integer :: n = 0 !! size of `x` integer :: m = 0 !! size of `f` type ( fx ), dimension (:), allocatable :: c !! the cache of `f(x)` integer :: chunk_size = 100 !! for resizing vectors !! in the [[unique]] function contains private procedure , public :: initialize => initialize_cache procedure , public :: get => get_from_cache procedure , public :: put => put_in_cache procedure , public :: destroy => destroy_cache procedure , public :: print => print_cache end type function_cache","tags":"","url":"type/function_cache.html"},{"title":"diff_func – NumDiff ","text":"type, public :: diff_func class to define the function for diff Components Type Visibility Attributes Name Initial logical, private :: stop = .false. procedure( func ), private, pointer :: f => null() Type-Bound Procedures procedure, private :: faccur private  subroutine faccur (me, h0, h1, facc, x0, twoinf, f0, f1, ifail) This procedure attempts to estimate the level of rounding errors in\nthe calculated function values near the point x0+h0 by fitting a\nleast-squares straight-line approximation to the function at the\nsix points x0+h0-j*h1 , ( j = 0,1,3,5,7,9 ), and then setting facc to\ntwice the largest deviation of the function values from this line. hi is adjusted if necessary so that it is approximately 8 times the\nsmallest spacing at which the function values are unequal near x0+h0 . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me real(kind=wp), intent(inout) :: h0 real(kind=wp), intent(inout) :: h1 real(kind=wp), intent(out) :: facc real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: twoinf real(kind=wp), intent(in) :: f0 real(kind=wp), intent(in) :: f1 integer, intent(out) :: ifail 0 if no error, -1 if user termination. procedure, public :: set_function private  subroutine set_function (me, f) Author Jacob Williams Date 12/27/2015 Set the function in a diff_func .\nMust be called before diff . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me procedure( func ) :: f procedure, public :: compute_derivative => diff private  subroutine diff (me, iord, x0, xmin, xmax, eps, accr, deriv, error, ifail) the procedure diff calculates the first, second or\nthird order derivative of a function by using neville's process to\nextrapolate from a sequence of simple polynomial approximations based on\ninterpolating points distributed symmetrically about x0 (or lying only on\none side of x0 should this be necessary).  if the specified tolerance is\nnon-zero then the procedure attempts to satisfy this absolute or relative\naccuracy requirement, while if it is unsuccessful or if the tolerance is\nset to zero then the result having the minimum achievable estimated error\nis returned instead. Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me integer, intent(in) :: iord 1, 2 or 3 specifies that the first, second or third order\nderivative,respectively, is required. real(kind=wp), intent(in) :: x0 the point at which the derivative of the function is to be calculated. real(kind=wp), intent(in) :: xmin xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: xmax xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: eps denotes the tolerance, either absolute or relative. eps=0 specifies that\nthe error is to be minimised, while eps>0 or eps<0 specifies that the\nabsolute or relative error, respectively, must not exceed abs(eps) if\npossible.  the accuracy requirement should not be made stricter than\nnecessary, since the amount of computation tends to increase as\nthe magnitude of eps decreases, and is particularly high when eps=0 . real(kind=wp), intent(in) :: accr denotes that the absolute ( accr>0 ) or relative ( accr<0 ) errors in the\ncomputed values of the function are most unlikely to exceed abs(accr) , which\nshould be as small as possible.  if the user cannot estimate accr with\ncomplete confidence, then it should be set to zero. real(kind=wp), intent(out) :: deriv the calculated value of the derivative real(kind=wp), intent(out) :: error an estimated upper bound on the magnitude of the absolute error in\nthe calculated result.  it should always be examined, since in extreme case\nmay indicate that there are no correct significant digits in the value\nreturned for derivative. integer, intent(out) :: ifail will have one of the following values on exit: 0 the procedure was successful. 1 the estimated error in the result exceeds the (non-zero) requested\n     error, but the most accurate result possible has been returned. 2 input data incorrect (derivative and error will be undefined). 3 the interval [ xmin , xmax ] is too small (derivative and error will be\n     undefined). -1 stopped by the user. procedure, public :: terminate private  subroutine terminate (me) Can be called by the user in the function to terminate the computation.\nThis will set ifail=-1 . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me Source Code type , public :: diff_func !! class to define the function for [[diff]] private logical :: stop = . false . procedure ( func ), pointer :: f => null () contains private procedure :: faccur procedure , public :: set_function procedure , public :: compute_derivative => diff procedure , public :: terminate end type diff_func","tags":"","url":"type/diff_func.html"},{"title":"finite_diff_method – NumDiff ","text":"type, public :: finite_diff_method defines the finite difference method\nused to compute the Jacobian. See: get_finite_difference_method for the different methods. Inherited by type~~finite_diff_method~~InheritedByGraph type~finite_diff_method finite_diff_method type~meth_array meth_array type~meth_array->type~finite_diff_method meth type~numdiff_type numdiff_type type~numdiff_type->type~finite_diff_method meth type~numdiff_type->type~meth_array class_meths Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, private :: id = 0 unique ID for the method character(len=:), private, allocatable :: name the name of the method integer, private :: class = 0 2=backward diffs, 3=central diffs, etc... real(kind=wp), private, dimension(:), allocatable :: dx_factors multiplicative factors for dx perturbation real(kind=wp), private, dimension(:), allocatable :: df_factors multiplicative factors for accumulating function evaluations real(kind=wp), private :: df_den_factor = zero denominator factor for finite difference equation (times dx ) Constructor public        interface finite_diff_method constructor private  function initialize_finite_difference_method (id, name, class, dx_factors, df_factors, df_den_factor) result(me) Constructor for a finite_diff_method . Note factors are input as integers for convenience, but are converted\n      to reals for the actual computations. (note: this means we can't\n      currently define methods that have non-integer factors). Arguments Type Intent Optional Attributes Name integer, intent(in) :: id unique ID for the method character(len=*), intent(in) :: name the name of the method integer, intent(in) :: class 2=backward diffs, 3=central diffs, etc... integer, intent(in), dimension(:) :: dx_factors multiplicative factors for dx perturbation integer, intent(in), dimension(:) :: df_factors multiplicative factors for accumulating function evaluations integer, intent(in) :: df_den_factor denominator factor for finite difference equation (times dx) Return Value type( finite_diff_method ) Type-Bound Procedures procedure, public :: get_formula private  subroutine get_formula (me, formula) Return a string with the finite difference formula. Read more… Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me character(len=:), intent(out), allocatable :: formula procedure, public :: print => print_finite_difference_method private  subroutine print_finite_difference_method (me, iunit) Print the contents of a finite_diff_method . Used for debugging. Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me integer, intent(in) :: iunit file unit for printing\n(assumed to be opened) Source Code type , public :: finite_diff_method !! defines the finite difference method !! used to compute the Jacobian. !! !! See: [[get_finite_difference_method]] !! for the different methods. private integer :: id = 0 !! unique ID for the method character ( len = :), allocatable :: name !! the name of the method integer :: class = 0 !! 2=backward diffs, 3=central diffs, etc... real ( wp ), dimension (:), allocatable :: dx_factors !! multiplicative factors for `dx` perturbation real ( wp ), dimension (:), allocatable :: df_factors !! multiplicative factors for accumulating function evaluations real ( wp ) :: df_den_factor = zero !! denominator factor for finite difference equation (times `dx`) contains private procedure , public :: get_formula procedure , public :: print => print_finite_difference_method end type finite_diff_method","tags":"","url":"type/finite_diff_method.html"},{"title":"meth_array – NumDiff ","text":"type, public :: meth_array to store an array of finite_diff_method types\nthis is used when the mode=2 option is used\nin numdiff_type Inherits type~~meth_array~~InheritsGraph type~meth_array meth_array type~finite_diff_method finite_diff_method type~meth_array->type~finite_diff_method meth Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~meth_array~~InheritedByGraph type~meth_array meth_array type~numdiff_type numdiff_type type~numdiff_type->type~meth_array class_meths Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( finite_diff_method ), private, dimension(:), allocatable :: meth Source Code type , public :: meth_array !! to store an array of [[finite_diff_method]] types !! this is used when the `mode=2` option is used !! in [[numdiff_type]] private type ( finite_diff_method ), dimension (:), allocatable :: meth end type meth_array","tags":"","url":"type/meth_array.html"},{"title":"sparsity_pattern – NumDiff ","text":"type, public :: sparsity_pattern A sparsity pattern Inherited by type~~sparsity_pattern~~InheritedByGraph type~sparsity_pattern sparsity_pattern type~numdiff_type numdiff_type type~numdiff_type->type~sparsity_pattern sparsity Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, private :: sparsity_computed = .false. has the sparsity pattern already been computed? integer, private :: num_nonzero_elements = 0 number of nonzero elements in the jacobian\n(will be the dimension of irow and icol ) integer, private, dimension(:), allocatable :: irow sparsity pattern - rows of non-zero elements integer, private, dimension(:), allocatable :: icol sparsity pattern - columns of non-zero elements logical, private :: linear_sparsity_computed = .false. if the linear pattern has been populated integer, private :: num_nonzero_linear_elements = 0 number of constant elements in the jacobian integer, private, dimension(:), allocatable :: linear_irow linear sparsity pattern - rows of non-zero elements integer, private, dimension(:), allocatable :: linear_icol linear sparsity pattern - columns of non-zero elements real(kind=wp), private, dimension(:), allocatable :: linear_vals linear elements of the jacobian integer, private, dimension(:), allocatable :: indices index vector [1,2,...,num_nonzero_elements] for putting df into jac integer, private :: maxgrp = 0 the number of groups in the partition\nof the columns of a . integer, private, dimension(:), allocatable :: ngrp specifies the partition of the columns of a .\ncolumn jcol belongs to group ngrp(jcol) . size(n) Type-Bound Procedures procedure, private :: dsm_wrapper private  subroutine dsm_wrapper (me, n, m, info) Wrapper for dsm to compute the sparsity pattern partition. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me integer, intent(in) :: n number of columns of jacobian matrix integer, intent(in) :: m number of rows of jacobian matrix integer, intent(out) :: info status output from dsm procedure, private :: compute_indices private  subroutine compute_indices (me) Computes the indices vector in the class. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me procedure, public :: destroy => destroy_sparsity private  subroutine destroy_sparsity (me) destroy a sparsity_pattern type. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(out) :: me procedure, public :: print => print_sparsity private  subroutine print_sparsity (me, n, m, iunit, dense) Print the sparsity pattern. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: n number of variables (columns of jacobian) integer, intent(in) :: m number of functions (rows of jacobian) integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) logical, intent(in), optional :: dense if present and true, the matrix form\nof the sparsity pattern is printed\n(default is vector form) procedure, public :: columns_in_partition_group private  subroutine columns_in_partition_group (me, igroup, n_cols, cols, nonzero_rows, indices, status_ok) Returns the columns in a sparsity partition group. Read more… Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: igroup group number. Should be >0 and <=me%mxgrp integer, intent(out) :: n_cols number of columns in the igroup group. integer, intent(out), dimension(:), allocatable :: cols the column numbers in the igroup group.\n(if none, then it is not allocated) integer, intent(out), dimension(:), allocatable :: nonzero_rows the row numbers of all the nonzero\nJacobian elements in this group integer, intent(out), dimension(:), allocatable :: indices nonzero indices in jac for a group logical, intent(out) :: status_ok true if the partition is valid Source Code type , public :: sparsity_pattern !! A sparsity pattern private logical :: sparsity_computed = . false . !! has the sparsity pattern already been computed? integer :: num_nonzero_elements = 0 !! number of nonzero elements in the jacobian !! (will be the dimension of `irow` and `icol`) integer , dimension (:), allocatable :: irow !! sparsity pattern - rows of non-zero elements integer , dimension (:), allocatable :: icol !! sparsity pattern - columns of non-zero elements logical :: linear_sparsity_computed = . false . !! if the linear pattern has been populated integer :: num_nonzero_linear_elements = 0 !! number of constant elements in the jacobian integer , dimension (:), allocatable :: linear_irow !! linear sparsity pattern - rows of non-zero elements integer , dimension (:), allocatable :: linear_icol !! linear sparsity pattern - columns of non-zero elements real ( wp ), dimension (:), allocatable :: linear_vals !! linear elements of the jacobian integer , dimension (:), allocatable :: indices !! index vector !! `[1,2,...,num_nonzero_elements]` !! for putting `df` into `jac` integer :: maxgrp = 0 !! the number of groups in the partition !! of the columns of `a`. integer , dimension (:), allocatable :: ngrp !! specifies the partition of the columns of `a`. !! column `jcol` belongs to group `ngrp(jcol)`. !! `size(n)` contains private procedure :: dsm_wrapper procedure :: compute_indices procedure , public :: destroy => destroy_sparsity procedure , public :: print => print_sparsity procedure , public :: columns_in_partition_group end type sparsity_pattern","tags":"","url":"type/sparsity_pattern.html"},{"title":"numdiff_type – NumDiff ","text":"type, public :: numdiff_type base type for sparsity and Jacobian computations. Inherits type~~numdiff_type~~InheritsGraph type~numdiff_type numdiff_type type~finite_diff_method finite_diff_method type~numdiff_type->type~finite_diff_method meth type~function_cache function_cache type~numdiff_type->type~function_cache cache type~meth_array meth_array type~numdiff_type->type~meth_array class_meths type~sparsity_pattern sparsity_pattern type~numdiff_type->type~sparsity_pattern sparsity type~fx fx type~function_cache->type~fx c type~meth_array->type~finite_diff_method meth Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, private :: exception_raised = .false. if true, an exception has been raised integer, private :: istat = 0 a non-zero value will cause all routine to exit.\nthis can be set to -1 by calling terminate . character(len=:), private, allocatable :: error_msg error message (if istat/=0 ) integer, private :: n = 0 number of x variables integer, private :: m = 0 number of f functions real(kind=wp), private, dimension(:), allocatable :: xlow lower bounds on x real(kind=wp), private, dimension(:), allocatable :: xhigh upper bounds on x logical, private :: print_messages = .true. if true, warning messages are printed\nto the error_unit for any errors. integer, private :: chunk_size = 100 chuck size for allocating the arrays (>0) integer, private :: perturb_mode = 1 perturbation mode: 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), private, dimension(:), allocatable :: dpert perturbation vector for x logical, private :: partition_sparsity_pattern = .false. to partition the sparsity pattern using dsm type( sparsity_pattern ), private :: sparsity the sparsity pattern real(kind=wp), private, dimension(:), allocatable :: xlow_for_sparsity lower bounds on x for computing sparsity (optional) real(kind=wp), private, dimension(:), allocatable :: xhigh_for_sparsity upper bounds on x for computing sparsity (optional) real(kind=wp), private, dimension(:), allocatable :: dpert_for_sparsity perturbation vector for x when computing\nsparsity for sparsity_mode=4 integer, private :: num_sparsity_points = 3 for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern.\nSee compute_sparsity_random_2 integer, private :: sparsity_perturb_mode = 1 perturbation mode (if sparsity_mode=4 ): 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) logical, private :: compute_linear_sparsity_pattern = .false. to also compute the linear sparsity pattern real(kind=wp), private :: linear_sparsity_tol = epsilon(1.0_wp) the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), private :: function_precision_tol = epsilon(1.0_wp) the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, private :: mode = 1 1 = use meth (specified methods), 2 = use class (specified class, method is selected on-the-fly). type( finite_diff_method ), private, dimension(:), allocatable :: meth the finite difference method to use\ncompute the n th column of the Jacobian size(n) .  Either this or class is used integer, private, dimension(:), allocatable :: class the class of method to use to\ncompute the n th column of the Jacobian size(n) . Either this or meth is used type( meth_array ), private, dimension(:), allocatable :: class_meths array of methods for the specified classes.\nused with class when mode=2 real(kind=wp), private :: eps = 1.0e-9_wp tolerance parameter for diff real(kind=wp), private :: acc = 0.0_wp tolerance parameter for diff type( function_cache ), private :: cache if using the function cache logical, private :: use_diff = .false. if we are using the Neville's process method,\nrather than finite differences procedure( func ), private, pointer :: problem_func => null() the user-defined function procedure( func ), private, pointer :: compute_function => null() compute the user-defined function\nthis can point to the problem_func or, if using\nthe cache, it points to compute_function_with_cache . procedure( spars_f ), private, pointer :: compute_sparsity => null() for computing the sparsity pattern procedure( info_f ), private, pointer :: info_function => null() an optional function the user can define\nwhich is called when each column of the jacobian is computed.\nIt can be used to perform any setup operations. procedure( jacobian_f ), private, pointer :: jacobian_function => null() the low-level function called by compute_jacobian that actually computes the jacobian. Type-Bound Procedures procedure, public :: initialize => initialize_numdiff initialize the class private  subroutine initialize_numdiff (me, n, m, xlow, xhigh, perturb_mode, dpert, problem_func, sparsity_mode, jacobian_method, jacobian_methods, class, classes, info, chunk_size, partition_sparsity_pattern, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points) Initialize a numdiff_type class. This must be called first. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x integer, intent(in) :: perturb_mode perturbation mode: 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), dimension(n) :: dpert perturbation vector for x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. integer, intent(in), optional :: jacobian_method id code for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: jacobian_methods id codes for the finite difference method\nto use for each variable.\nsee get_finite_difference_method integer, intent(in), optional :: class method class for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: classes method class for the finite difference methods\nto use for each variable.\nsee get_finite_difference_method procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] logical, intent(in), optional :: partition_sparsity_pattern if the sparisty pattern is to\nbe partitioned using dsm [default is False] integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity for sparsity_mode=4 , the perturbation integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. procedure, public :: diff_initialize => initialize_numdiff_for_diff initialize the class private  subroutine initialize_numdiff_for_diff (me, n, m, xlow, xhigh, problem_func, sparsity_mode, info, chunk_size, eps, acc, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points, print_messages) Alternate version of initialize_numdiff routine when\nusing diff to compute the Jacobian. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: Read more… procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] real(kind=wp), intent(in), optional :: eps tolerance parameter for diff if not present, default is 1.0e-9_wp real(kind=wp), intent(in), optional :: acc tolerance parameter for diff if not present, default is 0.0_wp integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity required if sparsity_mode=4 integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): Read more… real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. logical, intent(in), optional :: print_messages if true, print error messages to error_unit .\ndefault is True. procedure, public :: compute_jacobian main routine to compute the Jacobian\nusing the selected options. It\nreturns the sparse (vector) form. private  subroutine compute_jacobian (me, x, jac) Compute the Jacobian. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector procedure, public :: compute_jacobian_dense return the dense size(m,n) matrix form of the Jacobian. private  subroutine compute_jacobian_dense (me, x, jac) just a wrapper for compute_jacobian , that returns a dense ( m x n ) matrix. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:,:), allocatable :: jac the jacobian matrix procedure, public :: compute_jacobian_times_vector returns the product of the Jacobian\nmatrix and an input vector private  subroutine compute_jacobian_times_vector (me, x, v, z) Returns the product J*v , where J is the m x n Jacobian matrix\n  and v is an n x 1 vector. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(:) :: v vector (size n ) real(kind=wp), intent(out), dimension(:) :: z The product J*v (size m ) procedure, public :: destroy => destroy_numdiff_type destroy the class private  subroutine destroy_numdiff_type (me) destroy the numdiff_type class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(out) :: me procedure, public :: print_sparsity_pattern print the sparsity pattern in vector form to a file private  subroutine print_sparsity_pattern (me, iunit) Print the sparsity pattern in vector form ( irow , icol ). Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) procedure, public :: print_sparsity_matrix print the sparsity pattern in matrix form to a file private  subroutine print_sparsity_matrix (me, iunit) Print the sparsity pattern in matrix form. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) procedure, public :: set_sparsity_pattern manually set the sparsity pattern private  subroutine set_sparsity_pattern (me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) To specify the sparsity pattern directly if it is already known. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in), dimension(:) :: irow sparsity pattern nonzero elements row indices integer, intent(in), dimension(:) :: icol sparsity pattern nonzero elements column indices integer, intent(in), optional, dimension(:) :: linear_irow linear sparsity pattern nonzero elements row indices integer, intent(in), optional, dimension(:) :: linear_icol linear sparsity pattern nonzero elements column indices real(kind=wp), intent(in), optional, dimension(:) :: linear_vals linear sparsity values (constant elements of the Jacobian) integer, intent(in), optional :: maxgrp DSM sparsity partition\n[only used if me%partition_sparsity_pattern=True ] integer, intent(in), optional, dimension(:) :: ngrp DSM sparsity partition (size n )\n[only used if me%partition_sparsity_pattern=True ] procedure, public :: select_finite_diff_method select a method in a specified class so\nthat the variable bounds are not violated\nwhen by the perturbations. private  subroutine select_finite_diff_method (me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in) :: x the variable value real(kind=wp), intent(in) :: xlow the variable lower bound real(kind=wp), intent(in) :: xhigh the variable upper bound real(kind=wp), intent(in) :: dx the perturbation value (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . procedure, public :: select_finite_diff_method_for_partition_group version of select_finite_diff_method for partitioned sparsity pattern. private  subroutine select_finite_diff_method_for_partition_group (me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds for any variable in the group. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x the variable values real(kind=wp), intent(in), dimension(:) :: xlow the variable lower bounds real(kind=wp), intent(in), dimension(:) :: xhigh the variable upper bounds real(kind=wp), intent(in), dimension(:) :: dx the perturbation values (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . procedure, public :: set_numdiff_bounds can be called to change the variable bounds. private  subroutine set_numdiff_bounds (me, xlow, xhigh) Change the variable bounds in a numdiff_type . Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(:) :: xhigh upper bounds on x procedure, public :: compute_sparsity_pattern if the user needs to compute the sparsity pattern manually.\n(otherwise it will be done the first time the Jacobian is computed) private  subroutine compute_sparsity_pattern (me, x, irow, icol, linear_irow, linear_icol, linear_vals) Computes the sparsity pattern and return it.\nUses the settings currently in the class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) procedure, public :: get_sparsity_pattern returns the sparsity pattern (if it is allocated) private  subroutine get_sparsity_pattern (me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) Returns the sparsity pattern from the class.\nIf it hasn't been computed, the output arrays will not be allocated. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) integer, intent(out), optional :: maxgrp DSM sparsity partition integer, intent(out), optional, dimension(:), allocatable :: ngrp DSM sparsity partition procedure, public :: terminate can be called by user to stop the computation private  subroutine terminate (me) A user-callable routine. When called, it will terminate\nall computations and return. The istat return code will be\nset to -1 . This can be called in the function or the info function. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me procedure, public :: failed to check if an exception was raised. private pure function failed (me) Returns True if an exception has been raised. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me Return Value logical procedure, public :: get_error_status the status of error condition private  subroutine get_error_status (me, istat, error_msg) Returns the current error code and message. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me integer, intent(out), optional :: istat error code ( istat=0 means no errors). character(len=:), intent(out), optional, allocatable :: error_msg error message string. procedure, public :: set_dpert change the dpert values private  subroutine set_dpert (me, dpert) Change the dpert vector. Can be used after the class has been initialized\nto change the perturbation step sizes (e.g., after an iteration). Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: dpert perturbation vector for x procedure, private :: destroy_sparsity_pattern destroy the sparsity pattern private  subroutine destroy_sparsity_pattern (me) Destroy the sparsity pattern in the class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me procedure, private :: compute_perturb_vector private  subroutine compute_perturb_vector (me, x, dpert, perturb_mode, dx) Compute dx , the perturbation vector for x Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dpert integer, intent(in) :: perturb_mode real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable procedure, private :: compute_perturbation_vector computes the variable perturbation factor private  subroutine compute_perturbation_vector (me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the gradients. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable procedure, private :: compute_sparsity_perturbation_vector private  subroutine compute_sparsity_perturbation_vector (me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the sparsity pattern. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable procedure, private :: perturb_x_and_compute_f private  subroutine perturb_x_and_compute_f (me, x, dx_factor, dx, df_factor, column, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in) :: column the variable to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero procedure, private :: perturb_x_and_compute_f_partitioned private  subroutine perturb_x_and_compute_f_partitioned (me, x, dx_factor, dx, df_factor, columns, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in), dimension(:) :: columns the variables to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero procedure, private :: set_numdiff_sparsity_bounds private  subroutine set_numdiff_sparsity_bounds (me, xlow, xhigh) Sets the variable bounds for sparsity in a numdiff_type .\n  These are only used for sparsity_mode=2 . Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), optional, dimension(:) :: xlow lower bounds on x to be used for\nsparsity computation. If not present,\nthen then xlow values in the class are used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh upper bounds on x to be used for\nsparsity computation. If not present,\nthen then xhigh values in the class are used. procedure, private :: set_sparsity_mode private  subroutine set_sparsity_mode (me, sparsity_mode, xlow_for_sparsity, xhigh_for_sparsity) Set sparsity mode. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. real(kind=wp), intent(in), optional, dimension(:) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. procedure, private :: generate_dense_sparsity_partition private  subroutine generate_dense_sparsity_partition (me) Generate a \"dense\" sparsity partition. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me procedure, private :: compute_jacobian_for_sparsity private  subroutine compute_jacobian_for_sparsity (me, i, class_meths, x, jac) A separate version of compute_jacobian to be used only when\n  computing the sparsity pattern in compute_sparsity_random_2 .\n  It uses class_meths and the sparsity dperts and bounds. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: i the column being computed type( meth_array ), intent(in) :: class_meths set of finite diff methods to use real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector procedure, private :: resize_sparsity_vectors private  subroutine resize_sparsity_vectors (me, n_icol, n_irow, n_linear_icol, n_linear_irow, n_linear_vals) Resize the sparsity arrays after accumulating them. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(inout) :: n_icol integer, intent(inout) :: n_irow integer, intent(inout) :: n_linear_icol integer, intent(inout) :: n_linear_irow integer, intent(inout) :: n_linear_vals procedure, private :: raise_exception private  subroutine raise_exception (me, istat, routine, error_msg) Raise an exception. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: istat error code. character(len=*), intent(in) :: routine the routine where the error was raised. character(len=*), intent(in) :: error_msg error message string. procedure, private :: clear_exceptions private  subroutine clear_exceptions (me) Clear all exceptions. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me Source Code type , public :: numdiff_type !! base type for sparsity and Jacobian computations. private logical :: exception_raised = . false . !! if true, an exception has been raised integer :: istat = 0 !! a non-zero value will cause all routine to exit. !! this can be set to `-1` by calling [[terminate]]. character ( len = :), allocatable :: error_msg !! error message (if `istat/=0`) integer :: n = 0 !! number of `x` variables integer :: m = 0 !! number of `f` functions real ( wp ), dimension (:), allocatable :: xlow !! lower bounds on `x` real ( wp ), dimension (:), allocatable :: xhigh !! upper bounds on `x` logical :: print_messages = . true . !! if true, warning messages are printed !! to the `error_unit` for any errors. integer :: chunk_size = 100 !! chuck size for allocating the arrays (>0) integer :: perturb_mode = 1 !! perturbation mode: !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), dimension (:), allocatable :: dpert !! perturbation vector for `x` logical :: partition_sparsity_pattern = . false . !! to partition the sparsity pattern using [[dsm]] type ( sparsity_pattern ) :: sparsity !! the sparsity pattern real ( wp ), dimension (:), allocatable :: xlow_for_sparsity !! lower bounds on `x` for computing sparsity (optional) real ( wp ), dimension (:), allocatable :: xhigh_for_sparsity !! upper bounds on `x` for computing sparsity (optional) real ( wp ), dimension (:), allocatable :: dpert_for_sparsity !! perturbation vector for `x` when computing !! sparsity for `sparsity_mode=4` integer :: num_sparsity_points = 3 !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. !! See [[compute_sparsity_random_2]] integer :: sparsity_perturb_mode = 1 !! perturbation mode (if `sparsity_mode=4`): !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` ! if computing the sparsity pattern, we also have an option to ! compute the linear pattern, which indicates constant elements ! of the jacobian. these elements don't need to be computed again. logical :: compute_linear_sparsity_pattern = . false . !! to also compute the linear sparsity pattern real ( wp ) :: linear_sparsity_tol = epsilon ( 1.0_wp ) !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ) :: function_precision_tol = epsilon ( 1.0_wp ) !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] integer :: mode = 1 !! **1** = use `meth` (specified methods), !! **2** = use `class` (specified class, method is selected on-the-fly). type ( finite_diff_method ), dimension (:), allocatable :: meth !! the finite difference method to use !! compute the `n`th column of the Jacobian !! `size(n)`.  Either this or `class` is used integer , dimension (:), allocatable :: class !! the class of method to use to !! compute the `n`th column of the Jacobian !! `size(n)`. Either this or `meth` is used type ( meth_array ), dimension (:), allocatable :: class_meths !! array of methods for the specified classes. !! used with `class` when `mode=2` ! parameters when using diff: real ( wp ) :: eps = 1.0e-9_wp !! tolerance parameter for [[diff]] real ( wp ) :: acc = 0.0_wp !! tolerance parameter for [[diff]] type ( function_cache ) :: cache !! if using the function cache logical :: use_diff = . false . !! if we are using the Neville's process method, !! rather than finite differences procedure ( func ), pointer :: problem_func => null () !! the user-defined function ! these are required to be defined by the user: procedure ( func ), pointer :: compute_function => null () !! compute the user-defined function !! this can point to the `problem_func` or, if using !! the cache, it points to [[compute_function_with_cache]]. procedure ( spars_f ), pointer :: compute_sparsity => null () !! for computing the sparsity pattern procedure ( info_f ), pointer :: info_function => null () !! an optional function the user can define !! which is called when each column of the jacobian is computed. !! It can be used to perform any setup operations. procedure ( jacobian_f ), pointer :: jacobian_function => null () !! the low-level function called by [[compute_jacobian]] !! that actually computes the jacobian. contains private procedure , public :: initialize => initialize_numdiff !! initialize the class procedure , public :: diff_initialize => initialize_numdiff_for_diff !! initialize the class procedure , public :: compute_jacobian !! main routine to compute the Jacobian !! using the selected options. It !! returns the sparse (vector) form. procedure , public :: compute_jacobian_dense !! return the dense `size(m,n)` !! matrix form of the Jacobian. procedure , public :: compute_jacobian_times_vector !! returns the product of the Jacobian !! matrix and an input vector procedure , public :: destroy => destroy_numdiff_type !! destroy the class procedure , public :: print_sparsity_pattern !! print the sparsity pattern in vector form to a file procedure , public :: print_sparsity_matrix !! print the sparsity pattern in matrix form to a file procedure , public :: set_sparsity_pattern !! manually set the sparsity pattern procedure , public :: select_finite_diff_method !! select a method in a specified class so !! that the variable bounds are not violated !! when by the perturbations. procedure , public :: select_finite_diff_method_for_partition_group !! version of [[select_finite_diff_method]] !! for partitioned sparsity pattern. procedure , public :: set_numdiff_bounds !! can be called to change the variable bounds. procedure , public :: compute_sparsity_pattern !! if the user needs to compute the sparsity pattern manually. !! (otherwise it will be done the first time the Jacobian is computed) procedure , public :: get_sparsity_pattern !! returns the sparsity pattern (if it is allocated) procedure , public :: terminate !! can be called by user to stop the computation procedure , public :: failed !! to check if an exception was raised. procedure , public :: get_error_status !! the status of error condition procedure , public :: set_dpert !! change the `dpert` values ! internal routines: procedure :: destroy_sparsity_pattern !! destroy the sparsity pattern procedure :: compute_perturb_vector procedure :: compute_perturbation_vector !! computes the variable perturbation factor procedure :: compute_sparsity_perturbation_vector procedure :: perturb_x_and_compute_f procedure :: perturb_x_and_compute_f_partitioned procedure :: set_numdiff_sparsity_bounds procedure :: set_sparsity_mode procedure :: generate_dense_sparsity_partition procedure :: compute_jacobian_for_sparsity procedure :: resize_sparsity_vectors procedure :: raise_exception procedure :: clear_exceptions end type numdiff_type","tags":"","url":"type/numdiff_type.html"},{"title":"func – NumDiff","text":"interface private  function func(me, x) result(fx) Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me real(kind=wp), intent(in) :: x Return Value real(kind=wp) Description interface to function for diff","tags":"","url":"interface/func.html"},{"title":"func – NumDiff","text":"interface private  subroutine func(me, x, f, funcs_to_compute) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x array of variables (size n ) real(kind=wp), intent(out), dimension(:) :: f array of functions (size m ) integer, intent(in), dimension(:) :: funcs_to_compute the elements of the\nfunction vector that need\nto be computed (the other\nare ignored) Description The function (vector array of output functions f , computed\nfrom a vector of input variables x ).\nThis must be defined for all computations.","tags":"","url":"interface/func~2.html"},{"title":"spars_f – NumDiff","text":"interface private  subroutine spars_f(me, x) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) Description The function to compute the sparsity pattern.\nIt populates the irow and icol variables in the class.","tags":"","url":"interface/spars_f.html"},{"title":"info_f – NumDiff","text":"interface private  subroutine info_f(me, column, i, x) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in), dimension(:) :: column the columns being computed. integer, intent(in) :: i perturbing these columns for the i th time (1,2,...) real(kind=wp), intent(in), dimension(:) :: x the nominal variable vector Description User-defined info function (optional).\nInforms user what is being done during Jacobian computation.\nIt can be used to perform any setup operations that need to\ndone on the user's end.","tags":"","url":"interface/info_f.html"},{"title":"jacobian_f – NumDiff","text":"interface private  subroutine jacobian_f(me, x, dx, jac) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0) for each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) Description Actual function for computing the Jacobian\ncalled by compute_jacobian .","tags":"","url":"interface/jacobian_f.html"},{"title":"vector_djb_hash – NumDiff","text":"private pure function vector_djb_hash(r) result(hash) DJB hash algorithm for a real(wp) vector. See also J. Shahbazian, Fortran hashing algorithm, July 6, 2013 Fortran Dev Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: r the vector Return Value integer(kind=ip) the hash value Called by proc~~vector_djb_hash~~CalledByGraph proc~vector_djb_hash vector_djb_hash proc~get_from_cache function_cache%get_from_cache proc~get_from_cache->proc~vector_djb_hash proc~compute_function_with_cache compute_function_with_cache proc~compute_function_with_cache->proc~get_from_cache Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function vector_djb_hash ( r ) result ( hash ) real ( wp ), dimension (:), intent ( in ) :: r !! the vector integer ( ip ) :: hash !! the hash value integer :: i !! counter hash = 5381_ip do i = 1 , size ( r ) hash = ishft ( hash , 5_ip ) + hash + transfer ( r ( i ), 1_ip ) end do end function vector_djb_hash","tags":"","url":"proc/vector_djb_hash.html"},{"title":"initialize_cache – NumDiff","text":"private  subroutine initialize_cache(me, isize, n, m, chunk_size) Initialize the cache. Must be called first before use. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in) :: n number of independant variables (x) integer, intent(in) :: m number of functions (f) integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] Calls proc~~initialize_cache~~CallsGraph proc~initialize_cache function_cache%initialize_cache proc~destroy_cache function_cache%destroy_cache proc~initialize_cache->proc~destroy_cache Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initialize_cache~~CalledByGraph proc~initialize_cache function_cache%initialize_cache proc~initialize_numdiff numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~initialize_cache proc~initialize_numdiff_for_diff numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~initialize_cache Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_cache ( me , isize , n , m , chunk_size ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: isize !! the size of the hash table integer , intent ( in ) :: n !! number of independant variables (x) integer , intent ( in ) :: m !! number of functions (f) integer , intent ( in ), optional :: chunk_size !! chunk size to speed up reallocation !! of arrays. A good value is a guess for !! the actual number of elements of `f` that !! will be saved per value of `x` [default is 100] call me % destroy () allocate ( me % c ( 0 : isize - 1 )) me % n = n me % m = m if ( present ( chunk_size )) then me % chunk_size = chunk_size else me % chunk_size = 100 end if end subroutine initialize_cache","tags":"","url":"proc/initialize_cache.html"},{"title":"print_cache – NumDiff","text":"private  subroutine print_cache(me, iunit) Print the contents of the cache. Used for debugging. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: iunit file unit for writing\n(assumed to be opened) Source Code subroutine print_cache ( me , iunit ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit for writing !! (assumed to be opened) integer :: i !! counter write ( iunit , '(A)' ) '' write ( iunit , '(A)' ) '------------------------' if ( allocated ( me % c )) then do i = 1 , size ( me % c ) if ( allocated ( me % c ( i )% x )) then write ( iunit , '(A)' ) '' write ( iunit , '(A,1X,I10)' ) 'Entry ' , i write ( iunit , '(A,1X,*(F27.16,1X))' ) 'x  :' , me % c ( i )% x if ( allocated ( me % c ( i )% f )) then write ( iunit , '(A,1X,*(I27,1X))' ) 'ifs:' , me % c ( i )% ifs write ( iunit , '(A,1X,*(F27.16,1X))' ) 'f  :' , me % c ( i )% f ( me % c ( i )% ifs ) end if write ( iunit , '(A)' ) '------------------------' end if end do else write ( iunit , '(A)' ) 'Cache is not initialized' write ( iunit , '(A)' ) '------------------------' end if write ( iunit , '(A)' ) '' end subroutine print_cache","tags":"","url":"proc/print_cache.html"},{"title":"get_from_cache – NumDiff","text":"private  subroutine get_from_cache(me, x, ifs, i, f, xfound, ffound) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x independant variable vector integer, intent(in), dimension(:) :: ifs elements of f needed integer, intent(out) :: i index in the hash table real(kind=wp), intent(out), dimension(:) :: f f(x) from the cache (if it was found) logical, intent(out) :: xfound if x was found in the cache logical, intent(out), dimension(size(ifs)) :: ffound which ifs were found in the cache Calls proc~~get_from_cache~~CallsGraph proc~get_from_cache function_cache%get_from_cache proc~vector_djb_hash vector_djb_hash proc~get_from_cache->proc~vector_djb_hash Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_from_cache~~CalledByGraph proc~get_from_cache function_cache%get_from_cache proc~compute_function_with_cache compute_function_with_cache proc~compute_function_with_cache->proc~get_from_cache Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_from_cache ( me , x , ifs , i , f , xfound , ffound ) implicit none class ( function_cache ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! independant variable vector integer , dimension (:), intent ( in ) :: ifs !! elements of `f` needed integer , intent ( out ) :: i !! index in the hash table real ( wp ), dimension (:), intent ( out ) :: f !! `f(x)` from the cache (if it was found) logical , intent ( out ) :: xfound !! if `x` was found in the cache logical , dimension ( size ( ifs )), intent ( out ) :: ffound !! which `ifs` were found in the cache integer :: j !! counter ! initialize: xfound = . false . ffound = . false . if ( allocated ( me % c )) then ! get index in the hash table: i = mod ( abs ( vector_djb_hash ( x )), int ( size ( me % c ), ip ) ) ! check the table: if ( allocated ( me % c ( i )% x ) . and . allocated ( me % c ( i )% f )) then if ( size ( me % c ( i )% x ) == size ( x ) . and . & size ( me % c ( i )% f ) == size ( f )) then if ( all ( me % c ( i )% x == x )) then xfound = . true . ! return the elements that were found in the cache: f ( me % c ( i )% ifs ) = me % c ( i )% f ( me % c ( i )% ifs ) ! what indices are in the cache? do j = 1 , size ( ifs ) ffound ( j ) = any ( ifs ( j ) == me % c ( i )% ifs ) end do end if end if end if else error stop 'Error: the cache has not been initialized.' end if end subroutine get_from_cache","tags":"","url":"proc/get_from_cache.html"},{"title":"put_in_cache – NumDiff","text":"private  subroutine put_in_cache(me, i, x, f, ifs) Put a value into the cache. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: i index in the hash table real(kind=wp), intent(in), dimension(:) :: x independant variable vector (dimension n ) real(kind=wp), intent(in), dimension(:) :: f function vector f(x) (dimension m ) integer, intent(in), dimension(:) :: ifs elements of f to add (should all be >0, <=m ) Calls proc~~put_in_cache~~CallsGraph proc~put_in_cache function_cache%put_in_cache interface~unique unique proc~put_in_cache->interface~unique proc~unique_int unique_int interface~unique->proc~unique_int proc~unique_real unique_real interface~unique->proc~unique_real interface~expand_vector expand_vector proc~unique_int->interface~expand_vector interface~sort_ascending sort_ascending proc~unique_int->interface~sort_ascending proc~unique_real->interface~expand_vector proc~unique_real->interface~sort_ascending proc~expand_vector_int expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap swap proc~sort_ascending_int->interface~swap proc~sort_ascending_real->interface~swap proc~swap_int swap_int interface~swap->proc~swap_int proc~swap_real swap_real interface~swap->proc~swap_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~put_in_cache~~CalledByGraph proc~put_in_cache function_cache%put_in_cache proc~compute_function_with_cache compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine put_in_cache ( me , i , x , f , ifs ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: i !! index in the hash table real ( wp ), dimension (:), intent ( in ) :: x !! independant variable vector (dimension `n`) real ( wp ), dimension (:), intent ( in ) :: f !! function vector `f(x)` (dimension `m`) integer , dimension (:), intent ( in ) :: ifs !! elements of `f` to add (should all be `>0, <=m`) real ( wp ), parameter :: null = huge ( 1.0_wp ) !! an unusual value to initialize arrays if ( allocated ( me % c )) then if ( i <= size ( me % c )) then if ( allocated ( me % c ( i )% x )) then ! we need to check if there is an x already there, ! which may already have some function indices present. ! if same x, then add the new indices to them. ! if a different x, then replace indices. if ( all ( me % c ( i )% x == x )) then ! this x is already present in this location. ! so merge the new f,ifs into what is already there. if ( allocated ( me % c ( i )% f )) then me % c ( i )% ifs = unique ([ me % c ( i )% ifs , ifs ],& chunk_size = me % chunk_size ) else allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% ifs = ifs end if me % c ( i )% f ( ifs ) = f ( ifs ) else ! replace existing x and f. me % c ( i )% x = x me % c ( i )% ifs = ifs if ( allocated ( me % c ( i )% f )) deallocate ( me % c ( i )% f ) allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% f ( ifs ) = f ( ifs ) end if else ! new entry in the cache: me % c ( i )% x = x allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% ifs = ifs me % c ( i )% f ( ifs ) = f ( ifs ) end if else error stop 'Error: invalid index in hash table.' end if else error stop 'Error: the cache has not been initialized.' end if end subroutine put_in_cache","tags":"","url":"proc/put_in_cache.html"},{"title":"destroy_cache – NumDiff","text":"private  subroutine destroy_cache(me) Destroy a cache. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me Called by proc~~destroy_cache~~CalledByGraph proc~destroy_cache function_cache%destroy_cache proc~initialize_cache function_cache%initialize_cache proc~initialize_cache->proc~destroy_cache proc~initialize_numdiff numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~destroy_cache proc~initialize_numdiff->proc~initialize_cache proc~initialize_numdiff_for_diff numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~destroy_cache proc~initialize_numdiff_for_diff->proc~initialize_cache Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_cache ( me ) implicit none class ( function_cache ), intent ( out ) :: me end subroutine destroy_cache","tags":"","url":"proc/destroy_cache.html"},{"title":"set_function – NumDiff","text":"private  subroutine set_function(me, f) Set the function in a diff_func .\nMust be called before diff . Type Bound diff_func Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me procedure( func ) :: f Called by proc~~set_function~~CalledByGraph proc~set_function diff_func%set_function proc~compute_jacobian_with_diff compute_jacobian_with_diff proc~compute_jacobian_with_diff->proc~set_function Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_function ( me , f ) implicit none class ( diff_func ), intent ( inout ) :: me procedure ( func ) :: f me % f => f end subroutine set_function","tags":"","url":"proc/set_function.html"},{"title":"terminate – NumDiff","text":"private  subroutine terminate(me) Can be called by the user in the function to terminate the computation.\nThis will set ifail=-1 . Type Bound diff_func Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me Source Code subroutine terminate ( me ) implicit none class ( diff_func ), intent ( inout ) :: me me % stop = . true . end subroutine terminate","tags":"","url":"proc/terminate.html"},{"title":"diff – NumDiff","text":"private  subroutine diff(me, iord, x0, xmin, xmax, eps, accr, deriv, error, ifail) the procedure diff calculates the first, second or\nthird order derivative of a function by using neville's process to\nextrapolate from a sequence of simple polynomial approximations based on\ninterpolating points distributed symmetrically about x0 (or lying only on\none side of x0 should this be necessary).  if the specified tolerance is\nnon-zero then the procedure attempts to satisfy this absolute or relative\naccuracy requirement, while if it is unsuccessful or if the tolerance is\nset to zero then the result having the minimum achievable estimated error\nis returned instead. Type Bound diff_func Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me integer, intent(in) :: iord 1, 2 or 3 specifies that the first, second or third order\nderivative,respectively, is required. real(kind=wp), intent(in) :: x0 the point at which the derivative of the function is to be calculated. real(kind=wp), intent(in) :: xmin xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: xmax xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: eps denotes the tolerance, either absolute or relative. eps=0 specifies that\nthe error is to be minimised, while eps>0 or eps<0 specifies that the\nabsolute or relative error, respectively, must not exceed abs(eps) if\npossible.  the accuracy requirement should not be made stricter than\nnecessary, since the amount of computation tends to increase as\nthe magnitude of eps decreases, and is particularly high when eps=0 . real(kind=wp), intent(in) :: accr denotes that the absolute ( accr>0 ) or relative ( accr<0 ) errors in the\ncomputed values of the function are most unlikely to exceed abs(accr) , which\nshould be as small as possible.  if the user cannot estimate accr with\ncomplete confidence, then it should be set to zero. real(kind=wp), intent(out) :: deriv the calculated value of the derivative real(kind=wp), intent(out) :: error an estimated upper bound on the magnitude of the absolute error in\nthe calculated result.  it should always be examined, since in extreme case\nmay indicate that there are no correct significant digits in the value\nreturned for derivative. integer, intent(out) :: ifail will have one of the following values on exit: 0 the procedure was successful. 1 the estimated error in the result exceeds the (non-zero) requested\n     error, but the most accurate result possible has been returned. 2 input data incorrect (derivative and error will be undefined). 3 the interval [ xmin , xmax ] is too small (derivative and error will be\n     undefined). -1 stopped by the user. Calls proc~~diff~~CallsGraph proc~diff diff_func%diff proc~faccur diff_func%faccur proc~diff->proc~faccur Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~diff~~CalledByGraph proc~diff diff_func%diff proc~compute_jacobian_with_diff compute_jacobian_with_diff proc~compute_jacobian_with_diff->proc~diff Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine diff ( me , iord , x0 , xmin , xmax , eps , accr , deriv , error , ifail ) implicit none class ( diff_func ), intent ( inout ) :: me integer , intent ( in ) :: iord !! 1, 2 or 3 specifies that the first, second or third order !! derivative,respectively, is required. real ( wp ), intent ( in ) :: x0 !! the point at which the derivative of the function is to be calculated. real ( wp ), intent ( in ) :: xmin !! `xmin`, `xmax` restrict the interpolating points to lie in [`xmin`, `xmax`], which !! should be the largest interval including `x0` in which the function is !! calculable and continuous. real ( wp ), intent ( in ) :: xmax !! `xmin`, `xmax` restrict the interpolating points to lie in [`xmin`, `xmax`], which !! should be the largest interval including `x0` in which the function is !! calculable and continuous. real ( wp ), intent ( in ) :: eps !! denotes the tolerance, either absolute or relative. `eps=0` specifies that !! the error is to be minimised, while `eps>0` or `eps<0` specifies that the !! absolute or relative error, respectively, must not exceed `abs(eps)` if !! possible.  the accuracy requirement should not be made stricter than !! necessary, since the amount of computation tends to increase as !! the magnitude of `eps` decreases, and is particularly high when `eps=0`. real ( wp ), intent ( in ) :: accr !! denotes that the absolute (`accr>0`) or relative (`accr<0`) errors in the !! computed values of the function are most unlikely to exceed `abs(accr)`, which !! should be as small as possible.  if the user cannot estimate `accr` with !! complete confidence, then it should be set to zero. real ( wp ), intent ( out ) :: deriv !! the calculated value of the derivative real ( wp ), intent ( out ) :: error !! an estimated upper bound on the magnitude of the absolute error in !! the calculated result.  it should always be examined, since in extreme case !! may indicate that there are no correct significant digits in the value !! returned for derivative. integer , intent ( out ) :: ifail !! will have one of the following values on exit: !!  *0* the procedure was successful. !!  *1* the estimated error in the result exceeds the (non-zero) requested !!      error, but the most accurate result possible has been returned. !!  *2* input data incorrect (derivative and error will be undefined). !!  *3* the interval [`xmin`, `xmax`] is too small (derivative and error will be !!      undefined). !!  *-1* stopped by the user. real ( wp ) :: acc , beta , beta4 , h , h0 , h1 , h2 , & newh1 , newh2 , heval , hprev , baseh , hacc1 , hacc2 , nhacc1 , & nhacc2 , minh , maxh , maxh1 , maxh2 , tderiv , f0 , twof0 , f1 , f2 , f3 , f4 , fmax , & maxfun , pmaxf , df1 , deltaf , pdelta , z , zpower , c0f0 , c1 , c2 , c3 , dnew , dprev , & re , te , newerr , temerr , newacc , pacc1 , pacc2 , facc1 , facc2 , acc0 , & acc1 , acc2 , relacc , twoinf , twosup , s , & d ( 10 ), denom ( 10 ), e ( 10 ), minerr ( 10 ), maxf ( 0 : 10 ), save ( 0 : 13 ), storef ( - 45 : 45 ), factor integer :: i , j , k , n , nmax , method , signh , fcount , init logical :: ignore ( 10 ), contin , saved real ( wp ) :: dummy1 , dummy2 integer , parameter :: eta = digits ( 1.0_wp ) - 1 !! minimum number of significant binary digits (apart from the !! sign digit) used to represent the mantissa of real(wp) numbers. it should !! be decreased by one if the computer truncates rather than rounds. integer , parameter :: inf = - minexponent ( 1.0_wp ) - 2 !! the largest possible positive integers subject to !! 2**(-inf) and -2**(-inf) being representable real(wp) numbers. integer , parameter :: sup = maxexponent ( 1.0_wp ) - 1 !! the largest possible positive integers subject to !! 2**sup and -2**sup being representable real(wp) numbers. real ( wp ), parameter :: sqrt2 = sqrt ( 2.0_wp ) !!  \\sqrt(2)  real ( wp ), parameter :: sqrt3 = sqrt ( 3.0_wp ) !!  \\sqrt(3)  me % stop = . false . ! execution commences with examination of input parameters if ( iord < 1 . or . iord > 3 . or . xmax <= xmin . or . & x0 > xmax . or . x0 < xmin . or . . not . associated ( me % f )) then ifail = 2 else acc = accr twoinf = 2.0_wp ** ( - inf ) twosup = 2.0_wp ** sup factor = 2.0_wp ** ( real (( inf + sup ), wp ) / 3 0.0_wp ) if ( factor < 25 6.0_wp ) factor = 25 6.0_wp maxh1 = xmax - x0 signh = 1 if ( x0 - xmin <= maxh1 ) then maxh2 = x0 - xmin else maxh2 = maxh1 maxh1 = x0 - xmin signh = - 1 end if relacc = 2.0_wp ** ( 1.0_wp - eta ) maxh1 = ( 1.0_wp - relacc ) * maxh1 maxh2 = ( 1.0_wp - relacc ) * maxh2 s = 12 8.0_wp * twoinf if ( abs ( x0 ) > 12 8.0_wp * twoinf * 2.0_wp ** eta ) s = abs ( x0 ) * 2.0_wp ** ( - eta ) if ( maxh1 < s ) then ! interval too small ifail = 3 return end if if ( acc < 0.0_wp ) then if ( - acc > relacc ) relacc = - acc acc = 0.0_wp end if ! determine the smallest spacing at which the calculated ! function values are unequal near x0. f0 = me % f ( x0 ) if ( me % stop ) then ifail = - 1 return end if twof0 = f0 + f0 if ( abs ( x0 ) > twoinf * 2.0_wp ** eta ) then h = abs ( x0 ) * 2.0_wp ** ( - eta ) z = 2.0_wp else h = twoinf z = 6 4.0_wp end if df1 = me % f ( x0 + signh * h ) - f0 if ( me % stop ) then ifail = - 1 return end if do if ( df1 /= 0.0_wp . or . z * h > maxh1 ) exit h = z * h df1 = me % f ( x0 + signh * h ) - f0 if ( me % stop ) then ifail = - 1 return end if if ( z /= 2.0_wp ) then if ( df1 /= 0.0_wp ) then h = h / z z = 2.0_wp df1 = 0.0_wp else if ( z * h > maxh1 ) z = 2.0_wp end if end if end do if ( df1 == 0.0_wp ) then ! constant function deriv = 0.0_wp error = 0.0_wp ifail = 0 return end if if ( h > maxh1 / 12 8.0_wp ) then ! minimum h too large ifail = 3 return end if h = 8.0_wp * h h1 = signh * h h0 = h1 h2 = - h1 minh = 2.0_wp ** ( - min ( inf , sup ) / iord ) if ( minh < h ) minh = h select case ( iord ) case ( 1 ) s = 8.0_wp case ( 2 ) s = 9.0_wp * sqrt3 case ( 3 ) s = 2 7.0_wp end select if ( minh > maxh1 / s ) then ifail = 3 return end if if ( minh > maxh2 / s . or . maxh2 < 12 8.0_wp * twoinf ) then method = 1 else method = 2 end if ! method 1 uses 1-sided formulae, and method 2 symmetric. ! now estimate accuracy of calculated function values. if ( method /= 2 . or . iord == 2 ) then if ( x0 /= 0.0_wp ) then dummy1 = 0.0_wp dummy2 = - h1 call me % faccur ( dummy1 , dummy2 , acc0 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return else acc0 = 0.0_wp end if end if if ( abs ( h1 ) > twosup / 12 8.0_wp ) then hacc1 = twosup else hacc1 = 12 8.0_wp * h1 end if if ( abs ( hacc1 ) / 4.0_wp < minh ) then hacc1 = 4.0_wp * signh * minh else if ( abs ( hacc1 ) > maxh1 ) then hacc1 = signh * maxh1 end if f1 = me % f ( x0 + hacc1 ) if ( me % stop ) then ifail = - 1 return end if call me % faccur ( hacc1 , h1 , acc1 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( method == 2 ) then hacc2 = - hacc1 if ( abs ( hacc2 ) > maxh2 ) hacc2 = - signh * maxh2 f1 = me % f ( x0 + hacc2 ) if ( me % stop ) then ifail = - 1 return end if call me % faccur ( hacc2 , h2 , acc2 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return end if nmax = 8 if ( eta > 36 ) nmax = 10 n = - 1 fcount = 0 deriv = 0.0_wp error = twosup init = 3 contin = . true . do n = n + 1 if (. not . contin ) exit if ( init == 3 ) then ! calculate coefficients for differentiation ! formulae and neville extrapolation algorithm if ( iord == 1 ) then beta = 2.0_wp else if ( method == 2 ) then beta = sqrt2 else beta = sqrt3 end if beta4 = beta ** 4 z = beta if ( method == 2 ) z = z ** 2 zpower = 1.0_wp do k = 1 , nmax zpower = z * zpower denom ( k ) = zpower - 1 end do if ( method == 2 . and . iord == 1 ) then e ( 1 ) = 5.0_wp e ( 2 ) = 6.3_wp do i = 3 , nmax e ( i ) = 6.81_wp end do else if (( method /= 2 . and . iord == 1 ) . or . & ( method == 2 . and . iord == 2 )) then e ( 1 ) = 1 0.0_wp e ( 2 ) = 1 6.0_wp e ( 3 ) = 2 0.36_wp e ( 4 ) = 2 3.0_wp e ( 5 ) = 2 4.46_wp do i = 6 , nmax e ( i ) = 2 6.0_wp end do if ( method == 2 . and . iord == 2 ) then do i = 1 , nmax e ( i ) = 2.0_wp * e ( i ) end do end if else if ( method /= 2 . and . iord == 2 ) then e ( 1 ) = 1 7.78_wp e ( 2 ) = 3 0.06_wp e ( 3 ) = 3 9.66_wp e ( 4 ) = 4 6.16_wp e ( 5 ) = 5 0.26_wp do i = 6 , nmax e ( i ) = 5 5.0_wp end do else if ( method == 2 . and . iord == 3 ) then e ( 1 ) = 2 5.97_wp e ( 2 ) = 4 1.22_wp e ( 3 ) = 5 0.95_wp e ( 4 ) = 5 6.4_wp e ( 5 ) = 5 9.3_wp do i = 6 , nmax e ( i ) = 6 2.0_wp end do else e ( 1 ) = 2 4.5_wp e ( 2 ) = 4 0.4_wp e ( 3 ) = 5 2.78_wp e ( 4 ) = 6 1.2_wp e ( 5 ) = 6 6.55_wp do i = 6 , nmax e ( i ) = 7 3.0_wp end do c0f0 = - twof0 / ( 3.0_wp * beta ) c1 = 3.0_wp / ( 3.0_wp * beta - 1.0_wp ) c2 = - 1.0_wp / ( 3.0_wp * ( beta - 1.0_wp )) c3 = 1.0_wp / ( 3.0_wp * beta * ( 5.0_wp - 2.0_wp * beta )) end if end if if ( init >= 2 ) then ! initialization of steplengths, accuracy and other parameters heval = signh * minh h = heval baseh = heval maxh = maxh2 if ( method == 1 ) maxh = maxh1 do k = 1 , nmax minerr ( k ) = twosup ignore ( k ) = . false . end do if ( method == 1 ) newacc = acc1 if ( method == - 1 ) newacc = acc2 if ( method == 2 ) newacc = ( acc1 + acc2 ) / 2.0_wp if ( newacc < acc ) newacc = acc if (( method /= 2 . or . iord == 2 ) . and . newacc < acc0 ) newacc = acc0 if ( method /= - 1 ) then facc1 = acc1 nhacc1 = hacc1 newh1 = h1 end if if ( method /= 1 ) then facc2 = acc2 nhacc2 = hacc2 newh2 = h2 else facc2 = 0.0_wp nhacc2 = 0.0_wp end if init = 1 j = 0 saved = . false . end if ! calculate new or initial function values if ( init == 1 . and . ( n == 0 . or . iord == 1 ) . and . & . not .( method == 2 . and . fcount >= 45 )) then if ( method == 2 ) then fcount = fcount + 1 f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if storef ( fcount ) = f1 f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if storef ( - fcount ) = f2 else j = j + 1 if ( j <= fcount ) then f1 = storef ( j * method ) else f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if end if else f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if if ( method == 2 ) then f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if end if end if if ( n == 0 ) then if ( method == 2 . and . iord == 3 ) then pdelta = f1 - f2 pmaxf = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if deltaf = f1 - f2 maxfun = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if else if ( method /= 2 . and . iord >= 2 ) then if ( iord == 2 ) then f3 = f1 else f4 = f1 heval = beta * heval f3 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if heval = beta * heval f2 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if end if ! evaluate a new approximation dnew to the derivative if ( n > nmax ) then n = nmax do i = 1 , n maxf ( i - 1 ) = maxf ( i ) end do end if if ( method == 2 ) then maxf ( n ) = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp if ( iord == 1 ) then dnew = ( f1 - f2 ) / 2.0_wp else if ( iord == 2 ) then dnew = f1 + f2 - twof0 else dnew = - pdelta pdelta = deltaf deltaf = f1 - f2 dnew = dnew + 0.5_wp * deltaf if ( maxf ( n ) < pmaxf ) maxf ( n ) = pmaxf pmaxf = maxfun maxfun = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp end if else maxf ( n ) = abs ( f1 ) if ( iord == 1 ) then dnew = f1 - f0 else if ( iord == 2 ) then dnew = ( twof0 - 3.0_wp * f3 + f1 ) / 3.0_wp if ( maxf ( n ) < abs ( f3 )) maxf ( n ) = abs ( f3 ) f3 = f2 f2 = f1 else dnew = c3 * f1 + c2 * f2 + c1 * f4 + c0f0 if ( maxf ( n ) < abs ( f2 )) maxf ( n ) = abs ( f2 ) if ( maxf ( n ) < abs ( f4 )) maxf ( n ) = abs ( f4 ) f4 = f3 f3 = f2 f2 = f1 end if end if if ( abs ( h ) > 1 ) then dnew = dnew / h ** iord else if ( 12 8.0_wp * abs ( dnew ) > twosup * abs ( h ) ** iord ) then dnew = twosup / 12 8.0_wp else dnew = dnew / h ** iord end if end if if ( init == 0 ) then ! update estimated accuracy of function values newacc = acc if (( method /= 2 . or . iord == 2 ) . and . newacc < acc0 ) newacc = acc0 if ( method /= - 1 . and . abs ( nhacc1 ) <= 1.125_wp * abs ( heval ) / beta4 ) then nhacc1 = heval pacc1 = facc1 call me % faccur ( nhacc1 , newh1 , facc1 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( facc1 < pacc1 ) facc1 = ( 3.0_wp * facc1 + pacc1 ) / 4.0_wp end if if ( method /= 1 . and . abs ( nhacc2 ) <= 1.125_wp * abs ( heval ) / beta4 ) then if ( method == 2 ) then f1 = f2 nhacc2 = - heval else nhacc2 = heval end if pacc2 = facc2 call me % faccur ( nhacc2 , newh2 , facc2 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( facc2 < pacc2 ) facc2 = ( 3.0_wp * facc2 + pacc2 ) / 4.0_wp end if if ( method == 1 . and . newacc < facc1 ) newacc = facc1 if ( method == - 1 . and . newacc < facc2 ) newacc = facc2 if ( method == 2 . and . newacc < ( facc1 + facc2 ) / 2.0_wp ) & newacc = ( facc1 + facc2 ) / 2.0_wp end if ! evaluate successive elements of the current row in the neville ! array, estimating and examining the truncation and rounding ! errors in each contin = n < nmax hprev = abs ( h ) fmax = maxf ( n ) if (( method /= 2 . or . iord == 2 ) . and . fmax < abs ( f0 )) fmax = abs ( f0 ) do k = 1 , n dprev = d ( k ) d ( k ) = dnew dnew = dprev + ( dprev - dnew ) / denom ( k ) te = abs ( dnew - d ( k )) if ( fmax < maxf ( n - k )) fmax = maxf ( n - k ) hprev = hprev / beta if ( newacc >= relacc * fmax ) then re = newacc * e ( k ) else re = relacc * fmax * e ( k ) end if if ( re /= 0.0_wp ) then if ( hprev > 1 ) then re = re / hprev ** iord else if ( 2.0_wp * re > twosup * hprev ** iord ) then re = twosup / 2.0_wp else re = re / hprev ** iord end if end if newerr = te + re if ( te > re ) newerr = 1.25_wp * newerr if (. not . ignore ( k )) then if (( init == 0 . or . ( k == 2 . and . . not . ignore ( 1 ))) & . and . newerr < error ) then deriv = d ( k ) error = newerr end if if ( init == 1 . and . n == 1 ) then tderiv = d ( 1 ) temerr = newerr end if if ( minerr ( k ) < twosup / 4.0_wp ) then s = 4.0_wp * minerr ( k ) else s = twosup end if if ( te > re . or . newerr > s ) then ignore ( k ) = . true . else contin = . true . end if if ( newerr < minerr ( k )) minerr ( k ) = newerr if ( init == 1 . and . n == 2 . and . k == 1 . and . . not . ignore ( 1 )) then if ( newerr < temerr ) then tderiv = d ( 1 ) temerr = newerr end if if ( temerr < error ) then deriv = tderiv error = temerr end if end if end if end do if ( n < nmax ) d ( n + 1 ) = dnew if ( eps < 0.0_wp ) then s = abs ( eps * deriv ) else s = eps end if if ( error <= s ) then contin = . false . else if ( init == 1 . and . ( n == 2 . or . ignore ( 1 ))) then if (( ignore ( 1 ) . or . ignore ( 2 )) . and . saved ) then saved = . false . n = 2 h = beta * save ( 0 ) heval = beta * save ( 1 ) maxf ( 0 ) = save ( 2 ) maxf ( 1 ) = save ( 3 ) maxf ( 2 ) = save ( 4 ) d ( 1 ) = save ( 5 ) d ( 2 ) = save ( 6 ) d ( 3 ) = save ( 7 ) minerr ( 1 ) = save ( 8 ) minerr ( 2 ) = save ( 9 ) if ( method == 2 . and . iord == 3 ) then pdelta = save ( 10 ) deltaf = save ( 11 ) pmaxf = save ( 12 ) maxfun = save ( 13 ) else if ( method /= 2 . and . iord >= 2 ) then f2 = save ( 10 ) f3 = save ( 11 ) if ( iord == 3 ) f4 = save ( 12 ) end if init = 0 ignore ( 1 ) = . false . ignore ( 2 ) = . false . else if (. not . ( ignore ( 1 ) . or . ignore ( 2 )) . and . n == 2 & . and . beta4 * factor * abs ( heval ) <= maxh ) then ! save all current values in case of return to current point saved = . true . save ( 0 ) = h save ( 1 ) = heval save ( 2 ) = maxf ( 0 ) save ( 3 ) = maxf ( 1 ) save ( 4 ) = maxf ( 2 ) save ( 5 ) = d ( 1 ) save ( 6 ) = d ( 2 ) save ( 7 ) = d ( 3 ) save ( 8 ) = minerr ( 1 ) save ( 9 ) = minerr ( 2 ) if ( method == 2 . and . iord == 3 ) then save ( 10 ) = pdelta save ( 11 ) = deltaf save ( 12 ) = pmaxf save ( 13 ) = maxfun else if ( method /= 2 . and . iord >= 2 ) then save ( 10 ) = f2 save ( 11 ) = f3 if ( iord == 3 ) save ( 12 ) = f4 end if h = factor * baseh heval = h baseh = h n = - 1 else init = 0 h = beta * h heval = beta * heval end if else if ( contin . and . beta * abs ( heval ) <= maxh ) then h = beta * h heval = beta * heval else if ( method /= 1 ) then contin = . true . if ( method == 2 ) then init = 3 method = - 1 if ( iord /= 2 ) then if ( x0 /= 0.0_wp ) then dummy1 = 0.0_wp dummy2 = - h0 call me % faccur ( dummy1 , dummy2 , acc0 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return else acc0 = 0.0_wp end if end if else init = 2 method = 1 end if n = - 1 signh = - signh else contin = . false . end if end do if ( eps < 0.0_wp ) then s = abs ( eps * deriv ) else s = eps end if ifail = 0 if ( eps /= 0.0_wp . and . error > s ) ifail = 1 end if end subroutine diff","tags":"","url":"proc/diff.html"},{"title":"faccur – NumDiff","text":"private  subroutine faccur(me, h0, h1, facc, x0, twoinf, f0, f1, ifail) This procedure attempts to estimate the level of rounding errors in\nthe calculated function values near the point x0+h0 by fitting a\nleast-squares straight-line approximation to the function at the\nsix points x0+h0-j*h1 , ( j = 0,1,3,5,7,9 ), and then setting facc to\ntwice the largest deviation of the function values from this line. hi is adjusted if necessary so that it is approximately 8 times the\nsmallest spacing at which the function values are unequal near x0+h0 . Type Bound diff_func Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me real(kind=wp), intent(inout) :: h0 real(kind=wp), intent(inout) :: h1 real(kind=wp), intent(out) :: facc real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: twoinf real(kind=wp), intent(in) :: f0 real(kind=wp), intent(in) :: f1 integer, intent(out) :: ifail 0 if no error, -1 if user termination. Called by proc~~faccur~~CalledByGraph proc~faccur diff_func%faccur proc~diff diff_func%diff proc~diff->proc~faccur proc~compute_jacobian_with_diff compute_jacobian_with_diff proc~compute_jacobian_with_diff->proc~diff Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine faccur ( me , h0 , h1 , facc , x0 , twoinf , f0 , f1 , ifail ) implicit none class ( diff_func ), intent ( inout ) :: me real ( wp ), intent ( inout ) :: h0 real ( wp ), intent ( inout ) :: h1 real ( wp ), intent ( out ) :: facc real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: twoinf real ( wp ), intent ( in ) :: f0 real ( wp ), intent ( in ) :: f1 integer , intent ( out ) :: ifail !! 0 if no error, -1 if user termination. real ( wp ) :: a0 , a1 , f00 , f001 , f2 , deltaf , t0 , t1 , df ( 5 ) integer :: j ifail = 0 t0 = 0.0_wp t1 = 0.0_wp if ( h0 /= 0.0_wp ) then if ( x0 + h0 /= 0.0_wp ) then f00 = f1 else h0 = 0.875_wp * h0 f00 = me % f ( x0 + h0 ) if ( me % stop ) then ifail = - 1 return end if end if if ( abs ( h1 ) >= 3 2.0_wp * twoinf ) h1 = h1 / 8.0_wp if ( 1 6.0_wp * abs ( h1 ) > abs ( h0 )) h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp f001 = me % f ( x0 + h0 - h1 ) if ( me % stop ) then ifail = - 1 return end if if ( f001 == f00 ) then if ( 25 6.0_wp * abs ( h1 ) <= abs ( h0 )) then h1 = 2.0_wp * h1 do f001 = me % f ( x0 + h0 - h1 ) if ( me % stop ) then ifail = - 1 return end if if ( f001 /= f00 . or . 25 6.0_wp * abs ( h1 ) > abs ( h0 )) exit h1 = 2.0_wp * h1 end do h1 = 8.0_wp * h1 else h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp end if else if ( 25 6.0_wp * twoinf <= abs ( h0 )) then do f001 = me % f ( x0 + h0 - h1 / 2.0_wp ) if ( me % stop ) then ifail = - 1 return end if if ( f001 == f00 . or . abs ( h1 ) < 4.0_wp * twoinf ) exit h1 = h1 / 2.0_wp end do h1 = 8.0_wp * h1 if ( 1 6.0_wp * abs ( h1 ) > abs ( h0 )) h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp else h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp end if end if else f00 = f0 end if do j = 1 , 5 f2 = me % f ( x0 + h0 - real ( 2 * j - 1 , wp ) * h1 ) if ( me % stop ) then ifail = - 1 return end if df ( j ) = f2 - f00 t0 = t0 + df ( j ) t1 = t1 + real ( 2 * j - 1 , wp ) * df ( j ) end do a0 = ( 3 3.0_wp * t0 - 5.0_wp * t1 ) / 7 3.0_wp a1 = ( - 5.0_wp * t0 + 1.2_wp * t1 ) / 7 3.0_wp facc = abs ( a0 ) do j = 1 , 5 deltaf = abs ( df ( j ) - ( a0 + real ( 2 * j - 1 , wp ) * a1 )) if ( facc < deltaf ) facc = deltaf end do facc = 2.0_wp * facc end subroutine faccur","tags":"","url":"proc/faccur.html"},{"title":"initialize_finite_difference_method – NumDiff","text":"private  function initialize_finite_difference_method(id, name, class, dx_factors, df_factors, df_den_factor) result(me) Constructor for a finite_diff_method . Note factors are input as integers for convenience, but are converted\n      to reals for the actual computations. (note: this means we can't\n      currently define methods that have non-integer factors). Arguments Type Intent Optional Attributes Name integer, intent(in) :: id unique ID for the method character(len=*), intent(in) :: name the name of the method integer, intent(in) :: class 2=backward diffs, 3=central diffs, etc... integer, intent(in), dimension(:) :: dx_factors multiplicative factors for dx perturbation integer, intent(in), dimension(:) :: df_factors multiplicative factors for accumulating function evaluations integer, intent(in) :: df_den_factor denominator factor for finite difference equation (times dx) Return Value type( finite_diff_method ) Called by proc~~initialize_finite_difference_method~~CalledByGraph proc~initialize_finite_difference_method initialize_finite_difference_method interface~finite_diff_method finite_diff_method interface~finite_diff_method->proc~initialize_finite_difference_method Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function initialize_finite_difference_method ( id , name , class , dx_factors ,& df_factors , df_den_factor ) result ( me ) implicit none type ( finite_diff_method ) :: me integer , intent ( in ) :: id !! unique ID for the method character ( len =* ), intent ( in ) :: name !! the name of the method integer , intent ( in ) :: class !! 2=backward diffs, 3=central diffs, etc... integer , dimension (:), intent ( in ) :: dx_factors !! multiplicative factors for dx perturbation integer , dimension (:), intent ( in ) :: df_factors !! multiplicative factors for accumulating function evaluations integer , intent ( in ) :: df_den_factor !! denominator factor for finite difference equation (times dx) if ( size ( dx_factors ) /= size ( df_factors )) then error stop 'Error in initialize_finite_difference_method: ' // & 'dx_factors and df_factors arrays must be the same size.' else me % id = id me % name = trim ( name ) me % class = class ! the following is not strictly necessary if the ! compiler fully supports auto-LHS allocation: allocate ( me % dx_factors ( size ( dx_factors ))) allocate ( me % df_factors ( size ( df_factors ))) me % dx_factors = real ( dx_factors , wp ) me % df_factors = real ( df_factors , wp ) me % df_den_factor = real ( df_den_factor , wp ) end if end function initialize_finite_difference_method","tags":"","url":"proc/initialize_finite_difference_method.html"},{"title":"get_all_methods_in_class – NumDiff","text":"public  function get_all_methods_in_class(class) result(list_of_methods) Returns all the methods with the given class (i.e., number of points in the formula). Arguments Type Intent Optional Attributes Name integer, intent(in) :: class the class is the number of points in the\nfinite different computation Return Value type( meth_array ) all the methods with the specified class Calls proc~~get_all_methods_in_class~~CallsGraph proc~get_all_methods_in_class get_all_methods_in_class proc~get_finite_difference_method get_finite_difference_method proc~get_all_methods_in_class->proc~get_finite_difference_method Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_all_methods_in_class~~CalledByGraph proc~get_all_methods_in_class get_all_methods_in_class proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~get_all_methods_in_class proc~initialize_numdiff numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~get_all_methods_in_class Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function get_all_methods_in_class ( class ) result ( list_of_methods ) implicit none integer , intent ( in ) :: class !! the `class` is the number of points in the !! finite different computation type ( meth_array ) :: list_of_methods !! all the methods with the specified `class` type ( finite_diff_method ) :: fd !! temp variable for getting a !! method from [[get_finite_difference_method]] integer :: id !! method id counter logical :: found !! status flag integer :: n !! temp size variable type ( finite_diff_method ), dimension (:), allocatable :: tmp !! for resizing `meth` array ! currently, the only way to do this is to call the ! get_finite_difference_method routine and see if there ! is one available. id = 0 do id = id + 1 call get_finite_difference_method ( id , fd , found ) if ( found ) then if ( fd % class == class ) then if ( allocated ( list_of_methods % meth )) then ! add to the list n = size ( list_of_methods % meth ) allocate ( tmp ( n + 1 )) tmp ( 1 : n ) = list_of_methods % meth tmp ( n + 1 ) = fd call move_alloc ( tmp , list_of_methods % meth ) ! ... this doesn't appear to work on Intel compiler ... !list_of_methods%meth = [list_of_methods%meth,fd]  ! add to the list else ! first element: allocate ( list_of_methods % meth ( 1 )) list_of_methods % meth = fd end if elseif ( fd % class > class ) then ! we assume they are in increasing order exit end if else exit ! done end if end do end function get_all_methods_in_class","tags":"","url":"proc/get_all_methods_in_class.html"},{"title":"failed – NumDiff","text":"private pure function failed(me) Returns True if an exception has been raised. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me Return Value logical Source Code pure logical function failed ( me ) implicit none class ( numdiff_type ), intent ( in ) :: me failed = me % exception_raised end function failed","tags":"","url":"proc/failed.html"},{"title":"integer_to_string – NumDiff","text":"private  function integer_to_string(i, with_sign) result(str) Convert an integer to a string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i the integer logical, intent(in), optional :: with_sign also include the sign (default is False) Return Value character(len=:), allocatable integer converted to a string Called by proc~~integer_to_string~~CalledByGraph proc~integer_to_string integer_to_string proc~get_formula finite_diff_method%get_formula proc~get_formula->proc~integer_to_string proc~set_numdiff_bounds numdiff_type%set_numdiff_bounds proc~set_numdiff_bounds->proc~integer_to_string proc~get_finite_diff_formula get_finite_diff_formula proc~get_finite_diff_formula->proc~get_formula proc~initialize_numdiff numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~set_numdiff_bounds proc~initialize_numdiff_for_diff numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~set_numdiff_bounds Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function integer_to_string ( i , with_sign ) result ( str ) implicit none integer , intent ( in ) :: i !! the integer logical , intent ( in ), optional :: with_sign !! also include the sign (default is False) character ( len = :), allocatable :: str !! integer converted to a string integer :: istat !! `iostat` code for write statement character ( len = 100 ) :: tmp !! logical :: sgn !! local copy of `with_sign` if ( present ( with_sign )) then sgn = with_sign else sgn = . false . end if if ( sgn ) then write ( tmp , '(SP,I100)' , iostat = istat ) i else write ( tmp , '(I100)' , iostat = istat ) i end if if ( istat == 0 ) then str = trim ( adjustl ( tmp )) else str = '****' end if end function integer_to_string","tags":"","url":"proc/integer_to_string.html"},{"title":"print_finite_difference_method – NumDiff","text":"private  subroutine print_finite_difference_method(me, iunit) Print the contents of a finite_diff_method . Used for debugging. Type Bound finite_diff_method Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me integer, intent(in) :: iunit file unit for printing\n(assumed to be opened) Source Code subroutine print_finite_difference_method ( me , iunit ) implicit none class ( finite_diff_method ), intent ( in ) :: me integer , intent ( in ) :: iunit !! file unit for printing !! (assumed to be opened) write ( iunit , '(A,1X,I5)' ) 'id            :' , me % id write ( iunit , '(A,1X,A)' ) 'name          :' , me % name write ( iunit , '(A,1X,I5)' ) 'class         :' , me % class write ( iunit , '(A,1X,*(I5,\",\"))' ) 'dx_factors    :' , int ( me % dx_factors ) write ( iunit , '(A,1X,*(I5,\",\"))' ) 'df_factors    :' , int ( me % df_factors ) write ( iunit , '(A,1X,I5)' ) 'df_den_factor :' , int ( me % df_den_factor ) end subroutine print_finite_difference_method","tags":"","url":"proc/print_finite_difference_method.html"},{"title":"compute_function_with_cache – NumDiff","text":"private  subroutine compute_function_with_cache(me, x, f, funcs_to_compute) Wrapper for computing the function, using the cache. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x array of variables (size n ) real(kind=wp), intent(out), dimension(:) :: f array of functions (size m ) integer, intent(in), dimension(:) :: funcs_to_compute the elements of the\nfunction vector that need\nto be computed (the other\nare ignored) Calls proc~~compute_function_with_cache~~CallsGraph proc~compute_function_with_cache compute_function_with_cache proc~get_from_cache function_cache%get_from_cache proc~compute_function_with_cache->proc~get_from_cache proc~put_in_cache function_cache%put_in_cache proc~compute_function_with_cache->proc~put_in_cache proc~vector_djb_hash vector_djb_hash proc~get_from_cache->proc~vector_djb_hash interface~unique unique proc~put_in_cache->interface~unique proc~unique_int unique_int interface~unique->proc~unique_int proc~unique_real unique_real interface~unique->proc~unique_real interface~expand_vector expand_vector proc~unique_int->interface~expand_vector interface~sort_ascending sort_ascending proc~unique_int->interface~sort_ascending proc~unique_real->interface~expand_vector proc~unique_real->interface~sort_ascending proc~expand_vector_int expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap swap proc~sort_ascending_int->interface~swap proc~sort_ascending_real->interface~swap proc~swap_int swap_int interface~swap->proc~swap_int proc~swap_real swap_real interface~swap->proc~swap_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_function_with_cache ( me , x , f , funcs_to_compute ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! array of variables (size `n`) real ( wp ), dimension (:), intent ( out ) :: f !! array of functions (size `m`) integer , dimension (:), intent ( in ) :: funcs_to_compute !! the elements of the !! function vector that need !! to be computed (the other !! are ignored) integer :: i !! index in the cache logical , dimension ( size ( funcs_to_compute )) :: ffound !! functions found in the cache logical :: xfound !! if `x` was found in the cache if ( me % exception_raised ) return ! check for exceptions call me % cache % get ( x , funcs_to_compute , i , f , xfound , ffound ) if ( xfound . and . any ( ffound )) then ! at least one of the functions was found if ( all ( ffound )) return ! all were found ! compute the ones that weren't found, ! and add them to the cache: call me % problem_func ( x , f , pack ( funcs_to_compute , mask = (. not . ffound ))) call me % cache % put ( i , x , f , pack ( funcs_to_compute , mask = (. not . ffound ))) else ! compute the function and add it to the cache: call me % problem_func ( x , f , funcs_to_compute ) call me % cache % put ( i , x , f , funcs_to_compute ) end if end subroutine compute_function_with_cache","tags":"","url":"proc/compute_function_with_cache.html"},{"title":"get_formula – NumDiff","text":"private  subroutine get_formula(me, formula) Return a string with the finite difference formula. Example For 3-point backward: dfdx = (f(x-2h)-4f(x-h)+3f(x)) / (2h) Type Bound finite_diff_method Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me character(len=:), intent(out), allocatable :: formula Calls proc~~get_formula~~CallsGraph proc~get_formula finite_diff_method%get_formula proc~integer_to_string integer_to_string proc~get_formula->proc~integer_to_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_formula~~CalledByGraph proc~get_formula finite_diff_method%get_formula proc~get_finite_diff_formula get_finite_diff_formula proc~get_finite_diff_formula->proc~get_formula Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_formula ( me , formula ) class ( finite_diff_method ), intent ( in ) :: me character ( len = :), allocatable , intent ( out ) :: formula integer :: i !! counter character ( len = :), allocatable :: x !! temp variable for integer to string conversion character ( len = :), allocatable :: f !! temp variable for integer to string conversion if ( allocated ( me % dx_factors ) . and . allocated ( me % df_factors )) then formula = 'dfdx = (' do i = 1 , size ( me % dx_factors ) if ( int ( me % df_factors ( i )) == 1 ) then if ( i == 1 ) then formula = formula // 'f(' else formula = formula // '+f(' end if elseif ( int ( me % df_factors ( i )) ==- 1 ) then formula = formula // '-f(' else if ( i == 1 ) then f = integer_to_string ( int ( me % df_factors ( i ))) else f = integer_to_string ( int ( me % df_factors ( i )), with_sign = . true .) end if formula = formula // trim ( adjustl ( f )) // 'f(' end if if ( int ( me % dx_factors ( i )) == 0 ) then formula = formula // 'x' elseif ( int ( me % dx_factors ( i )) == 1 ) then formula = formula // 'x+h' elseif ( int ( me % dx_factors ( i )) ==- 1 ) then formula = formula // 'x-h' else x = integer_to_string ( int ( me % dx_factors ( i )), with_sign = . true .) formula = formula // 'x' // trim ( adjustl ( x )) // 'h' end if formula = formula // ')' end do f = integer_to_string ( int ( me % df_den_factor )) if ( int ( me % df_den_factor ) == 1 ) then formula = formula // ') / h' else formula = formula // ') / (' // trim ( adjustl ( f )) // 'h)' end if else formula = '' end if end subroutine get_formula","tags":"","url":"proc/get_formula.html"},{"title":"get_finite_diff_formula – NumDiff","text":"public  subroutine get_finite_diff_formula(id, formula, name) Return a string with the finite difference formula.\n  Input is the method id code. See also: get_formula Arguments Type Intent Optional Attributes Name integer, intent(in) :: id the id code for the method character(len=:), intent(out), allocatable :: formula the formula string character(len=:), intent(out), optional, allocatable :: name Calls proc~~get_finite_diff_formula~~CallsGraph proc~get_finite_diff_formula get_finite_diff_formula proc~get_finite_difference_method get_finite_difference_method proc~get_finite_diff_formula->proc~get_finite_difference_method proc~get_formula finite_diff_method%get_formula proc~get_finite_diff_formula->proc~get_formula proc~integer_to_string integer_to_string proc~get_formula->proc~integer_to_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_finite_diff_formula ( id , formula , name ) implicit none integer , intent ( in ) :: id !! the id code for the method character ( len = :), allocatable , intent ( out ) :: formula !! the formula string character ( len = :), allocatable , intent ( out ), optional :: name type ( finite_diff_method ) :: fd logical :: found call get_finite_difference_method ( id , fd , found ) if ( found . and . fd % id /= 0 ) then call get_formula ( fd , formula ) if ( present ( name )) name = fd % name else formula = '' if ( present ( name )) name = '' end if end subroutine get_finite_diff_formula","tags":"","url":"proc/get_finite_diff_formula.html"},{"title":"get_finite_difference_method – NumDiff","text":"private  subroutine get_finite_difference_method(id, fd, found) Return a finite_diff_method given the id code.\n  (the id codes begin at 1, are sequential, and uniquely define the method). Available methods Where is the user-defined function of and is a \"small\" perturbation. References G. E. Mullges, F. Uhlig, \"Numerical Algorithms with Fortran\", Springer, 1996. G. W. Griffiths, \"Numerical Analysis Using R\", Cambridge University Press, 2016. Note This is the only routine that has to be changed if a new\n      finite difference method is added. Note The order within a class is assumed to be the order that we would prefer\n      to use them (e.g., central diffs are first, etc.) This is used in\n      the select_finite_diff_method routine. Arguments Type Intent Optional Attributes Name integer, intent(in) :: id the id code for the method type( finite_diff_method ), intent(out) :: fd this method (can be used\nin compute_jacobian ) logical, intent(out) :: found true if it was found Called by proc~~get_finite_difference_method~~CalledByGraph proc~get_finite_difference_method get_finite_difference_method proc~get_all_methods_in_class get_all_methods_in_class proc~get_all_methods_in_class->proc~get_finite_difference_method proc~get_finite_diff_formula get_finite_diff_formula proc~get_finite_diff_formula->proc~get_finite_difference_method proc~initialize_numdiff numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~get_finite_difference_method proc~initialize_numdiff->proc~get_all_methods_in_class proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~get_all_methods_in_class Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_finite_difference_method ( id , fd , found ) implicit none integer , intent ( in ) :: id !! the id code for the method type ( finite_diff_method ), intent ( out ) :: fd !! this method (can be used !! in [[compute_jacobian]]) logical , intent ( out ) :: found !! true if it was found found = . true . select case ( id ) ! 2 point methods case ( 1 ) ! (f(x+h)-f(x)) / h fd = finite_diff_method ( id , '2-point forward 1' , 2 ,[ 1 , 0 ],[ 1 , - 1 ], 1 ) case ( 2 ) ! (f(x)-f(x-h)) / h fd = finite_diff_method ( id , '2-point backward 1' , 2 ,[ 0 , - 1 ],[ 1 , - 1 ], 1 ) ! 3 point methods case ( 3 ) ! (f(x+h)-f(x-h)) / (2h) fd = finite_diff_method ( id , '3-point central' , 3 ,[ 1 , - 1 ],[ 1 , - 1 ], 2 ) case ( 4 ) ! (-3f(x)+4f(x+h)-f(x+2h)) / (2h) fd = finite_diff_method ( id , '3-point forward 2' , 3 ,[ 0 , 1 , 2 ],[ - 3 , 4 , - 1 ], 2 ) case ( 5 ) ! (f(x-2h)-4f(x-h)+3f(x)) / (2h) fd = finite_diff_method ( id , '3-point backward 2' , 3 ,[ - 2 , - 1 , 0 ],[ 1 , - 4 , 3 ], 2 ) ! 4 point methods case ( 6 ) ! (-2f(x-h)-3f(x)+6f(x+h)-f(x+2h)) / (6h) fd = finite_diff_method ( id , '4-point forward 2' , 4 ,[ - 1 , 0 , 1 , 2 ],[ - 2 , - 3 , 6 , - 1 ], 6 ) case ( 7 ) ! (f(x-2h)-6f(x-h)+3f(x)+2f(x+h)) / (6h) fd = finite_diff_method ( id , '4-point backward 2' , 4 ,[ - 2 , - 1 , 0 , 1 ],[ 1 , - 6 , 3 , 2 ], 6 ) case ( 8 ) ! (-11f(x)+18f(x+h)-9f(x+2h)+2f(x+3h)) / (6h) fd = finite_diff_method ( id , '4-point forward 3' , 4 ,[ 0 , 1 , 2 , 3 ],[ - 11 , 18 , - 9 , 2 ], 6 ) case ( 9 ) ! (-2f(x-3h)+9f(x-2h)-18f(x-h)+11f(x)) / (6h) fd = finite_diff_method ( id , '4-point backward 3' , 4 ,[ - 3 , - 2 , - 1 , 0 ],[ - 2 , 9 , - 18 , 11 ], 6 ) ! 5 point methods case ( 10 ) ! (f(x-2h)-8f(x-h)+8f(x+h)-f(x+2h)) / (12h) fd = finite_diff_method ( id , '5-point central' , 5 ,[ - 2 , - 1 , 1 , 2 ],[ 1 , - 8 , 8 , - 1 ], 12 ) case ( 11 ) ! (-3f(x-h)-10f(x)+18f(x+h)-6f(x+2h)+f(x+3h)) / (12h) fd = finite_diff_method ( id , '5-point forward 3' , 5 ,[ - 1 , 0 , 1 , 2 , 3 ],[ - 3 , - 10 , 18 , - 6 , 1 ], 12 ) case ( 12 ) ! (-f(x-3h)+6f(x-2h)-18f(x-h)+10f(x)+3f(x+h)) / (12h) fd = finite_diff_method ( id , '5-point backward 3' , 5 ,[ - 3 , - 2 , - 1 , 0 , 1 ],[ - 1 , 6 , - 18 , 10 , 3 ], 12 ) case ( 13 ) ! (-25f(x)+48f(x+h)-36f(x+2h)+16f(x+3h)-3f(x+4h)) / (12h) fd = finite_diff_method ( id , '5-point forward 4' , 5 ,[ 0 , 1 , 2 , 3 , 4 ],[ - 25 , 48 , - 36 , 16 , - 3 ], 12 ) case ( 14 ) ! (3f(x-4h)-16f(x-3h)+36f(x-2h)-48f(x-h)+25f(x)) / (12h) fd = finite_diff_method ( id , '5-point backward 4' , 5 ,[ - 4 , - 3 , - 2 , - 1 , 0 ],[ 3 , - 16 , 36 , - 48 , 25 ], 12 ) ! 6 point methods case ( 15 ) ! (3f(x-2h)-30f(x-h)-20f(x)+60f(x+h)-15f(x+2h)+2f(x+3h)) / (60h) fd = finite_diff_method ( id , '6-point forward 3' , 6 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 ],[ 3 , - 30 , - 20 , 60 , - 15 , 2 ], 60 ) case ( 16 ) ! (-2f(x-3h)+15f(x-2h)-60f(x-h)+20f(x)+30f(x+h)-3f(x+2h)) / (60h) fd = finite_diff_method ( id , '6-point backward 3' , 6 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ - 2 , 15 , - 60 , 20 , 30 , - 3 ], 60 ) case ( 17 ) ! (-12f(x-h)-65f(x)+120f(x+h)-60f(x+2h)+20f(x+3h)-3f(x+4h)) / (60h) fd = finite_diff_method ( id , '6-point forward 4' , 6 ,[ - 1 , 0 , 1 , 2 , 3 , 4 ],[ - 12 , - 65 , 120 , - 60 , 20 , - 3 ], 60 ) case ( 18 ) ! (3f(x-4h)-20f(x-3h)+60f(x-2h)-120f(x-h)+65f(x)+12f(x+h)) / (60h) fd = finite_diff_method ( id , '6-point backward 4' , 6 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ 3 , - 20 , 60 , - 120 , 65 , 12 ], 60 ) case ( 19 ) ! (-137f(x)+300f(x+h)-300f(x+2h)+200f(x+3h)-75f(x+4h)+12f(x+5h)) / (60h) fd = finite_diff_method ( id , '6-point forward 5' , 6 ,[ 0 , 1 , 2 , 3 , 4 , 5 ],[ - 137 , 300 , - 300 , 200 , - 75 , 12 ], 60 ) case ( 20 ) ! (-12f(x-5h)+75f(x-4h)-200f(x-3h)+300f(x-2h)-300f(x-h)+137f(x)) / (60h) fd = finite_diff_method ( id , '6-point backward 5' , 6 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ - 12 , 75 , - 200 , 300 , - 300 , 137 ], 60 ) ! 7 point methods case ( 21 ) ! (-f(x-3h)+9f(x-2h)-45f(x-h)+45f(x+h)-9f(x+2h)+f(x+3h)) / (60h) fd = finite_diff_method ( id , '7-point central' , 7 ,[ - 3 , - 2 , - 1 , 1 , 2 , 3 ],[ - 1 , 9 , - 45 , 45 , - 9 , 1 ], 60 ) case ( 22 ) ! (2f(x-2h)-24f(x-h)-35f(x)+80f(x+h)-30f(x+2h)+8f(x+3h)-f(x+4h)) / (60h) fd = finite_diff_method ( id , '7-point forward 4' , 7 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 ],[ 2 , - 24 , - 35 , 80 , - 30 , 8 , - 1 ], 60 ) case ( 23 ) ! (f(x-4h)-8f(x-3h)+30f(x-2h)-80f(x-h)+35f(x)+24f(x+h)-2f(x+2h)) / (60h) fd = finite_diff_method ( id , '7-point backward 4' , 7 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ 1 , - 8 , 30 , - 80 , 35 , 24 , - 2 ], 60 ) case ( 24 ) ! (-10f(x-h)-77f(x)+150f(x+h)-100f(x+2h)+50f(x+3h)-15f(x+4h)+2f(x+5h)) / (60h) fd = finite_diff_method ( id , '7-point forward 5' , 7 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ - 10 , - 77 , 150 , - 100 , 50 , - 15 , 2 ], 60 ) case ( 25 ) ! (-2f(x-5h)+15f(x-4h)-50f(x-3h)+100f(x-2h)-150f(x-h)+77f(x)+10f(x+h)) / (60h) fd = finite_diff_method ( id , '7-point backward 5' , 7 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ - 2 , 15 , - 50 , 100 , - 150 , 77 , 10 ], 60 ) case ( 26 ) ! (-147f(x)+360f(x+h)-450f(x+2h)+400f(x+3h)-225f(x+4h)+72f(x+5h)-10f(x+6h)) / (60h) fd = finite_diff_method ( id , '7-point forward 6' , 7 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ - 147 , 360 , - 450 , 400 , - 225 , 72 , - 10 ], 60 ) case ( 27 ) ! (10f(x-6h)-72f(x-5h)+225f(x-4h)-400f(x-3h)+450f(x-2h)-360f(x-h)+147f(x)) / (60h) fd = finite_diff_method ( id , '7-point backward 6' , 7 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ 10 , - 72 , 225 , - 400 , 450 , - 360 , 147 ], 60 ) ! 8 point methods case ( 28 ) ! (-4f(x-3h)+42f(x-2h)-252f(x-h)-105f(x)+420f(x+h)-126f(x+2h)+28f(x+3h)-3f(x+4h)) / (420h) fd = finite_diff_method ( id , '8-point forward 4' , 8 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 ],[ - 4 , 42 , - 252 , - 105 , 420 , - 126 , 28 , - 3 ], 420 ) case ( 29 ) ! (3f(x-4h)-28f(x-3h)+126f(x-2h)-420f(x-h)+105f(x)+252f(x+h)-42f(x+2h)+4f(x+3h)) / (420h) fd = finite_diff_method ( id , '8-point backward 4' , 8 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 ],[ 3 , - 28 , 126 , - 420 , 105 , 252 , - 42 , 4 ], 420 ) case ( 30 ) ! (10f(x-2h)-140f(x-h)-329f(x)+700f(x+h)-350f(x+2h)+140f(x+3h)-35f(x+4h)+4f(x+5h)) / (420h) fd = finite_diff_method ( id , '8-point forward 5' , 8 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ 10 , - 140 , - 329 , 700 , - 350 , 140 , - 35 , 4 ], 420 ) case ( 31 ) ! (-4f(x-5h)+35f(x-4h)-140f(x-3h)+350f(x-2h)-700f(x-h)+329f(x)+140f(x+h)-10f(x+2h)) / (420h) fd = finite_diff_method ( id , '8-point backward 5' , 8 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ - 4 , 35 , - 140 , 350 , - 700 , 329 , 140 , - 10 ], 420 ) case ( 32 ) ! (-60f(x-h)-609f(x)+1260f(x+h)-1050f(x+2h)+700f(x+3h)-315f(x+4h)+84f(x+5h)-10f(x+6h)) / (420h) fd = finite_diff_method ( id , '8-point forward 6' , 8 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ - 60 , - 609 , 1260 , - 1050 , 700 , - 315 , 84 , - 10 ], 420 ) case ( 33 ) ! (10f(x-6h)-84f(x-5h)+315f(x-4h)-700f(x-3h)+1050f(x-2h)-1260f(x-h)+609f(x)+60f(x+h)) / (420h) fd = finite_diff_method ( id , '8-point backward 6' , 8 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ 10 , - 84 , 315 , - 700 , 1050 , - 1260 , 609 , 60 ], 420 ) case ( 34 ) ! (-1089f(x)+2940f(x+h)-4410f(x+2h)+4900f(x+3h)-3675f(x+4h)+1764f(x+5h)-490f(x+6h)+60f(x+7h)) / (420h) fd = finite_diff_method ( id , '8-point forward 7' , 8 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],[ - 1089 , 2940 , - 4410 , 4900 , - 3675 , 1764 , - 490 , 60 ], 420 ) case ( 35 ) ! (-60f(x-7h)+490f(x-6h)-1764f(x-5h)+3675f(x-4h)-4900f(x-3h)+4410f(x-2h)-2940f(x-h)+1089f(x)) / (420h) fd = finite_diff_method ( id , '8-point backward 7' , 8 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ - 60 , 490 , - 1764 , 3675 , - 4900 , 4410 , - 2940 , 1089 ], 420 ) ! 9 point methods case ( 36 ) ! (3f(x-4h)-32f(x-3h)+168f(x-2h)-672f(x-h)+672f(x+h)-168f(x+2h)+32f(x+3h)-3f(x+4h)) / (840h) fd = finite_diff_method ( id , '9-point central' , & 9 ,[ - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 ],[ 3 , - 32 , 168 , - 672 , 672 , - 168 , 32 , - 3 ], 840 ) case ( 37 ) ! (-5f(x-3h)+60f(x-2h)-420f(x-h)-378f(x)+1050f(x+h)-420f(x+2h)+140f(x+3h)-30f(x+4h)+3f(x+5h)) / (840h) fd = finite_diff_method ( id , '9-point forward 5' , & 9 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ - 5 , 60 , - 420 , - 378 , 1050 , - 420 , 140 , - 30 , 3 ], 840 ) case ( 38 ) ! (-3f(x-5h)+30f(x-4h)-140f(x-3h)+420f(x-2h)-1050f(x-h)+378f(x)+420f(x+h)-60f(x+2h)+5f(x+3h)) / (840h) fd = finite_diff_method ( id , '9-point backward 5' , & 9 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 ],[ - 3 , 30 , - 140 , 420 , - 1050 , 378 , 420 , - 60 , 5 ], 840 ) case ( 39 ) ! (15f(x-2h)-240f(x-h)-798f(x)+1680f(x+h)-1050f(x+2h)+560f(x+3h)-210f(x+4h)+48f(x+5h)-5f(x+6h)) / (840h) fd = finite_diff_method ( id , '9-point forward 6' , & 9 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ 15 , - 240 , - 798 , 1680 , - 1050 , 560 , - 210 , 48 , - 5 ], 840 ) case ( 40 ) ! (5f(x-6h)-48f(x-5h)+210f(x-4h)-560f(x-3h)+1050f(x-2h)-1680f(x-h)+798f(x)+240f(x+h)-15f(x+2h)) / (840h) fd = finite_diff_method ( id , '9-point backward 6' , & 9 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ 5 , - 48 , 210 , - 560 , 1050 , - 1680 , 798 , 240 , - 15 ], 840 ) case ( 41 ) ! (-105f(x-h)-1338f(x)+2940f(x+h)-2940f(x+2h)+2450f(x+3h)-1470f(x+4h)+588f(x+5h)-140f(x+6h)+15f(x+7h)) / (840h) fd = finite_diff_method ( id , '9-point forward 7' , & 9 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],[ - 105 , - 1338 , 2940 , - 2940 , 2450 , - 1470 , 588 , - 140 , 15 ], 840 ) case ( 42 ) ! (-15f(x-7h)+140f(x-6h)-588f(x-5h)+1470f(x-4h)-2450f(x-3h)+2940f(x-2h)-2940f(x-h)+1338f(x)+105f(x+h)) / (840h) fd = finite_diff_method ( id , '9-point backward 7' , & 9 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ - 15 , 140 , - 588 , 1470 , - 2450 , 2940 , - 2940 , 1338 , 105 ], 840 ) case ( 43 ) ! (-2283f(x)+6720f(x+h)-11760f(x+2h)+15680f(x+3h)-14700f(x+4h)+9408f(x+5h)-3920f(x+6h)+960f(x+7h)-105f(x+8h)) / (840h) fd = finite_diff_method ( id , '9-point forward 8' , & 9 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ],[ - 2283 , 6720 , - 11760 , 15680 , - 14700 , 9408 , - 3920 , 960 , - 105 ], 840 ) case ( 44 ) ! (105f(x-8h)-960f(x-7h)+3920f(x-6h)-9408f(x-5h)+14700f(x-4h)-15680f(x-3h)+11760f(x-2h)-6720f(x-h)+2283f(x)) / (840h) fd = finite_diff_method ( id , '9-point backward 8' , & 9 ,[ - 8 , - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ 105 , - 960 , 3920 , - 9408 , 14700 , - 15680 , 11760 , - 6720 , 2283 ], 840 ) ! 11 point methods case ( 500 ) ! (-2f(x-5h)+25f(x-4h)-150f(x-3h)+600f(x-2h)-2100f(x-h)+2100f(x+h)-600f(x+2h)+150f(x+3h)-25f(x+4h)+2f(x+5h)) / (2520h) fd = finite_diff_method ( id , '11-point central' , & 11 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 ],[ - 2 , 25 , - 150 , 600 , - 2100 , 2100 , - 600 , 150 , - 25 , 2 ], 2520 ) ! 13 point methods case ( 600 ) ! (5f(x-6h)-72f(x-5h)+495f(x-4h)-2200f(x-3h)+7425f(x-2h)-23760f(x-h)+23760f(x+h)-7425f(x+2h)+2200f(x+3h)-495f(x+4h)+72f(x+5h)-5f(x+6h)) / (27720h) fd = finite_diff_method ( id , '13-point central' , & 13 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 ],& [ 5 , - 72 , 495 , - 2200 , 7425 , - 23760 , 23760 , - 7425 , 2200 , - 495 , 72 , - 5 ], 27720 ) ! 15 point methods case ( 700 ) ! (-15f(x-7h)+245f(x-6h)-1911f(x-5h)+9555f(x-4h)-35035f(x-3h)+105105f(x-2h)-315315f(x-h)+315315f(x+h)-105105f(x+2h)+35035f(x+3h)-9555f(x+4h)+1911f(x+5h)-245f(x+6h)+15f(x+7h)) / (360360h) fd = finite_diff_method ( id , '15-point central' , & 15 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],& [ - 15 , 245 , - 1911 , 9555 , - 35035 , 105105 , - 315315 , 315315 , - 105105 , 35035 , - 9555 , 1911 , - 245 , 15 ], 360360 ) ! 17 point methods case ( 800 ) ! (7f(x-8h)-128f(x-7h)+1120f(x-6h)-6272f(x-5h)+25480f(x-4h)-81536f(x-3h)+224224f(x-2h)-640640f(x-h)+640640f(x+h)-224224f(x+2h)+81536f(x+3h)-25480f(x+4h)+6272f(x+5h)-1120f(x+6h)+128f(x+7h)-7f(x+8h)) / (720720h) fd = finite_diff_method ( id , '17-point central' , & 17 ,[ - 8 , - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ],& [ 7 , - 128 , 1120 , - 6272 , 25480 , - 81536 , 224224 , - 640640 , 640640 , - 224224 , 81536 , - 25480 , 6272 , - 1120 , 128 , - 7 ], 720720 ) case default found = . false . end select end subroutine get_finite_difference_method","tags":"","url":"proc/get_finite_difference_method.html"},{"title":"select_finite_diff_method – NumDiff","text":"private  subroutine select_finite_diff_method(me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in) :: x the variable value real(kind=wp), intent(in) :: xlow the variable lower bound real(kind=wp), intent(in) :: xhigh the variable upper bound real(kind=wp), intent(in) :: dx the perturbation value (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . Called by proc~~select_finite_diff_method~~CalledByGraph proc~select_finite_diff_method numdiff_type%select_finite_diff_method proc~compute_jacobian_for_sparsity numdiff_type%compute_jacobian_for_sparsity proc~compute_jacobian_for_sparsity->proc~select_finite_diff_method proc~compute_jacobian_standard compute_jacobian_standard proc~compute_jacobian_standard->proc~select_finite_diff_method proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine select_finite_diff_method ( me , x , xlow , xhigh , dx , list_of_methods , fd , status_ok ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x !! the variable value real ( wp ), intent ( in ) :: xlow !! the variable lower bound real ( wp ), intent ( in ) :: xhigh !! the variable upper bound real ( wp ), intent ( in ) :: dx !! the perturbation value (>0) type ( meth_array ), intent ( in ) :: list_of_methods !! list of available methods to choose from type ( finite_diff_method ), intent ( out ) :: fd !! this method can be used logical , intent ( out ) :: status_ok !! true if it really doesn't violate the bounds !! (say, the bounds are very close to each other) !! if `status_ok=False`, then the first method in !! the given class is returned in `fd`. integer :: i !! counter integer :: j !! counter real ( wp ) :: xs !! if `x` is outside the bounds, this is the value !! on the nearest bound. otherwise equal to `x`. real ( wp ) :: xp !! perturbed `x` value ! initialize: status_ok = . false . if ( me % exception_raised ) return ! check for exceptions ! make sure it is within the bounds xs = min ( xhigh , max ( xlow , x )) ! try all the methods in the class: do i = 1 , size ( list_of_methods % meth ) status_ok = . true . ! will be set to false if any ! perturbation violates the bounds ! check each of the perturbations: do j = 1 , size ( list_of_methods % meth ( i )% dx_factors ) xp = xs + list_of_methods % meth ( i )% dx_factors ( j ) * dx if ( xp < xlow . or . xp > xhigh ) then status_ok = . false . exit end if end do if ( status_ok ) then ! this one is OK to use fd = list_of_methods % meth ( i ) exit end if end do if (. not . status_ok ) then ! no method was found that doesn't violate the bounds, ! so just return the first one in the list. fd = list_of_methods % meth ( 1 ) end if end subroutine select_finite_diff_method","tags":"","url":"proc/select_finite_diff_method.html"},{"title":"select_finite_diff_method_for_partition_group – NumDiff","text":"private  subroutine select_finite_diff_method_for_partition_group(me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds for any variable in the group. The x vector are only the variables in a group (not the full variable vector) Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x the variable values real(kind=wp), intent(in), dimension(:) :: xlow the variable lower bounds real(kind=wp), intent(in), dimension(:) :: xhigh the variable upper bounds real(kind=wp), intent(in), dimension(:) :: dx the perturbation values (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . Called by proc~~select_finite_diff_method_for_partition_group~~CalledByGraph proc~select_finite_diff_method_for_partition_group numdiff_type%select_finite_diff_method_for_partition_group proc~compute_jacobian_partitioned compute_jacobian_partitioned proc~compute_jacobian_partitioned->proc~select_finite_diff_method_for_partition_group Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine select_finite_diff_method_for_partition_group ( me , x , xlow , xhigh , dx ,& list_of_methods , fd , status_ok ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! the variable values real ( wp ), dimension (:), intent ( in ) :: xlow !! the variable lower bounds real ( wp ), dimension (:), intent ( in ) :: xhigh !! the variable upper bounds real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation values (>0) type ( meth_array ), intent ( in ) :: list_of_methods !! list of available methods to choose from type ( finite_diff_method ), intent ( out ) :: fd !! this method can be used logical , intent ( out ) :: status_ok !! true if it really doesn't violate the bounds !! (say, the bounds are very close to each other) !! if `status_ok=False`, then the first method in !! the given class is returned in `fd`. integer :: i !! counter integer :: j !! counter real ( wp ), dimension ( size ( x )) :: xp !! perturbed `x` values real ( wp ), dimension ( size ( x )) :: xs !! if `x` is outside the bounds, this is the value !! on the nearest bound. otherwise equal to `x`. ! initialize: status_ok = . false . if ( me % exception_raised ) return ! check for exceptions ! make sure they are within the bounds xs = min ( xhigh , max ( xlow , x )) ! try all the methods in the class: do i = 1 , size ( list_of_methods % meth ) status_ok = . true . ! will be set to false if any ! perturbation violates the bounds ! check each of the perturbations: do j = 1 , size ( list_of_methods % meth ( i )% dx_factors ) xp = xs + list_of_methods % meth ( i )% dx_factors ( j ) * dx if ( any ( xp < xlow ) . or . any ( xp > xhigh )) then status_ok = . false . exit end if end do if ( status_ok ) then ! this one is OK to use fd = list_of_methods % meth ( i ) exit end if end do if (. not . status_ok ) then ! no method was found that doesn't violate the bounds, ! so just return the first one in the list. fd = list_of_methods % meth ( 1 ) end if end subroutine select_finite_diff_method_for_partition_group","tags":"","url":"proc/select_finite_diff_method_for_partition_group.html"},{"title":"initialize_numdiff_for_diff – NumDiff","text":"private  subroutine initialize_numdiff_for_diff(me, n, m, xlow, xhigh, problem_func, sparsity_mode, info, chunk_size, eps, acc, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points, print_messages) Alternate version of initialize_numdiff routine when\nusing diff to compute the Jacobian. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] real(kind=wp), intent(in), optional :: eps tolerance parameter for diff if not present, default is 1.0e-9_wp real(kind=wp), intent(in), optional :: acc tolerance parameter for diff if not present, default is 0.0_wp integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity required if sparsity_mode=4 integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. logical, intent(in), optional :: print_messages if true, print error messages to error_unit .\ndefault is True. Calls proc~~initialize_numdiff_for_diff~~CallsGraph proc~initialize_numdiff_for_diff numdiff_type%initialize_numdiff_for_diff proc~destroy_cache function_cache%destroy_cache proc~initialize_numdiff_for_diff->proc~destroy_cache proc~initialize_cache function_cache%initialize_cache proc~initialize_numdiff_for_diff->proc~initialize_cache proc~raise_exception numdiff_type%raise_exception proc~initialize_numdiff_for_diff->proc~raise_exception proc~set_numdiff_bounds numdiff_type%set_numdiff_bounds proc~initialize_numdiff_for_diff->proc~set_numdiff_bounds proc~set_sparsity_mode numdiff_type%set_sparsity_mode proc~initialize_numdiff_for_diff->proc~set_sparsity_mode proc~initialize_cache->proc~destroy_cache proc~set_numdiff_bounds->proc~raise_exception proc~integer_to_string integer_to_string proc~set_numdiff_bounds->proc~integer_to_string proc~set_sparsity_mode->proc~raise_exception proc~set_numdiff_sparsity_bounds numdiff_type%set_numdiff_sparsity_bounds proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~set_numdiff_sparsity_bounds->proc~raise_exception Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_numdiff_for_diff ( me , n , m , xlow , xhigh ,& problem_func , sparsity_mode , info ,& chunk_size , eps , acc , cache_size ,& xlow_for_sparsity , xhigh_for_sparsity ,& dpert_for_sparsity , sparsity_perturb_mode ,& linear_sparsity_tol , function_precision_tol ,& num_sparsity_points , print_messages ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of `x` variables integer , intent ( in ) :: m !! number of `f` functions real ( wp ), dimension ( n ), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension ( n ), intent ( in ) :: xhigh !! upper bounds on `x` procedure ( func ) :: problem_func !! the user function that defines the problem !! (returns `m` functions) integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. procedure ( info_f ), optional :: info !! a function the user can define !! which is called when each column !! of the jacobian is computed. !! It can be used to perform any !! setup operations. integer , intent ( in ), optional :: chunk_size !! chunk size for allocating the arrays !! (must be >0) [default is 100] real ( wp ), intent ( in ), optional :: eps !! tolerance parameter for [[diff]] !! if not present, default is `1.0e-9_wp` real ( wp ), intent ( in ), optional :: acc !! tolerance parameter for [[diff]] !! if not present, default is `0.0_wp` integer , intent ( in ), optional :: cache_size !! if present, this is the cache size !! for the function cache !! (default is not to enable cache) real ( wp ), dimension ( n ), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: dpert_for_sparsity !! required if `sparsity_mode=4` integer , intent ( in ), optional :: sparsity_perturb_mode !! perturbation mode (required if `sparsity_mode=4`): !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` integer , intent ( in ), optional :: num_sparsity_points !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. real ( wp ), intent ( in ), optional :: linear_sparsity_tol !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ), intent ( in ), optional :: function_precision_tol !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] logical , intent ( in ), optional :: print_messages !! if true, print error messages to `error_unit`. !! default is True. logical :: cache !! if the cache is to be used me % use_diff = . true . ! cache: cache = present ( cache_size ) if ( cache ) cache = cache_size > 0 if ( cache ) then me % compute_function => compute_function_with_cache call me % cache % initialize ( cache_size , n , m ) else me % compute_function => problem_func call me % cache % destroy () end if ! functions: me % problem_func => problem_func me % jacobian_function => compute_jacobian_with_diff ! size of the problem: me % n = n me % m = m ! input variable bounds: call me % set_numdiff_bounds ( xlow , xhigh ) ! set the sparsity function call me % set_sparsity_mode ( sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) if ( sparsity_mode == 4 ) then ! these must be present, since we don't have a dpert and perturb mode for the gradients: if ( present ( dpert_for_sparsity ) . and . present ( sparsity_perturb_mode )) then me % dpert_for_sparsity = abs ( dpert_for_sparsity ) ! perturbation options: select case ( sparsity_perturb_mode ) case ( 1 : 3 ) me % sparsity_perturb_mode = sparsity_perturb_mode case default call me % raise_exception ( 1 , 'initialize_numdiff_for_diff' ,& 'sparsity_perturb_mode must be 1, 2, or 3.' ) return end select else call me % raise_exception ( 2 , 'initialize_numdiff_for_diff' ,& 'missing required inputs for sparsity mode 4' ) return end if end if ! if these aren't present, they will just keep the defaults: if ( present ( linear_sparsity_tol )) me % linear_sparsity_tol = linear_sparsity_tol if ( present ( function_precision_tol )) me % function_precision_tol = function_precision_tol if ( present ( num_sparsity_points )) me % num_sparsity_points = num_sparsity_points ! optional: if ( present ( chunk_size )) me % chunk_size = abs ( chunk_size ) if ( present ( eps )) me % eps = eps if ( present ( acc )) me % acc = acc if ( present ( info )) me % info_function => info if ( present ( print_messages )) me % print_messages = print_messages end subroutine initialize_numdiff_for_diff","tags":"","url":"proc/initialize_numdiff_for_diff.html"},{"title":"set_numdiff_bounds – NumDiff","text":"private  subroutine set_numdiff_bounds(me, xlow, xhigh) Change the variable bounds in a numdiff_type . See also set_numdiff_sparsity_bounds Note The bounds must be set when the class is initialized,\n      but this routine can be used to change them later if required. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(:) :: xhigh upper bounds on x Calls proc~~set_numdiff_bounds~~CallsGraph proc~set_numdiff_bounds numdiff_type%set_numdiff_bounds proc~integer_to_string integer_to_string proc~set_numdiff_bounds->proc~integer_to_string proc~raise_exception numdiff_type%raise_exception proc~set_numdiff_bounds->proc~raise_exception Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_numdiff_bounds~~CalledByGraph proc~set_numdiff_bounds numdiff_type%set_numdiff_bounds proc~initialize_numdiff numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~set_numdiff_bounds proc~initialize_numdiff_for_diff numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~set_numdiff_bounds Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_numdiff_bounds ( me , xlow , xhigh ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension (:), intent ( in ) :: xhigh !! upper bounds on `x` integer :: i !! counter for error print character ( len = :), allocatable :: error_info !! error message info character ( len = :), allocatable :: istr !! for integer to string character ( len = 30 ) :: xlow_str , xhigh_str !! for real to string if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % xlow )) deallocate ( me % xlow ) if ( allocated ( me % xhigh )) deallocate ( me % xhigh ) if ( size ( xlow ) /= me % n . or . size ( xhigh ) /= me % n ) then call me % raise_exception ( 3 , 'set_numdiff_bounds' ,& 'invalid size of xlow or xhigh' ) return else if ( any ( xlow >= xhigh )) then error_info = 'all xlow must be < xhigh' do i = 1 , size ( xlow ) if ( xlow ( i ) >= xhigh ( i )) then istr = integer_to_string ( i ) write ( xlow_str , '(F30.16)' ) xlow ( i ) write ( xhigh_str , '(F30.16)' ) xhigh ( i ) error_info = error_info // new_line ( '' ) // '  Error for optimization variable ' // trim ( adjustl ( istr )) // & ': xlow=' // trim ( adjustl ( xlow_str )) // & ' >= xhigh=' // trim ( adjustl ( xhigh_str )) end if end do call me % raise_exception ( 4 , 'set_numdiff_bounds' , error_info ) return else allocate ( me % xlow ( me % n )) allocate ( me % xhigh ( me % n )) me % xlow = xlow me % xhigh = xhigh end if end subroutine set_numdiff_bounds","tags":"","url":"proc/set_numdiff_bounds.html"},{"title":"set_sparsity_mode – NumDiff","text":"private  subroutine set_sparsity_mode(me, sparsity_mode, xlow_for_sparsity, xhigh_for_sparsity) Set sparsity mode. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. real(kind=wp), intent(in), optional, dimension(:) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. Calls proc~~set_sparsity_mode~~CallsGraph proc~set_sparsity_mode numdiff_type%set_sparsity_mode proc~raise_exception numdiff_type%raise_exception proc~set_sparsity_mode->proc~raise_exception proc~set_numdiff_sparsity_bounds numdiff_type%set_numdiff_sparsity_bounds proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~set_numdiff_sparsity_bounds->proc~raise_exception Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_sparsity_mode~~CalledByGraph proc~set_sparsity_mode numdiff_type%set_sparsity_mode proc~initialize_numdiff numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~set_sparsity_mode proc~initialize_numdiff_for_diff numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~set_sparsity_mode Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_sparsity_mode ( me , sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. real ( wp ), dimension (:), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension (:), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. if ( me % exception_raised ) return ! check for exceptions ! set the sparsity function select case ( sparsity_mode ) case ( 1 ) ! dense me % compute_sparsity => compute_sparsity_dense case ( 3 ) ! user defined me % compute_sparsity => null () case ( 2 ) ! three-point simple method me % compute_sparsity => compute_sparsity_random ! in this case, we have the option of specifying ! separate bounds for computing the sparsity: call me % set_numdiff_sparsity_bounds ( xlow_for_sparsity , xhigh_for_sparsity ) case ( 4 ) ! compute 2-point jacobian in specified number of points me % compute_sparsity => compute_sparsity_random_2 ! in this case, we have the option of specifying ! separate bounds for computing the sparsity: call me % set_numdiff_sparsity_bounds ( xlow_for_sparsity , xhigh_for_sparsity ) case default call me % raise_exception ( 5 , 'set_sparsity_mode' ,& 'sparsity_mode must be 1, 2, 3, or 4.' ) return end select end subroutine set_sparsity_mode","tags":"","url":"proc/set_sparsity_mode.html"},{"title":"set_numdiff_sparsity_bounds – NumDiff","text":"private  subroutine set_numdiff_sparsity_bounds(me, xlow, xhigh) Sets the variable bounds for sparsity in a numdiff_type .\n  These are only used for sparsity_mode=2 . See also set_numdiff_bounds Note This routine assumes that xlow and xhigh have already\n      been set in the class. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), optional, dimension(:) :: xlow lower bounds on x to be used for\nsparsity computation. If not present,\nthen then xlow values in the class are used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh upper bounds on x to be used for\nsparsity computation. If not present,\nthen then xhigh values in the class are used. Calls proc~~set_numdiff_sparsity_bounds~~CallsGraph proc~set_numdiff_sparsity_bounds numdiff_type%set_numdiff_sparsity_bounds proc~raise_exception numdiff_type%raise_exception proc~set_numdiff_sparsity_bounds->proc~raise_exception Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_numdiff_sparsity_bounds~~CalledByGraph proc~set_numdiff_sparsity_bounds numdiff_type%set_numdiff_sparsity_bounds proc~set_sparsity_mode numdiff_type%set_sparsity_mode proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~initialize_numdiff numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~set_sparsity_mode proc~initialize_numdiff_for_diff numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~set_sparsity_mode Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_numdiff_sparsity_bounds ( me , xlow , xhigh ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ), optional :: xlow !! lower bounds on `x` to be used for !! sparsity computation. If not present, !! then then `xlow` values in the class are used. real ( wp ), dimension (:), intent ( in ), optional :: xhigh !! upper bounds on `x` to be used for !! sparsity computation. If not present, !! then then `xhigh` values in the class are used. if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % xlow_for_sparsity )) deallocate ( me % xlow_for_sparsity ) if ( allocated ( me % xhigh_for_sparsity )) deallocate ( me % xhigh_for_sparsity ) if (. not . present ( xlow )) then allocate ( me % xlow_for_sparsity ( size ( me % xlow ))) me % xlow_for_sparsity = me % xlow else allocate ( me % xlow_for_sparsity ( size ( xlow ))) me % xlow_for_sparsity = xlow end if if (. not . present ( xhigh )) then allocate ( me % xhigh_for_sparsity ( size ( me % xhigh ))) me % xhigh_for_sparsity = me % xhigh else allocate ( me % xhigh_for_sparsity ( size ( xhigh ))) me % xhigh_for_sparsity = xhigh end if ! error checks: if ( size ( me % xlow_for_sparsity ) /= me % n . or . size ( me % xhigh_for_sparsity ) /= me % n ) then call me % raise_exception ( 6 , 'set_numdiff_sparsity_bounds' ,& 'invalid size of xlow or xhigh' ) else if ( any ( me % xlow_for_sparsity >= me % xhigh_for_sparsity )) then call me % raise_exception ( 7 , 'set_numdiff_sparsity_bounds' ,& 'all xlow must be < xhigh' ) end if end subroutine set_numdiff_sparsity_bounds","tags":"","url":"proc/set_numdiff_sparsity_bounds.html"},{"title":"set_dpert – NumDiff","text":"private  subroutine set_dpert(me, dpert) Change the dpert vector. Can be used after the class has been initialized\nto change the perturbation step sizes (e.g., after an iteration). Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: dpert perturbation vector for x Calls proc~~set_dpert~~CallsGraph proc~set_dpert numdiff_type%set_dpert proc~raise_exception numdiff_type%raise_exception proc~set_dpert->proc~raise_exception Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_dpert ( me , dpert ) class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: dpert !! perturbation vector for `x` if ( size ( dpert ) /= me % n ) then call me % raise_exception ( 29 , 'set_dpert' ,& 'incorrect size of dpert array' ) else me % dpert = abs ( dpert ) ! update end if end subroutine set_dpert","tags":"","url":"proc/set_dpert.html"},{"title":"initialize_numdiff – NumDiff","text":"private  subroutine initialize_numdiff(me, n, m, xlow, xhigh, perturb_mode, dpert, problem_func, sparsity_mode, jacobian_method, jacobian_methods, class, classes, info, chunk_size, partition_sparsity_pattern, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points) Initialize a numdiff_type class. This must be called first. Note Only one of the following inputs can be used: jacobian_method , jacobian_methods , class , or classes . Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x integer, intent(in) :: perturb_mode perturbation mode: 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), dimension(n) :: dpert perturbation vector for x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. integer, intent(in), optional :: jacobian_method id code for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: jacobian_methods id codes for the finite difference method\nto use for each variable.\nsee get_finite_difference_method integer, intent(in), optional :: class method class for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: classes method class for the finite difference methods\nto use for each variable.\nsee get_finite_difference_method procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] logical, intent(in), optional :: partition_sparsity_pattern if the sparisty pattern is to\nbe partitioned using dsm [default is False] integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity for sparsity_mode=4 , the perturbation integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. Calls proc~~initialize_numdiff~~CallsGraph proc~initialize_numdiff numdiff_type%initialize_numdiff proc~destroy_cache function_cache%destroy_cache proc~initialize_numdiff->proc~destroy_cache proc~get_all_methods_in_class get_all_methods_in_class proc~initialize_numdiff->proc~get_all_methods_in_class proc~get_finite_difference_method get_finite_difference_method proc~initialize_numdiff->proc~get_finite_difference_method proc~initialize_cache function_cache%initialize_cache proc~initialize_numdiff->proc~initialize_cache proc~raise_exception numdiff_type%raise_exception proc~initialize_numdiff->proc~raise_exception proc~set_numdiff_bounds numdiff_type%set_numdiff_bounds proc~initialize_numdiff->proc~set_numdiff_bounds proc~set_sparsity_mode numdiff_type%set_sparsity_mode proc~initialize_numdiff->proc~set_sparsity_mode proc~get_all_methods_in_class->proc~get_finite_difference_method proc~initialize_cache->proc~destroy_cache proc~set_numdiff_bounds->proc~raise_exception proc~integer_to_string integer_to_string proc~set_numdiff_bounds->proc~integer_to_string proc~set_sparsity_mode->proc~raise_exception proc~set_numdiff_sparsity_bounds numdiff_type%set_numdiff_sparsity_bounds proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~set_numdiff_sparsity_bounds->proc~raise_exception Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_numdiff ( me , n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func , sparsity_mode , jacobian_method , jacobian_methods ,& class , classes , info , chunk_size , partition_sparsity_pattern ,& cache_size , xlow_for_sparsity , xhigh_for_sparsity ,& dpert_for_sparsity , sparsity_perturb_mode ,& linear_sparsity_tol , function_precision_tol ,& num_sparsity_points ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of `x` variables integer , intent ( in ) :: m !! number of `f` functions real ( wp ), dimension ( n ), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension ( n ), intent ( in ) :: xhigh !! upper bounds on `x` integer , intent ( in ) :: perturb_mode !! perturbation mode: !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), dimension ( n ), intent ( in ) :: dpert !! perturbation vector for `x` procedure ( func ) :: problem_func !! the user function that defines the problem !! (returns `m` functions) integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. integer , intent ( in ), optional :: jacobian_method !! `id` code for the finite difference method !! to use for all `n` variables. !! see [[get_finite_difference_method]] integer , dimension ( n ), intent ( in ), optional :: jacobian_methods !! `id` codes for the finite difference method !! to use for each variable. !! see [[get_finite_difference_method]] integer , intent ( in ), optional :: class !! method class for the finite difference method !! to use for all `n` variables. !! see [[get_finite_difference_method]] integer , dimension ( n ), intent ( in ), optional :: classes !! method class for the finite difference methods !! to use for each variable. !! see [[get_finite_difference_method]] procedure ( info_f ), optional :: info !! a function the user can define !! which is called when each column !! of the jacobian is computed. !! It can be used to perform any !! setup operations. integer , intent ( in ), optional :: chunk_size !! chunk size for allocating the arrays !! (must be >0) [default is 100] logical , intent ( in ), optional :: partition_sparsity_pattern !! if the sparisty pattern is to !! be partitioned using [[DSM]] !! [default is False] integer , intent ( in ), optional :: cache_size !! if present, this is the cache size !! for the function cache !! (default is not to enable cache) real ( wp ), dimension ( n ), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: dpert_for_sparsity !! for `sparsity_mode=4`, the perturbation integer , intent ( in ), optional :: sparsity_perturb_mode !! perturbation mode (required if `sparsity_mode=4`): !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), intent ( in ), optional :: linear_sparsity_tol !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ), intent ( in ), optional :: function_precision_tol !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] integer , intent ( in ), optional :: num_sparsity_points !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. integer :: i !! counter logical :: found !! flag for [[get_finite_difference_method]] logical :: cache !! if the cache is to be used me % use_diff = . false . ! cache: cache = present ( cache_size ) if ( cache ) cache = cache_size > 0 if ( cache ) then me % compute_function => compute_function_with_cache call me % cache % initialize ( cache_size , n , m ) else me % compute_function => problem_func call me % cache % destroy () end if ! functions: me % problem_func => problem_func if ( present ( partition_sparsity_pattern )) then me % partition_sparsity_pattern = partition_sparsity_pattern else me % partition_sparsity_pattern = . false . end if ! method: if ( allocated ( me % meth )) deallocate ( me % meth ) if ( allocated ( me % class )) deallocate ( me % class ) if ( allocated ( me % class_meths )) deallocate ( me % class_meths ) if ( present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & . not . present ( class ) . and . . not . present ( classes )) then ! use the same for all variable me % mode = 1 allocate ( me % meth ( n )) do i = 1 , n call get_finite_difference_method ( jacobian_method , me % meth ( i ), found ) if (. not . found ) then call me % raise_exception ( 8 , 'initialize_numdiff' ,& 'invalid jacobian_method' ) return end if end do elseif (. not . present ( jacobian_method ) . and . present ( jacobian_methods ) . and . & . not . present ( class ) . and . . not . present ( classes )) then ! specify a separate method for each variable me % mode = 1 allocate ( me % meth ( n )) do i = 1 , n call get_finite_difference_method ( jacobian_methods ( i ), me % meth ( i ), found ) if (. not . found ) then call me % raise_exception ( 9 , 'initialize_numdiff' ,& 'invalid jacobian_methods' ) return end if end do if ( me % partition_sparsity_pattern ) then call me % raise_exception ( 10 , 'initialize_numdiff' ,& 'when using partitioned sparsity pattern, ' // & 'all columns must use the same ' // & 'finite diff method.' ) return end if elseif (. not . present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & present ( class ) . and . . not . present ( classes )) then ! use the class for all variables me % mode = 2 allocate ( me % class ( n )) me % class = class allocate ( me % class_meths ( n )) me % class_meths ( 1 ) = get_all_methods_in_class ( class ) if ( n > 1 ) me % class_meths ( 2 : n ) = me % class_meths ( 1 ) ! just copy them over elseif (. not . present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & . not . present ( class ) . and . present ( classes )) then ! specify a separate class for each variable me % mode = 2 me % class = classes allocate ( me % class_meths ( n )) do i = 1 , n me % class_meths ( i ) = get_all_methods_in_class ( me % class ( i )) end do if ( me % partition_sparsity_pattern ) then call me % raise_exception ( 11 , 'initialize_numdiff' ,& 'when using partitioned sparsity pattern, ' // & 'all columns must use the same ' // & 'finite diff method.' ) end if else call me % raise_exception ( 12 , 'initialize_numdiff' ,& 'must specify one of either ' // & 'jacobian_method, jacobian_methods, class, or classes.' ) end if ! size of the problem: me % n = n me % m = m ! input variable bounds: call me % set_numdiff_bounds ( xlow , xhigh ) ! perturbation options: select case ( perturb_mode ) case ( 1 : 3 ) me % perturb_mode = perturb_mode case default call me % raise_exception ( 13 , 'initialize_numdiff' ,& 'perturb_mode must be 1, 2, or 3.' ) return end select if ( allocated ( me % dpert )) deallocate ( me % dpert ) allocate ( me % dpert ( n )) me % dpert = abs ( dpert ) ! optional: if ( present ( info )) me % info_function => info if ( present ( chunk_size )) me % chunk_size = abs ( chunk_size ) ! set the jacobian function, depending on the options: if ( me % partition_sparsity_pattern ) then me % jacobian_function => compute_jacobian_partitioned else me % jacobian_function => compute_jacobian_standard end if ! set the sparsity function call me % set_sparsity_mode ( sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) if ( present ( linear_sparsity_tol )) me % linear_sparsity_tol = linear_sparsity_tol if ( present ( function_precision_tol )) me % function_precision_tol = function_precision_tol if ( present ( num_sparsity_points )) me % num_sparsity_points = num_sparsity_points if ( present ( dpert_for_sparsity )) then me % dpert_for_sparsity = abs ( dpert_for_sparsity ) else me % dpert_for_sparsity = dpert ! use the same dpert as the jacobian end if if ( present ( sparsity_perturb_mode )) then select case ( sparsity_perturb_mode ) case ( 1 : 3 ) me % sparsity_perturb_mode = sparsity_perturb_mode case default call me % raise_exception ( 14 , 'initialize_numdiff' ,& 'sparsity_perturb_mode must be 1, 2, or 3.' ) return end select else me % sparsity_perturb_mode = perturb_mode ! use the same perturb mode as the jacobian end if end subroutine initialize_numdiff","tags":"","url":"proc/initialize_numdiff.html"},{"title":"destroy_numdiff_type – NumDiff","text":"private  subroutine destroy_numdiff_type(me) destroy the numdiff_type class. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(out) :: me Source Code subroutine destroy_numdiff_type ( me ) implicit none class ( numdiff_type ), intent ( out ) :: me end subroutine destroy_numdiff_type","tags":"","url":"proc/destroy_numdiff_type.html"},{"title":"destroy_sparsity – NumDiff","text":"private  subroutine destroy_sparsity(me) destroy a sparsity_pattern type. Type Bound sparsity_pattern Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(out) :: me Called by proc~~destroy_sparsity~~CalledByGraph proc~destroy_sparsity sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern numdiff_type%destroy_sparsity_pattern proc~destroy_sparsity_pattern->proc~destroy_sparsity proc~compute_sparsity_dense compute_sparsity_dense proc~compute_sparsity_dense->proc~destroy_sparsity_pattern proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->proc~destroy_sparsity_pattern proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~destroy_sparsity_pattern proc~set_sparsity_pattern numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~destroy_sparsity_pattern Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_sparsity ( me ) implicit none class ( sparsity_pattern ), intent ( out ) :: me end subroutine destroy_sparsity","tags":"","url":"proc/destroy_sparsity.html"},{"title":"dsm_wrapper – NumDiff","text":"private  subroutine dsm_wrapper(me, n, m, info) Wrapper for dsm to compute the sparsity pattern partition. Type Bound sparsity_pattern Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me integer, intent(in) :: n number of columns of jacobian matrix integer, intent(in) :: m number of rows of jacobian matrix integer, intent(out) :: info status output from dsm Calls proc~~dsm_wrapper~~CallsGraph proc~dsm_wrapper sparsity_pattern%dsm_wrapper proc~dsm dsm proc~dsm_wrapper->proc~dsm proc~degr degr proc~dsm->proc~degr proc~ido ido proc~dsm->proc~ido proc~numsrt numsrt proc~dsm->proc~numsrt proc~seq seq proc~dsm->proc~seq proc~setr setr proc~dsm->proc~setr proc~slo slo proc~dsm->proc~slo proc~srtdat srtdat proc~dsm->proc~srtdat proc~ido->proc~numsrt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dsm_wrapper~~CalledByGraph proc~dsm_wrapper sparsity_pattern%dsm_wrapper proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dsm_wrapper ( me , n , m , info ) implicit none class ( sparsity_pattern ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of columns of jacobian matrix integer , intent ( in ) :: m !! number of rows of jacobian matrix integer , intent ( out ) :: info !! status output from [[dsm]] integer :: mingrp !! for call to [[dsm]] integer , dimension (:), allocatable :: ipntr !! for call to [[dsm]] integer , dimension (:), allocatable :: jpntr !! for call to [[dsm]] integer , dimension (:), allocatable :: irow !! for call to [[dsm]] !! (temp copy since [[dsm]] !! will modify it) integer , dimension (:), allocatable :: icol !! for call to [[dsm]] !! (temp copy since [[dsm]] !! will modify it) allocate ( ipntr ( m + 1 )) allocate ( jpntr ( n + 1 )) allocate ( me % ngrp ( n )) irow = me % irow icol = me % icol call dsm ( m , n , me % num_nonzero_elements ,& irow , icol ,& me % ngrp , me % maxgrp ,& mingrp , info , ipntr , jpntr ) end subroutine dsm_wrapper","tags":"","url":"proc/dsm_wrapper.html"},{"title":"columns_in_partition_group – NumDiff","text":"private  subroutine columns_in_partition_group(me, igroup, n_cols, cols, nonzero_rows, indices, status_ok) Returns the columns in a sparsity partition group. Note This is just a wrapper to get data from ngrp . Type Bound sparsity_pattern Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: igroup group number. Should be >0 and <=me%mxgrp integer, intent(out) :: n_cols number of columns in the igroup group. integer, intent(out), dimension(:), allocatable :: cols the column numbers in the igroup group.\n(if none, then it is not allocated) integer, intent(out), dimension(:), allocatable :: nonzero_rows the row numbers of all the nonzero\nJacobian elements in this group integer, intent(out), dimension(:), allocatable :: indices nonzero indices in jac for a group logical, intent(out) :: status_ok true if the partition is valid Called by proc~~columns_in_partition_group~~CalledByGraph proc~columns_in_partition_group sparsity_pattern%columns_in_partition_group proc~compute_jacobian_partitioned compute_jacobian_partitioned proc~compute_jacobian_partitioned->proc~columns_in_partition_group Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine columns_in_partition_group ( me , igroup , n_cols , cols , nonzero_rows , indices , status_ok ) implicit none class ( sparsity_pattern ), intent ( in ) :: me integer , intent ( in ) :: igroup !! group number. Should be `>0` and `<=me%mxgrp` integer , intent ( out ) :: n_cols !! number of columns in the `igroup` group. integer , dimension (:), allocatable , intent ( out ) :: cols !! the column numbers in the `igroup` group. !! (if none, then it is not allocated) integer , dimension (:), allocatable , intent ( out ) :: nonzero_rows !! the row numbers of all the nonzero !! Jacobian elements in this group integer , dimension (:), allocatable , intent ( out ) :: indices !! nonzero indices in `jac` for a group logical , intent ( out ) :: status_ok !! true if the partition is valid integer :: i !! counter integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column integer :: num_nonzero_elements_in_group !! number of nonzero elements in a group integer , dimension (:), allocatable :: col_indices !! nonzero indices in `jac` for a column if ( me % maxgrp > 0 . and . allocated ( me % ngrp )) then status_ok = . true . n_cols = count ( me % ngrp == igroup ) if ( n_cols > 0 ) then allocate ( cols ( n_cols )) cols = pack ([( i , i = 1 , size ( me % ngrp ))], mask = me % ngrp == igroup ) end if ! get all the non-zero elements in each column: num_nonzero_elements_in_group = 0 ! initialize do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % icol == cols ( i )) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to ! compute in this column num_nonzero_elements_in_group = num_nonzero_elements_in_group + & num_nonzero_elements_in_col if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) !col_indices = pack(me%indices,mask=me%icol==cols(i)) block integer :: j , n n = 0 do j = 1 , size ( me % icol ) if ( me % icol ( j ) == cols ( i )) then n = n + 1 col_indices ( n ) = j end if end do end block if ( allocated ( nonzero_rows )) then nonzero_rows = [ nonzero_rows , me % irow ( col_indices )] indices = [ indices , col_indices ] else nonzero_rows = me % irow ( col_indices ) indices = col_indices end if end if end do else status_ok = . false . end if end subroutine columns_in_partition_group","tags":"","url":"proc/columns_in_partition_group.html"},{"title":"destroy_sparsity_pattern – NumDiff","text":"private  subroutine destroy_sparsity_pattern(me) Destroy the sparsity pattern in the class. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me Calls proc~~destroy_sparsity_pattern~~CallsGraph proc~destroy_sparsity_pattern numdiff_type%destroy_sparsity_pattern proc~destroy_sparsity sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern->proc~destroy_sparsity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~destroy_sparsity_pattern~~CalledByGraph proc~destroy_sparsity_pattern numdiff_type%destroy_sparsity_pattern proc~compute_sparsity_dense compute_sparsity_dense proc~compute_sparsity_dense->proc~destroy_sparsity_pattern proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->proc~destroy_sparsity_pattern proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~destroy_sparsity_pattern proc~set_sparsity_pattern numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~destroy_sparsity_pattern Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_sparsity_pattern ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me call me % sparsity % destroy () end subroutine destroy_sparsity_pattern","tags":"","url":"proc/destroy_sparsity_pattern.html"},{"title":"compute_indices – NumDiff","text":"private  subroutine compute_indices(me) Computes the indices vector in the class. Type Bound sparsity_pattern Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me Called by proc~~compute_indices~~CalledByGraph proc~compute_indices sparsity_pattern%compute_indices proc~compute_sparsity_dense compute_sparsity_dense proc~compute_sparsity_dense->proc~compute_indices proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->proc~compute_indices proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_indices proc~set_sparsity_pattern numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~compute_indices Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_indices ( me ) implicit none class ( sparsity_pattern ), intent ( inout ) :: me integer :: i !! counter allocate ( me % indices ( me % num_nonzero_elements )) !me%indices = [(i,i=1,me%num_nonzero_elements)] do i = 1 , me % num_nonzero_elements me % indices ( i ) = i end do end subroutine compute_indices","tags":"","url":"proc/compute_indices.html"},{"title":"set_sparsity_pattern – NumDiff","text":"private  subroutine set_sparsity_pattern(me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) To specify the sparsity pattern directly if it is already known. Note If specifying the linear pattern, all three optional arguments\n      must be present. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in), dimension(:) :: irow sparsity pattern nonzero elements row indices integer, intent(in), dimension(:) :: icol sparsity pattern nonzero elements column indices integer, intent(in), optional, dimension(:) :: linear_irow linear sparsity pattern nonzero elements row indices integer, intent(in), optional, dimension(:) :: linear_icol linear sparsity pattern nonzero elements column indices real(kind=wp), intent(in), optional, dimension(:) :: linear_vals linear sparsity values (constant elements of the Jacobian) integer, intent(in), optional :: maxgrp DSM sparsity partition\n[only used if me%partition_sparsity_pattern=True ] integer, intent(in), optional, dimension(:) :: ngrp DSM sparsity partition (size n )\n[only used if me%partition_sparsity_pattern=True ] Calls proc~~set_sparsity_pattern~~CallsGraph proc~set_sparsity_pattern numdiff_type%set_sparsity_pattern proc~compute_indices sparsity_pattern%compute_indices proc~set_sparsity_pattern->proc~compute_indices proc~destroy_sparsity_pattern numdiff_type%destroy_sparsity_pattern proc~set_sparsity_pattern->proc~destroy_sparsity_pattern proc~dsm_wrapper sparsity_pattern%dsm_wrapper proc~set_sparsity_pattern->proc~dsm_wrapper proc~raise_exception numdiff_type%raise_exception proc~set_sparsity_pattern->proc~raise_exception proc~destroy_sparsity sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern->proc~destroy_sparsity proc~dsm dsm proc~dsm_wrapper->proc~dsm proc~degr degr proc~dsm->proc~degr proc~ido ido proc~dsm->proc~ido proc~numsrt numsrt proc~dsm->proc~numsrt proc~seq seq proc~dsm->proc~seq proc~setr setr proc~dsm->proc~setr proc~slo slo proc~dsm->proc~slo proc~srtdat srtdat proc~dsm->proc~srtdat proc~ido->proc~numsrt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_sparsity_pattern ( me , irow , icol , linear_irow , linear_icol , linear_vals , maxgrp , ngrp ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , dimension (:), intent ( in ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), intent ( in ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), intent ( in ), optional :: linear_irow !! linear sparsity pattern nonzero elements row indices integer , dimension (:), intent ( in ), optional :: linear_icol !! linear sparsity pattern nonzero elements column indices real ( wp ), dimension (:), intent ( in ), optional :: linear_vals !! linear sparsity values (constant elements of the Jacobian) integer , intent ( in ), optional :: maxgrp !! DSM sparsity partition !! [only used if `me%partition_sparsity_pattern=True`] integer , dimension (:), intent ( in ), optional :: ngrp !! DSM sparsity partition (size `n`) !! [only used if `me%partition_sparsity_pattern=True`] integer :: info !! status output form [[dsm]] call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions if ( size ( irow ) /= size ( icol ) . or . any ( irow > me % m ) . or . any ( icol > me % n )) then call me % raise_exception ( 15 , 'set_sparsity_pattern' ,& 'invalid inputs' ) return else me % sparsity % sparsity_computed = . true . me % sparsity % num_nonzero_elements = size ( irow ) me % sparsity % irow = irow me % sparsity % icol = icol call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then if ( present ( maxgrp ) . and . present ( ngrp )) then ! use the user-input partition: if ( maxgrp > 0 . and . all ( ngrp >= 1 . and . ngrp <= maxgrp ) . and . size ( ngrp ) == me % n ) then me % sparsity % maxgrp = maxgrp me % sparsity % ngrp = ngrp else call me % raise_exception ( 28 , 'set_sparsity_pattern' ,& 'invalid sparsity partition inputs.' ) return end if else call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 16 , 'set_sparsity_pattern' ,& 'error partitioning sparsity pattern.' ) return end if end if end if end if ! linear pattern: if ( present ( linear_irow ) . and . present ( linear_icol ) . and . present ( linear_vals )) then if ( size ( linear_irow ) /= size ( linear_icol ) . or . & size ( linear_vals ) /= size ( linear_icol ) . or . & any ( linear_irow > me % m ) . or . & any ( linear_icol > me % n )) then call me % raise_exception ( 17 , 'set_sparsity_pattern' ,& 'invalid linear sparsity pattern' ) return else me % sparsity % linear_irow = linear_irow me % sparsity % linear_icol = linear_icol me % sparsity % linear_vals = linear_vals me % sparsity % linear_sparsity_computed = . true . me % sparsity % num_nonzero_linear_elements = size ( linear_irow ) end if end if end subroutine set_sparsity_pattern","tags":"","url":"proc/set_sparsity_pattern.html"},{"title":"compute_sparsity_dense – NumDiff","text":"private  subroutine compute_sparsity_dense(me, x) assume all elements of Jacobian are non-zero. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) Calls proc~~compute_sparsity_dense~~CallsGraph proc~compute_sparsity_dense compute_sparsity_dense proc~compute_indices sparsity_pattern%compute_indices proc~compute_sparsity_dense->proc~compute_indices proc~destroy_sparsity_pattern numdiff_type%destroy_sparsity_pattern proc~compute_sparsity_dense->proc~destroy_sparsity_pattern proc~generate_dense_sparsity_partition numdiff_type%generate_dense_sparsity_partition proc~compute_sparsity_dense->proc~generate_dense_sparsity_partition proc~destroy_sparsity sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern->proc~destroy_sparsity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_sparsity_dense ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) integer :: i !! counter integer :: r !! row counter integer :: c !! column counter call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions me % sparsity % num_nonzero_elements = me % m * me % n allocate ( me % sparsity % irow ( me % sparsity % num_nonzero_elements )) allocate ( me % sparsity % icol ( me % sparsity % num_nonzero_elements )) call me % sparsity % compute_indices () ! create the dense matrix: i = 0 do c = 1 , me % n do r = 1 , me % m i = i + 1 me % sparsity % irow ( i ) = r me % sparsity % icol ( i ) = c end do end do ! No real need for this, since it can't be partitioned (all elements are true) if ( me % partition_sparsity_pattern ) call me % generate_dense_sparsity_partition () me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_dense","tags":"","url":"proc/compute_sparsity_dense.html"},{"title":"generate_dense_sparsity_partition – NumDiff","text":"private  subroutine generate_dense_sparsity_partition(me) Generate a \"dense\" sparsity partition. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me Called by proc~~generate_dense_sparsity_partition~~CalledByGraph proc~generate_dense_sparsity_partition numdiff_type%generate_dense_sparsity_partition proc~compute_sparsity_dense compute_sparsity_dense proc~compute_sparsity_dense->proc~generate_dense_sparsity_partition proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~generate_dense_sparsity_partition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine generate_dense_sparsity_partition ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer :: i !! counter if ( me % exception_raised ) return ! check for exceptions me % sparsity % maxgrp = me % n allocate ( me % sparsity % ngrp ( me % n )) me % sparsity % ngrp = [( i , i = 1 , me % n )] end subroutine generate_dense_sparsity_partition","tags":"","url":"proc/generate_dense_sparsity_partition.html"},{"title":"compute_sparsity_random – NumDiff","text":"private  subroutine compute_sparsity_random(me, x) Compute the sparsity pattern by computing the function at three\n\"random\" points in the [ xlow_for_sparsity , xhigh_for_sparsity ] interval\nand checking if the function values are the same. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n )\n(not used here) Calls proc~~compute_sparsity_random~~CallsGraph proc~compute_sparsity_random compute_sparsity_random interface~expand_vector expand_vector proc~compute_sparsity_random->interface~expand_vector proc~compute_indices sparsity_pattern%compute_indices proc~compute_sparsity_random->proc~compute_indices proc~destroy_sparsity_pattern numdiff_type%destroy_sparsity_pattern proc~compute_sparsity_random->proc~destroy_sparsity_pattern proc~dsm_wrapper sparsity_pattern%dsm_wrapper proc~compute_sparsity_random->proc~dsm_wrapper proc~equal_within_tol equal_within_tol proc~compute_sparsity_random->proc~equal_within_tol proc~raise_exception numdiff_type%raise_exception proc~compute_sparsity_random->proc~raise_exception proc~resize_sparsity_vectors numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random->proc~resize_sparsity_vectors proc~expand_vector_int expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real expand_vector_real interface~expand_vector->proc~expand_vector_real proc~destroy_sparsity sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern->proc~destroy_sparsity proc~dsm dsm proc~dsm_wrapper->proc~dsm proc~resize_sparsity_vectors->interface~expand_vector proc~degr degr proc~dsm->proc~degr proc~ido ido proc~dsm->proc~ido proc~numsrt numsrt proc~dsm->proc~numsrt proc~seq seq proc~dsm->proc~seq proc~setr setr proc~dsm->proc~setr proc~slo slo proc~dsm->proc~slo proc~srtdat srtdat proc~dsm->proc~srtdat proc~ido->proc~numsrt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_sparsity_random ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) !! (not used here) integer :: i !! column counter integer :: j !! row counter integer :: n_icol !! `icol` size counter integer :: n_irow !! `irow` size counter integer :: n_linear_icol !! `linear_icol` size counter integer :: n_linear_irow !! `linear_irow` size counter integer :: n_linear_vals !! `linear_vals` size counter integer , dimension ( me % m ) :: idx !! indices to compute `[1,2,...,m]` real ( wp ), dimension ( me % n ) :: x1 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x2 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x3 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x4 !! perturbed variable vector real ( wp ), dimension ( me % m ) :: f1 !! function evaluation real ( wp ), dimension ( me % m ) :: f2 !! function evaluation real ( wp ), dimension ( me % m ) :: f3 !! function evaluation real ( wp ), dimension ( me % m ) :: f4 !! function evaluation real ( wp ) :: dfdx1 !! for linear sparsity estimation real ( wp ) :: dfdx2 !! for linear sparsity estimation real ( wp ) :: dfdx3 !! for linear sparsity estimation real ( wp ) :: dfdx !! for linear sparsity estimation integer :: info !! status output form [[dsm]] real ( wp ), dimension ( 4 ), parameter :: coeffs = [ 0.20123456787654321_wp ,& 0.40123456787654321_wp ,& 0.60123456787654321_wp ,& 0.80123456787654321_wp ] !! Pick three pseudo-random points roughly equally spaced. !! (add some noise in attempt to avoid freak zeros) !!```` !! xlow---|----|--x--|---xhigh !!        1    2     3 !!```` !! !! Also using an extra point to estimate the !! constant elements of the Jacobian. ! initialize: call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions ! error check: if (. not . allocated ( me % xlow_for_sparsity ) . or . . not . allocated ( me % xhigh_for_sparsity )) then call me % raise_exception ( 18 , 'compute_sparsity_random' ,& 'the x bounds have not been set.' ) return end if associate ( xlow => me % xlow_for_sparsity , xhigh => me % xhigh_for_sparsity ) ! we will compute all the functions: idx = [( i , i = 1 , me % m )] n_icol = 0 ! initialize vector size counters n_irow = 0 n_linear_icol = 0 n_linear_irow = 0 n_linear_vals = 0 ! define a nominal point roughly in the middle: x2 = xlow + ( xhigh - xlow ) * coeffs ( 2 ) call me % compute_function ( x2 , f2 , idx ) if ( me % exception_raised ) return ! check for exceptions if ( me % compute_linear_sparsity_pattern ) then ! we need another point where we perturb all the variables ! to check to make sure it is linear in only one variable. x4 = xlow + ( xhigh - xlow ) * coeffs ( 4 ) call me % compute_function ( x4 , f4 , idx ) if ( me % exception_raised ) return ! check for exceptions end if do i = 1 , me % n ! columns of Jacobian ! restore nominal: x1 = x2 x3 = x2 x1 ( i ) = xlow ( i ) + ( xhigh ( i ) - xlow ( i )) * coeffs ( 1 ) x3 ( i ) = xlow ( i ) + ( xhigh ( i ) - xlow ( i )) * coeffs ( 3 ) call me % compute_function ( x1 , f1 , idx ) if ( me % exception_raised ) return ! check for exceptions call me % compute_function ( x3 , f3 , idx ) if ( me % exception_raised ) return ! check for exceptions do j = 1 , me % m ! each function (rows of Jacobian) if ( equal_within_tol ([ f1 ( j ), f2 ( j ), f3 ( j )], me % function_precision_tol )) then ! no change in the function, so no sparsity element here. cycle else if ( me % compute_linear_sparsity_pattern ) then ! if computing the linear pattern separately. ! do the three points lie on a line? (x1,f1) -> (x2, f2), -> (x3,f3) ! [check that the slopes are equal within a tolerance] dfdx1 = ( f1 ( j ) - f2 ( j )) / ( x1 ( i ) - x2 ( i )) ! slope of line from 1->2 dfdx2 = ( f1 ( j ) - f3 ( j )) / ( x1 ( i ) - x3 ( i )) ! slope of line from 1->3 dfdx3 = ( f1 ( j ) - f4 ( j )) / ( x1 ( i ) - x4 ( i )) ! slope of line from 1->4 if ( equal_within_tol ([ dfdx1 , dfdx2 , dfdx3 ], me % linear_sparsity_tol )) then ! this is a linear element (constant value) dfdx = ( dfdx1 + dfdx2 + dfdx3 ) / 3.0_wp ! just take the average and use that call expand_vector ( me % sparsity % linear_icol , n_linear_icol , me % chunk_size , val = i ) call expand_vector ( me % sparsity % linear_irow , n_linear_irow , me % chunk_size , val = j ) call expand_vector ( me % sparsity % linear_vals , n_linear_vals , me % chunk_size , val = dfdx ) cycle ! this element will not be added to the nonlinear pattern end if end if ! otherwise, add it to the nonlinear pattern: call expand_vector ( me % sparsity % icol , n_icol , me % chunk_size , val = i ) call expand_vector ( me % sparsity % irow , n_irow , me % chunk_size , val = j ) end if end do end do ! resize to correct size: call me % resize_sparsity_vectors ( n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) end associate call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 19 , 'compute_sparsity_random' ,& 'error partitioning sparsity pattern.' ) return end if end if ! finished: me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_random","tags":"","url":"proc/compute_sparsity_random.html"},{"title":"resize_sparsity_vectors – NumDiff","text":"private  subroutine resize_sparsity_vectors(me, n_icol, n_irow, n_linear_icol, n_linear_irow, n_linear_vals) Resize the sparsity arrays after accumulating them. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(inout) :: n_icol integer, intent(inout) :: n_irow integer, intent(inout) :: n_linear_icol integer, intent(inout) :: n_linear_irow integer, intent(inout) :: n_linear_vals Calls proc~~resize_sparsity_vectors~~CallsGraph proc~resize_sparsity_vectors numdiff_type%resize_sparsity_vectors interface~expand_vector expand_vector proc~resize_sparsity_vectors->interface~expand_vector proc~expand_vector_int expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real expand_vector_real interface~expand_vector->proc~expand_vector_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~resize_sparsity_vectors~~CalledByGraph proc~resize_sparsity_vectors numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->proc~resize_sparsity_vectors proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~resize_sparsity_vectors Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine resize_sparsity_vectors ( me , n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( inout ) :: n_icol integer , intent ( inout ) :: n_irow integer , intent ( inout ) :: n_linear_icol integer , intent ( inout ) :: n_linear_irow integer , intent ( inout ) :: n_linear_vals if ( me % exception_raised ) return ! check for exceptions ! resize to correct size: if ( allocated ( me % sparsity % icol )) then call expand_vector ( me % sparsity % icol , n_icol , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % irow , n_irow , me % chunk_size , finished = . true .) me % sparsity % num_nonzero_elements = size ( me % sparsity % irow ) else me % sparsity % num_nonzero_elements = 0 end if ! linear pattern (note: there may be no linear elements): me % sparsity % linear_sparsity_computed = me % compute_linear_sparsity_pattern . and . & allocated ( me % sparsity % linear_vals ) if ( me % sparsity % linear_sparsity_computed ) then call expand_vector ( me % sparsity % linear_icol , n_linear_icol , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % linear_irow , n_linear_irow , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % linear_vals , n_linear_vals , me % chunk_size , finished = . true .) me % sparsity % num_nonzero_linear_elements = n_linear_vals else me % sparsity % num_nonzero_linear_elements = 0 end if end subroutine resize_sparsity_vectors","tags":"","url":"proc/resize_sparsity_vectors.html"},{"title":"compute_sparsity_random_2 – NumDiff","text":"private  subroutine compute_sparsity_random_2(me, x) Compute the sparsity pattern by computing a 2-point jacobian at a specified\nnumber of \"random\" points ( num_sparsity_points ) in the\n[ xlow_for_sparsity , xhigh_for_sparsity ] interval and checking if\nthey are the same. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n )\n(not used here) Calls proc~~compute_sparsity_random_2~~CallsGraph proc~compute_sparsity_random_2 compute_sparsity_random_2 interface~expand_vector expand_vector proc~compute_sparsity_random_2->interface~expand_vector proc~compute_indices sparsity_pattern%compute_indices proc~compute_sparsity_random_2->proc~compute_indices proc~compute_jacobian_for_sparsity numdiff_type%compute_jacobian_for_sparsity proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity proc~destroy_sparsity_pattern numdiff_type%destroy_sparsity_pattern proc~compute_sparsity_random_2->proc~destroy_sparsity_pattern proc~divide_interval divide_interval proc~compute_sparsity_random_2->proc~divide_interval proc~dsm_wrapper sparsity_pattern%dsm_wrapper proc~compute_sparsity_random_2->proc~dsm_wrapper proc~equal_within_tol equal_within_tol proc~compute_sparsity_random_2->proc~equal_within_tol proc~generate_dense_sparsity_partition numdiff_type%generate_dense_sparsity_partition proc~compute_sparsity_random_2->proc~generate_dense_sparsity_partition proc~get_all_methods_in_class get_all_methods_in_class proc~compute_sparsity_random_2->proc~get_all_methods_in_class proc~raise_exception numdiff_type%raise_exception proc~compute_sparsity_random_2->proc~raise_exception proc~resize_sparsity_vectors numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random_2->proc~resize_sparsity_vectors proc~expand_vector_int expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real expand_vector_real interface~expand_vector->proc~expand_vector_real proc~compute_sparsity_perturbation_vector numdiff_type%compute_sparsity_perturbation_vector proc~compute_jacobian_for_sparsity->proc~compute_sparsity_perturbation_vector proc~perturb_x_and_compute_f numdiff_type%perturb_x_and_compute_f proc~compute_jacobian_for_sparsity->proc~perturb_x_and_compute_f proc~select_finite_diff_method numdiff_type%select_finite_diff_method proc~compute_jacobian_for_sparsity->proc~select_finite_diff_method proc~destroy_sparsity sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern->proc~destroy_sparsity interface~unique unique proc~divide_interval->interface~unique proc~dsm dsm proc~dsm_wrapper->proc~dsm proc~get_finite_difference_method get_finite_difference_method proc~get_all_methods_in_class->proc~get_finite_difference_method proc~resize_sparsity_vectors->interface~expand_vector proc~unique_int unique_int interface~unique->proc~unique_int proc~unique_real unique_real interface~unique->proc~unique_real proc~compute_perturb_vector numdiff_type%compute_perturb_vector proc~compute_sparsity_perturbation_vector->proc~compute_perturb_vector proc~degr degr proc~dsm->proc~degr proc~ido ido proc~dsm->proc~ido proc~numsrt numsrt proc~dsm->proc~numsrt proc~seq seq proc~dsm->proc~seq proc~setr setr proc~dsm->proc~setr proc~slo slo proc~dsm->proc~slo proc~srtdat srtdat proc~dsm->proc~srtdat proc~compute_perturb_vector->proc~raise_exception proc~ido->proc~numsrt proc~unique_int->interface~expand_vector interface~sort_ascending sort_ascending proc~unique_int->interface~sort_ascending proc~unique_real->interface~expand_vector proc~unique_real->interface~sort_ascending proc~sort_ascending_int sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap swap proc~sort_ascending_int->interface~swap proc~sort_ascending_real->interface~swap proc~swap_int swap_int interface~swap->proc~swap_int proc~swap_real swap_real interface~swap->proc~swap_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_sparsity_random_2 ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) !! (not used here) type :: jac_type !! so we can define an array of jacobian columns real ( wp ), dimension (:), allocatable :: jac !! a column of the jacobian end type jac_type real ( wp ), dimension (:), allocatable :: coeffs !! coefficients for computing `xp` real ( wp ), dimension (:,:), allocatable :: xp !! perturbed `x` array (size `n,num_sparsity_points`) type ( jac_type ), dimension (:), allocatable :: jac_array !! array of jacobian columns type ( sparsity_pattern ) :: tmp_sparsity_pattern !! will accumulate the pattern here !! and copy it into the class when !! finished. integer :: i !! counter for the number of points integer :: j !! counter integer :: icol !! column counter integer :: irow !! row counter real ( wp ) :: dfdx !! value of a jacobian element integer :: n_icol !! `icol` size counter integer :: n_irow !! `irow` size counter integer :: n_linear_icol !! `linear_icol` size counter integer :: n_linear_irow !! `linear_irow` size counter integer :: n_linear_vals !! `linear_vals` size counter type ( meth_array ) :: class_meths !! set of finite diff methods to use real ( wp ), dimension (:), allocatable :: jac !! array of jacobian element values integer :: info !! status output form [[dsm]] ! initialize: call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions ! error check: if (. not . allocated ( me % xlow_for_sparsity ) . or . . not . allocated ( me % xhigh_for_sparsity )) then call me % raise_exception ( 20 , 'compute_sparsity_random_2' ,& 'the x bounds have not been set.' ) return end if ! compute the coefficients: coeffs = divide_interval ( me % num_sparsity_points ) ! save the initial settings: tmp_sparsity_pattern = me % sparsity ! we create a provisional sparsity pattern here, ! to compute one row at a time: me % sparsity % irow = [( irow , irow = 1 , me % m )] me % sparsity % sparsity_computed = . true . me % sparsity % num_nonzero_elements = me % m call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) call me % generate_dense_sparsity_partition () n_icol = 0 n_irow = 0 n_linear_icol = 0 n_linear_irow = 0 n_linear_vals = 0 allocate ( jac ( me % num_sparsity_points )) ! the idea here is to compute the (dense) jacobian ! one column at at time, and keep a running track of ! the ones that have changed. ! first precompute the perturbation arrays for each point: allocate ( xp ( me % n , me % num_sparsity_points )) do i = 1 , me % num_sparsity_points xp (:, i ) = me % xlow_for_sparsity + ( me % xhigh_for_sparsity - me % xlow_for_sparsity ) * coeffs ( i ) end do ! we will use 2-point methods (simple differences): class_meths = get_all_methods_in_class ( 2 ) do icol = 1 , me % n ! column loop ! size the array: if ( allocated ( jac_array )) deallocate ( jac_array ) allocate ( jac_array ( me % num_sparsity_points )) ! compute the ith column of the jacobian: me % sparsity % icol = [( icol , j = 1 , me % m )] do i = 1 , me % num_sparsity_points call me % compute_jacobian_for_sparsity ( icol , class_meths , xp (:, i ), jac_array ( i )% jac ) if ( me % exception_raised ) return ! check for exceptions end do ! check each row: do irow = 1 , me % m ! get the jacobian values for this row,col for all the points: do j = 1 , me % num_sparsity_points jac ( j ) = jac_array ( j )% jac ( irow ) end do ! put the results into the tmp_sparsity_pattern if ( equal_within_tol ([ 0.0_wp , jac ], me % linear_sparsity_tol )) then ! they are all zero cycle else if ( me % compute_linear_sparsity_pattern ) then if ( equal_within_tol ( jac , me % linear_sparsity_tol )) then ! this is a linear element (constant value) dfdx = sum ( jac ) / me % num_sparsity_points ! just take the average and use that call expand_vector ( tmp_sparsity_pattern % linear_icol , n_linear_icol , me % chunk_size , val = icol ) call expand_vector ( tmp_sparsity_pattern % linear_irow , n_linear_irow , me % chunk_size , val = irow ) call expand_vector ( tmp_sparsity_pattern % linear_vals , n_linear_vals , me % chunk_size , val = dfdx ) cycle ! this element will not be added to the nonlinear pattern end if end if ! otherwise, add it to the nonlinear pattern: call expand_vector ( tmp_sparsity_pattern % icol , n_icol , me % chunk_size , val = icol ) call expand_vector ( tmp_sparsity_pattern % irow , n_irow , me % chunk_size , val = irow ) end if end do end do ! copy over the computed pattern: me % sparsity = tmp_sparsity_pattern ! resize to correct size: call me % resize_sparsity_vectors ( n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 21 , 'compute_sparsity_random_2' ,& 'error partitioning sparsity pattern.' ) return end if end if me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_random_2","tags":"","url":"proc/compute_sparsity_random_2.html"},{"title":"compute_sparsity_pattern – NumDiff","text":"private  subroutine compute_sparsity_pattern(me, x, irow, icol, linear_irow, linear_icol, linear_vals) Computes the sparsity pattern and return it.\nUses the settings currently in the class. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) Calls proc~~compute_sparsity_pattern~~CallsGraph proc~compute_sparsity_pattern numdiff_type%compute_sparsity_pattern proc~get_sparsity_pattern numdiff_type%get_sparsity_pattern proc~compute_sparsity_pattern->proc~get_sparsity_pattern Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_sparsity_pattern ( me , x , irow , icol , linear_irow , linear_icol , linear_vals ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) integer , dimension (:), allocatable , intent ( out ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), allocatable , intent ( out ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_irow !! linear sparsity pattern !! nonzero elements row indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_icol !! linear sparsity pattern nonzero !! elements column indices real ( wp ), dimension (:), allocatable , intent ( out ), optional :: linear_vals !! linear sparsity values (constant !! elements of the Jacobian) if ( me % exception_raised ) return ! check for exceptions if ( associated ( me % compute_sparsity )) then call me % compute_sparsity ( x ) if ( me % exception_raised ) return ! check for exceptions call me % get_sparsity_pattern ( irow , icol , linear_irow , linear_icol , linear_vals ) end if end subroutine compute_sparsity_pattern","tags":"","url":"proc/compute_sparsity_pattern.html"},{"title":"get_sparsity_pattern – NumDiff","text":"private  subroutine get_sparsity_pattern(me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) Returns the sparsity pattern from the class.\nIf it hasn't been computed, the output arrays will not be allocated. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) integer, intent(out), optional :: maxgrp DSM sparsity partition integer, intent(out), optional, dimension(:), allocatable :: ngrp DSM sparsity partition Called by proc~~get_sparsity_pattern~~CalledByGraph proc~get_sparsity_pattern numdiff_type%get_sparsity_pattern proc~compute_sparsity_pattern numdiff_type%compute_sparsity_pattern proc~compute_sparsity_pattern->proc~get_sparsity_pattern Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_sparsity_pattern ( me , irow , icol ,& linear_irow , linear_icol , linear_vals ,& maxgrp , ngrp ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , dimension (:), allocatable , intent ( out ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), allocatable , intent ( out ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_irow !! linear sparsity pattern !! nonzero elements row indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_icol !! linear sparsity pattern nonzero !! elements column indices real ( wp ), dimension (:), allocatable , intent ( out ), optional :: linear_vals !! linear sparsity values (constant !! elements of the Jacobian) integer , intent ( out ), optional :: maxgrp !! DSM sparsity partition integer , dimension (:), allocatable , intent ( out ), optional :: ngrp !! DSM sparsity partition if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % sparsity % irow ) . and . allocated ( me % sparsity % icol )) then irow = me % sparsity % irow icol = me % sparsity % icol end if ! optional linear pattern output: if ( present ( linear_irow )) then if ( allocated ( me % sparsity % linear_irow )) linear_irow = me % sparsity % linear_irow end if if ( present ( linear_icol )) then if ( allocated ( me % sparsity % linear_icol )) linear_icol = me % sparsity % linear_icol end if if ( present ( linear_vals )) then if ( allocated ( me % sparsity % linear_vals )) linear_vals = me % sparsity % linear_vals end if ! optional DSM partition: if ( present ( ngrp ) . and . allocated ( me % sparsity % ngrp )) ngrp = me % sparsity % ngrp if ( present ( maxgrp )) maxgrp = me % sparsity % maxgrp end subroutine get_sparsity_pattern","tags":"","url":"proc/get_sparsity_pattern.html"},{"title":"compute_jacobian_dense – NumDiff","text":"private  subroutine compute_jacobian_dense(me, x, jac) just a wrapper for compute_jacobian , that returns a dense ( m x n ) matrix. Note This one will include the constant elements if the linear pattern is available. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:,:), allocatable :: jac the jacobian matrix Calls proc~~compute_jacobian_dense~~CallsGraph proc~compute_jacobian_dense numdiff_type%compute_jacobian_dense proc~compute_jacobian numdiff_type%compute_jacobian proc~compute_jacobian_dense->proc~compute_jacobian proc~compute_perturbation_vector numdiff_type%compute_perturbation_vector proc~compute_jacobian->proc~compute_perturbation_vector proc~raise_exception numdiff_type%raise_exception proc~compute_jacobian->proc~raise_exception proc~compute_perturb_vector numdiff_type%compute_perturb_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~compute_perturb_vector->proc~raise_exception Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_dense ( me , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:,:), allocatable , intent ( out ) :: jac !! the jacobian matrix real ( wp ), dimension (:), allocatable :: jac_vec !! sparse jacobian representation integer :: i !! counter if ( me % exception_raised ) return ! check for exceptions ! size output matrix: allocate ( jac ( me % m , me % n )) ! convert to dense form: jac = zero ! compute sparse form of jacobian: call me % compute_jacobian ( x , jac_vec ) if ( me % exception_raised ) return ! check for exceptions if ( allocated ( jac_vec )) then ! add the nonlinear elements: do i = 1 , me % sparsity % num_nonzero_elements jac ( me % sparsity % irow ( i ), me % sparsity % icol ( i )) = jac_vec ( i ) end do deallocate ( jac_vec ) end if ! add the constant elements if necessary: do i = 1 , me % sparsity % num_nonzero_linear_elements jac ( me % sparsity % linear_irow ( i ), me % sparsity % linear_icol ( i )) = me % sparsity % linear_vals ( i ) end do end subroutine compute_jacobian_dense","tags":"","url":"proc/compute_jacobian_dense.html"},{"title":"perturb_x_and_compute_f – NumDiff","text":"private  subroutine perturb_x_and_compute_f(me, x, dx_factor, dx, df_factor, column, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in) :: column the variable to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero Called by proc~~perturb_x_and_compute_f~~CalledByGraph proc~perturb_x_and_compute_f numdiff_type%perturb_x_and_compute_f proc~compute_jacobian_for_sparsity numdiff_type%compute_jacobian_for_sparsity proc~compute_jacobian_for_sparsity->proc~perturb_x_and_compute_f proc~compute_jacobian_standard compute_jacobian_standard proc~compute_jacobian_standard->proc~perturb_x_and_compute_f proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine perturb_x_and_compute_f ( me , x , dx_factor , dx ,& df_factor , column , idx , df ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! nominal variable vector real ( wp ), intent ( in ) :: dx_factor !! factor to multiply `dx` real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation value for this column real ( wp ), intent ( in ) :: df_factor !! factor to multiply function value integer , intent ( in ) :: column !! the variable to perturb integer , dimension (:), intent ( in ) :: idx !! the elements in this !! column of the Jacobian !! to compute (passed to function) real ( wp ), dimension ( me % m ), intent ( inout ) :: df !! the accumulated function value !! note: for the first call, this !! should be set to zero real ( wp ), dimension ( me % n ) :: xp !! the perturbed variable vector real ( wp ), dimension ( me % m ) :: f !! function evaluation if ( me % exception_raised ) return ! check for exceptions xp = x if ( dx_factor /= zero ) xp ( column ) = xp ( column ) + dx_factor * dx ( column ) call me % compute_function ( xp , f , idx ) if ( me % exception_raised ) return ! check for exceptions df ( idx ) = df ( idx ) + df_factor * f ( idx ) end subroutine perturb_x_and_compute_f","tags":"","url":"proc/perturb_x_and_compute_f.html"},{"title":"compute_jacobian_times_vector – NumDiff","text":"private  subroutine compute_jacobian_times_vector(me, x, v, z) Returns the product J*v , where J is the m x n Jacobian matrix\n  and v is an n x 1 vector. Note This one will include the constant elements if the linear pattern is available. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(:) :: v vector (size n ) real(kind=wp), intent(out), dimension(:) :: z The product J*v (size m ) Calls proc~~compute_jacobian_times_vector~~CallsGraph proc~compute_jacobian_times_vector numdiff_type%compute_jacobian_times_vector proc~compute_jacobian numdiff_type%compute_jacobian proc~compute_jacobian_times_vector->proc~compute_jacobian proc~compute_perturbation_vector numdiff_type%compute_perturbation_vector proc~compute_jacobian->proc~compute_perturbation_vector proc~raise_exception numdiff_type%raise_exception proc~compute_jacobian->proc~raise_exception proc~compute_perturb_vector numdiff_type%compute_perturb_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~compute_perturb_vector->proc~raise_exception Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_times_vector ( me , x , v , z ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), intent ( in ) :: v !! vector (size `n`) real ( wp ), dimension (:), intent ( out ) :: z !! The product `J*v` (size `m`) real ( wp ), dimension (:), allocatable :: jac !! sparse jacobian vector integer :: i !! counter integer :: r !! row number in full jacobian integer :: c !! column number in full jacobian if ( me % exception_raised ) return ! check for exceptions ! first compute the jacobian in sparse vector form: call me % compute_jacobian ( x , jac ) if ( me % exception_raised ) return ! check for exceptions ! initialize output vector: z = 0.0_wp if ( allocated ( jac )) then !   J    v   z !  ---   -   - !  X0X   X   X !  0X0 * X = X !  00X   X   X !  00X       X ! multiplication by input v: do i = 1 , me % sparsity % num_nonzero_elements r = me % sparsity % irow ( i ) c = me % sparsity % icol ( i ) z ( r ) = z ( r ) + jac ( i ) * v ( c ) end do deallocate ( jac ) end if ! linear elements if available: do i = 1 , me % sparsity % num_nonzero_linear_elements r = me % sparsity % linear_irow ( i ) c = me % sparsity % linear_icol ( i ) z ( r ) = z ( r ) + me % sparsity % linear_vals ( i ) * v ( c ) end do end subroutine compute_jacobian_times_vector","tags":"","url":"proc/compute_jacobian_times_vector.html"},{"title":"compute_jacobian – NumDiff","text":"private  subroutine compute_jacobian(me, x, jac) Compute the Jacobian. Note The output jac only includes the elements of the nonlinear Jacobian.\n      If the constant elements are being handled separately (if the linear\n      pattern is available), then those elements can be obtained by\n      calling get_sparsity_pattern if required. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector Calls proc~~compute_jacobian~~CallsGraph proc~compute_jacobian numdiff_type%compute_jacobian proc~compute_perturbation_vector numdiff_type%compute_perturbation_vector proc~compute_jacobian->proc~compute_perturbation_vector proc~raise_exception numdiff_type%raise_exception proc~compute_jacobian->proc~raise_exception proc~compute_perturb_vector numdiff_type%compute_perturb_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~compute_perturb_vector->proc~raise_exception Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_jacobian~~CalledByGraph proc~compute_jacobian numdiff_type%compute_jacobian proc~compute_jacobian_dense numdiff_type%compute_jacobian_dense proc~compute_jacobian_dense->proc~compute_jacobian proc~compute_jacobian_times_vector numdiff_type%compute_jacobian_times_vector proc~compute_jacobian_times_vector->proc~compute_jacobian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian ( me , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), allocatable , intent ( out ) :: jac !! sparse jacobian vector real ( wp ), dimension ( me % n ) :: dx !! absolute perturbation (>0) for each variable if ( me % exception_raised ) return ! check for exceptions ! if we don't have a sparsity pattern yet then compute it: ! [also computes the indices vector] if (. not . me % sparsity % sparsity_computed ) call me % compute_sparsity ( x ) if ( me % sparsity % num_nonzero_elements == 0 ) return ! size the jacobian vector: allocate ( jac ( me % sparsity % num_nonzero_elements )) ! compute dx vector: if (. not . me % use_diff ) then ! only need this for the finite difference methods (not diff) call me % compute_perturbation_vector ( x , dx ) if ( me % exception_raised ) return ! check for exceptions end if ! compute the jacobian: if ( associated ( me % jacobian_function )) then call me % jacobian_function ( x , dx , jac ) else call me % raise_exception ( 22 , 'compute_jacobian' ,& 'jacobian_function has not been associated.' ) return end if end subroutine compute_jacobian","tags":"","url":"proc/compute_jacobian.html"},{"title":"compute_jacobian_for_sparsity – NumDiff","text":"private  subroutine compute_jacobian_for_sparsity(me, i, class_meths, x, jac) A separate version of compute_jacobian to be used only when\n  computing the sparsity pattern in compute_sparsity_random_2 .\n  It uses class_meths and the sparsity dperts and bounds. Note Based on compute_jacobian . The index manipulation here could be\n      greatly simplified, since we realdy know we are computed all the\n      elements in one column. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: i the column being computed type( meth_array ), intent(in) :: class_meths set of finite diff methods to use real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector Calls proc~~compute_jacobian_for_sparsity~~CallsGraph proc~compute_jacobian_for_sparsity numdiff_type%compute_jacobian_for_sparsity proc~compute_sparsity_perturbation_vector numdiff_type%compute_sparsity_perturbation_vector proc~compute_jacobian_for_sparsity->proc~compute_sparsity_perturbation_vector proc~perturb_x_and_compute_f numdiff_type%perturb_x_and_compute_f proc~compute_jacobian_for_sparsity->proc~perturb_x_and_compute_f proc~select_finite_diff_method numdiff_type%select_finite_diff_method proc~compute_jacobian_for_sparsity->proc~select_finite_diff_method proc~compute_perturb_vector numdiff_type%compute_perturb_vector proc~compute_sparsity_perturbation_vector->proc~compute_perturb_vector proc~raise_exception numdiff_type%raise_exception proc~compute_perturb_vector->proc~raise_exception Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_jacobian_for_sparsity~~CalledByGraph proc~compute_jacobian_for_sparsity numdiff_type%compute_jacobian_for_sparsity proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_for_sparsity ( me , i , class_meths , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: i !! the column being computed type ( meth_array ), intent ( in ) :: class_meths !! set of finite diff methods to use real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), allocatable , intent ( out ) :: jac !! sparse jacobian vector real ( wp ), dimension ( me % n ) :: dx !! absolute perturbation (>0) for each variable integer , dimension (:), allocatable :: nonzero_elements_in_col !! the indices of the !! nonzero Jacobian !! elements in a column integer :: j !! function evaluation counter real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column if ( me % exception_raised ) return ! check for exceptions ! Note that a sparsity pattern has already been set ! size the jacobian vector: allocate ( jac ( me % sparsity % num_nonzero_elements )) ! compute the perturbation vector (really we only need dx(i)): call me % compute_sparsity_perturbation_vector ( x , dx ) if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! determine functions to compute for this column: num_nonzero_elements_in_col = count ( me % sparsity % icol == i ) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to compute nonzero_elements_in_col = pack ( me % sparsity % irow , mask = me % sparsity % icol == i ) call me % select_finite_diff_method ( x ( i ), me % xlow_for_sparsity ( i ), me % xhigh_for_sparsity ( i ),& dx ( i ), class_meths , fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then write ( error_unit , '(A,1X,I5)' ) & 'Error in compute_jacobian_for_sparsity: variable bounds violated for column: ' , i end if end if ! compute this column of the Jacobian: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( fd % df_den_factor * dx ( i )) ! put result into the output vector: jac ( pack ( me % sparsity % indices , mask = me % sparsity % icol == i )) = & df ( nonzero_elements_in_col ) end if end subroutine compute_jacobian_for_sparsity","tags":"","url":"proc/compute_jacobian_for_sparsity.html"},{"title":"compute_jacobian_standard – NumDiff","text":"private  subroutine compute_jacobian_standard(me, x, dx, jac) Compute the Jacobian using finite differences.\n(one column at a time) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) Calls proc~~compute_jacobian_standard~~CallsGraph proc~compute_jacobian_standard compute_jacobian_standard proc~perturb_x_and_compute_f numdiff_type%perturb_x_and_compute_f proc~compute_jacobian_standard->proc~perturb_x_and_compute_f proc~raise_exception numdiff_type%raise_exception proc~compute_jacobian_standard->proc~raise_exception proc~select_finite_diff_method numdiff_type%select_finite_diff_method proc~compute_jacobian_standard->proc~select_finite_diff_method Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_standard ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector (size !! `num_nonzero_elements`) integer , dimension (:), allocatable :: nonzero_elements_in_col !! the indices of the !! nonzero Jacobian !! elements in a column integer :: i !! column counter integer :: j !! function evaluation counter real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! compute Jacobian matrix column-by-column: do i = 1 , me % n ! determine functions to compute for this column: num_nonzero_elements_in_col = count ( me % sparsity % icol == i ) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to compute nonzero_elements_in_col = pack ( me % sparsity % irow , mask = me % sparsity % icol == i ) select case ( me % mode ) case ( 1 ) ! use the specified methods ! compute this column of the Jacobian: df = zero do j = 1 , size ( me % meth ( i )% dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , me % meth ( i )% dx_factors ( j ),& dx , me % meth ( i )% df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( me % meth ( i )% df_den_factor * dx ( i )) case ( 2 ) ! select the method from the class so as not to violate the bounds call me % select_finite_diff_method ( x ( i ), me % xlow ( i ), me % xhigh ( i ),& dx ( i ), me % class_meths ( i ), fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then write ( error_unit , '(A,1X,I5)' ) & 'Error in compute_jacobian_standard: variable bounds violated for column: ' , i end if end if ! compute this column of the Jacobian: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( fd % df_den_factor * dx ( i )) case default call me % raise_exception ( 23 , 'compute_jacobian_standard' ,& 'invalid mode' ) return end select ! put result into the output vector: jac ( pack ( me % sparsity % indices , mask = me % sparsity % icol == i )) = & df ( nonzero_elements_in_col ) end if end do end subroutine compute_jacobian_standard","tags":"","url":"proc/compute_jacobian_standard.html"},{"title":"compute_jacobian_with_diff – NumDiff","text":"private  subroutine compute_jacobian_with_diff(me, x, dx, jac) Compute the Jacobian one element at a time using the Neville's process\nalgorithm diff . This takes a very large number of function evaluations,\nbut should give a very accurate answer. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) Calls proc~~compute_jacobian_with_diff~~CallsGraph proc~compute_jacobian_with_diff compute_jacobian_with_diff proc~diff diff_func%diff proc~compute_jacobian_with_diff->proc~diff proc~raise_exception numdiff_type%raise_exception proc~compute_jacobian_with_diff->proc~raise_exception proc~set_function diff_func%set_function proc~compute_jacobian_with_diff->proc~set_function proc~faccur diff_func%faccur proc~diff->proc~faccur Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_with_diff ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector (size !! `num_nonzero_elements`) integer , parameter :: iord = 1 !! tells [[diff]] to compute first derivative integer :: i !! counter for nonzero elements of jacobian type ( diff_func ) :: d !! the [[diff]] class to use real ( wp ) :: x0 !! value of ith variable for [[diff]] real ( wp ) :: xmin !! ith variable lower bound real ( wp ) :: xmax !! ith variable upper bound real ( wp ) :: deriv !! derivative value df/dx from [[diff]] real ( wp ) :: error !! estimated error from [[diff]] integer :: ifail !! [[diff]] error flag real ( wp ), dimension ( me % n ) :: xp !! used by [[dfunc]]. real ( wp ), dimension ( me % m ) :: fvec !! used by [[dfunc]]. integer :: ir !! row index of next non-zero element integer :: ic !! column index of next non-zero element integer :: ic_prev !! previous column perturbed integer :: icount !! count of number of times a column has been perturbed logical :: use_info !! if we are reporting to the user if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero use_info = associated ( me % info_function ) if ( use_info ) ic_prev = - 1 ! set the function for diff: call d % set_function ( dfunc ) ! each element is computed one by one do i = 1 , me % sparsity % num_nonzero_elements ir = me % sparsity % irow ( i ) ic = me % sparsity % icol ( i ) x0 = x ( ic ) xmin = me % xlow ( ic ) xmax = me % xhigh ( ic ) ! if reporting to the user, have to keep track ! of which column is being perturbed, and how ! many times: if ( use_info ) then if ( ic /= ic_prev ) icount = 0 end if call d % compute_derivative ( iord , x0 , xmin , xmax , me % eps , me % acc , deriv , error , ifail ) if ( ifail == 0 . or . ifail == 1 ) then jac ( i ) = deriv else if ( ifail == - 1 ) then ! this indicates an exception was ! already raised, so just return. return else call me % raise_exception ( 24 , 'compute_jacobian_with_diff' ,& 'error computing derivative with DIFF.' ) return end if if ( use_info ) ic_prev = ic end do contains function dfunc ( this , xval ) result ( fx ) !! interface to user function for [[diff]] routine. implicit none class ( diff_func ), intent ( inout ) :: this real ( wp ), intent ( in ) :: xval !! input variable (`ic` variable) real ( wp ) :: fx !! derivative of `ir` function !! w.r.t. `xval` variable if ( use_info ) then icount = icount + 1 call me % info_function ([ ic ], icount , x ) end if xp = x xp ( ic ) = xval call me % compute_function ( xp , fvec , funcs_to_compute = [ ir ]) if ( me % exception_raised ) then ! check for exceptions fx = 0.0_wp call me % terminate () else fx = fvec ( ir ) end if end function dfunc end subroutine compute_jacobian_with_diff","tags":"","url":"proc/compute_jacobian_with_diff.html"},{"title":"compute_jacobian_partitioned – NumDiff","text":"private  subroutine compute_jacobian_partitioned(me, x, dx, jac) Compute the Jacobian using finite differences,\n(using the partitioned sparsity pattern to compute multiple columns\nat a time). Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0) for each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector Calls proc~~compute_jacobian_partitioned~~CallsGraph proc~compute_jacobian_partitioned compute_jacobian_partitioned proc~columns_in_partition_group sparsity_pattern%columns_in_partition_group proc~compute_jacobian_partitioned->proc~columns_in_partition_group proc~perturb_x_and_compute_f_partitioned numdiff_type%perturb_x_and_compute_f_partitioned proc~compute_jacobian_partitioned->proc~perturb_x_and_compute_f_partitioned proc~raise_exception numdiff_type%raise_exception proc~compute_jacobian_partitioned->proc~raise_exception proc~select_finite_diff_method_for_partition_group numdiff_type%select_finite_diff_method_for_partition_group proc~compute_jacobian_partitioned->proc~select_finite_diff_method_for_partition_group Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_partitioned ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector integer :: i !! column counter integer :: j !! function evaluation counter integer :: igroup !! group number counter integer :: n_cols !! number of columns in a group integer , dimension (:), allocatable :: cols !! array of column indices in a group integer , dimension (:), allocatable :: nonzero_rows !! the indices of the nonzero Jacobian !! elementes (row numbers) in a group integer , dimension (:), allocatable :: indices !! nonzero indices in `jac` for a group integer , dimension (:), allocatable :: col_indices !! nonzero indices in `jac` for a column real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! compute by group: do igroup = 1 , me % sparsity % maxgrp ! get the columns in this group: call me % sparsity % columns_in_partition_group ( igroup , n_cols , cols ,& nonzero_rows , indices , status_ok ) if (. not . status_ok ) then call me % raise_exception ( 25 , 'compute_jacobian_partitioned' ,& 'the partition has not been computed.' ) return end if if ( n_cols > 0 ) then if ( allocated ( nonzero_rows )) then select case ( me % mode ) case ( 1 ) ! use the specified methods ! note: all the methods must be the same within a group ! compute the columns of the Jacobian in this group: df = zero do j = 1 , size ( me % meth ( 1 )% dx_factors ) if ( associated ( me % info_function )) call me % info_function ( cols , j , x ) call me % perturb_x_and_compute_f_partitioned ( x , me % meth ( 1 )% dx_factors ( j ),& dx , me % meth ( 1 )% df_factors ( j ),& cols , nonzero_rows , df ) if ( me % exception_raised ) return ! check for exceptions end do ! divide by the denominator, which can be different for each column: do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % sparsity % icol == cols ( i )) if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) ! col_indices = pack(me%sparsity%indices,mask=me%sparsity%icol==cols(i)) block integer :: j , n n = 0 do j = 1 , size ( me % sparsity % icol ) if ( me % sparsity % icol ( j ) == cols ( i )) then n = n + 1 col_indices ( n ) = j end if end do end block df ( me % sparsity % irow ( col_indices )) = df ( me % sparsity % irow ( col_indices )) / & ( me % meth ( 1 )% df_den_factor * dx ( cols ( i ))) end do case ( 2 ) ! select the method from the class so as not to violate ! the bounds on *any* of the variables in the group ! note: all the classes must be the same within a group call me % select_finite_diff_method_for_partition_group ( & x ( cols ), me % xlow ( cols ), me % xhigh ( cols ),& dx ( cols ), me % class_meths ( 1 ), fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then ! will not consider this a fatal error for now: write ( error_unit , '(A,1X,I5,1X,A,1X,*(I5,1X))' ) & 'Error in compute_jacobian_partitioned: ' // & 'variable bounds violated for group: ' ,& igroup , '. columns: ' , cols end if end if ! compute the columns of the Jacobian in this group: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ( cols , j , x ) call me % perturb_x_and_compute_f_partitioned ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& cols , nonzero_rows , df ) if ( me % exception_raised ) return ! check for exceptions end do ! divide by the denominator, which can be different for each column: do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % sparsity % icol == cols ( i )) if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) col_indices = pack ( me % sparsity % indices , mask = me % sparsity % icol == cols ( i )) df ( me % sparsity % irow ( col_indices )) = df ( me % sparsity % irow ( col_indices )) / & ( fd % df_den_factor * dx ( cols ( i ))) end do case default call me % raise_exception ( 26 , 'compute_jacobian_partitioned' , 'invalid mode' ) return end select ! put result into the output vector: jac ( indices ) = df ( nonzero_rows ) end if end if end do end subroutine compute_jacobian_partitioned","tags":"","url":"proc/compute_jacobian_partitioned.html"},{"title":"perturb_x_and_compute_f_partitioned – NumDiff","text":"private  subroutine perturb_x_and_compute_f_partitioned(me, x, dx_factor, dx, df_factor, columns, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in), dimension(:) :: columns the variables to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero Called by proc~~perturb_x_and_compute_f_partitioned~~CalledByGraph proc~perturb_x_and_compute_f_partitioned numdiff_type%perturb_x_and_compute_f_partitioned proc~compute_jacobian_partitioned compute_jacobian_partitioned proc~compute_jacobian_partitioned->proc~perturb_x_and_compute_f_partitioned Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine perturb_x_and_compute_f_partitioned ( me , x , dx_factor , dx ,& df_factor , columns , idx , df ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! nominal variable vector real ( wp ), intent ( in ) :: dx_factor !! factor to multiply `dx` real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation value for this column real ( wp ), intent ( in ) :: df_factor !! factor to multiply function value integer , dimension (:), intent ( in ) :: columns !! the variables to perturb integer , dimension (:), intent ( in ) :: idx !! the elements in this !! column of the Jacobian !! to compute (passed to function) real ( wp ), dimension ( me % m ), intent ( inout ) :: df !! the accumulated function value !! note: for the first call, this !! should be set to zero real ( wp ), dimension ( me % n ) :: xp !! the perturbed variable vector real ( wp ), dimension ( me % m ) :: f !! function evaluation if ( me % exception_raised ) return ! check for exceptions xp = x if ( dx_factor /= zero ) xp ( columns ) = xp ( columns ) + dx_factor * dx ( columns ) call me % compute_function ( xp , f , idx ) if ( me % exception_raised ) return ! check for exceptions df ( idx ) = df ( idx ) + df_factor * f ( idx ) end subroutine perturb_x_and_compute_f_partitioned","tags":"","url":"proc/perturb_x_and_compute_f_partitioned.html"},{"title":"compute_perturb_vector – NumDiff","text":"private  subroutine compute_perturb_vector(me, x, dpert, perturb_mode, dx) Compute dx , the perturbation vector for x Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dpert integer, intent(in) :: perturb_mode real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable Calls proc~~compute_perturb_vector~~CallsGraph proc~compute_perturb_vector numdiff_type%compute_perturb_vector proc~raise_exception numdiff_type%raise_exception proc~compute_perturb_vector->proc~raise_exception Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_perturb_vector~~CalledByGraph proc~compute_perturb_vector numdiff_type%compute_perturb_vector proc~compute_perturbation_vector numdiff_type%compute_perturbation_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~compute_sparsity_perturbation_vector numdiff_type%compute_sparsity_perturbation_vector proc~compute_sparsity_perturbation_vector->proc~compute_perturb_vector proc~compute_jacobian numdiff_type%compute_jacobian proc~compute_jacobian->proc~compute_perturbation_vector proc~compute_jacobian_for_sparsity numdiff_type%compute_jacobian_for_sparsity proc~compute_jacobian_for_sparsity->proc~compute_sparsity_perturbation_vector proc~compute_jacobian_dense numdiff_type%compute_jacobian_dense proc~compute_jacobian_dense->proc~compute_jacobian proc~compute_jacobian_times_vector numdiff_type%compute_jacobian_times_vector proc~compute_jacobian_times_vector->proc~compute_jacobian proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_perturb_vector ( me , x , dpert , perturb_mode , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dpert integer , intent ( in ) :: perturb_mode real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) !! the smallest allowed absolute step if ( me % exception_raised ) return ! check for exceptions select case ( perturb_mode ) case ( 1 ) dx = abs ( dpert ) case ( 2 ) dx = abs ( dpert * x ) case ( 3 ) dx = abs ( dpert ) * ( 1.0_wp + abs ( x )) case default call me % raise_exception ( 27 , 'compute_perturb_vector' ,& 'invalid value for perturb_mode (must be 1, 2, or 3)' ) return end select ! make sure none are too small: where ( dx < eps ) dx = dpert end where end subroutine compute_perturb_vector","tags":"","url":"proc/compute_perturb_vector.html"},{"title":"compute_perturbation_vector – NumDiff","text":"private  subroutine compute_perturbation_vector(me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the gradients. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable Calls proc~~compute_perturbation_vector~~CallsGraph proc~compute_perturbation_vector numdiff_type%compute_perturbation_vector proc~compute_perturb_vector numdiff_type%compute_perturb_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~raise_exception numdiff_type%raise_exception proc~compute_perturb_vector->proc~raise_exception Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_perturbation_vector~~CalledByGraph proc~compute_perturbation_vector numdiff_type%compute_perturbation_vector proc~compute_jacobian numdiff_type%compute_jacobian proc~compute_jacobian->proc~compute_perturbation_vector proc~compute_jacobian_dense numdiff_type%compute_jacobian_dense proc~compute_jacobian_dense->proc~compute_jacobian proc~compute_jacobian_times_vector numdiff_type%compute_jacobian_times_vector proc~compute_jacobian_times_vector->proc~compute_jacobian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_perturbation_vector ( me , x , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable if ( me % exception_raised ) return ! check for exceptions call me % compute_perturb_vector ( x , me % dpert , me % perturb_mode , dx ) end subroutine compute_perturbation_vector","tags":"","url":"proc/compute_perturbation_vector.html"},{"title":"compute_sparsity_perturbation_vector – NumDiff","text":"private  subroutine compute_sparsity_perturbation_vector(me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the sparsity pattern. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable Calls proc~~compute_sparsity_perturbation_vector~~CallsGraph proc~compute_sparsity_perturbation_vector numdiff_type%compute_sparsity_perturbation_vector proc~compute_perturb_vector numdiff_type%compute_perturb_vector proc~compute_sparsity_perturbation_vector->proc~compute_perturb_vector proc~raise_exception numdiff_type%raise_exception proc~compute_perturb_vector->proc~raise_exception Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_sparsity_perturbation_vector~~CalledByGraph proc~compute_sparsity_perturbation_vector numdiff_type%compute_sparsity_perturbation_vector proc~compute_jacobian_for_sparsity numdiff_type%compute_jacobian_for_sparsity proc~compute_jacobian_for_sparsity->proc~compute_sparsity_perturbation_vector proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_sparsity_perturbation_vector ( me , x , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable if ( me % exception_raised ) return ! check for exceptions call me % compute_perturb_vector ( x , me % dpert_for_sparsity , me % sparsity_perturb_mode , dx ) end subroutine compute_sparsity_perturbation_vector","tags":"","url":"proc/compute_sparsity_perturbation_vector.html"},{"title":"print_sparsity – NumDiff","text":"private  subroutine print_sparsity(me, n, m, iunit, dense) Print the sparsity pattern. Type Bound sparsity_pattern Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: n number of variables (columns of jacobian) integer, intent(in) :: m number of functions (rows of jacobian) integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) logical, intent(in), optional :: dense if present and true, the matrix form\nof the sparsity pattern is printed\n(default is vector form) Source Code subroutine print_sparsity ( me , n , m , iunit , dense ) implicit none class ( sparsity_pattern ), intent ( in ) :: me integer , intent ( in ) :: n !! number of variables (columns of jacobian) integer , intent ( in ) :: m !! number of functions (rows of jacobian) integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) logical , intent ( in ), optional :: dense !! if present and true, the matrix form !! of the sparsity pattern is printed !! (default is vector form) logical :: print_matrix !! if the matrix form is to be printed integer :: r !! row counter character ( len = 1 ), dimension ( n ) :: row !! a row of the sparsity matrix if ( present ( dense )) then print_matrix = dense else print_matrix = . false . ! default end if write ( iunit , '(A)' ) '---Sparsity pattern---' if ( allocated ( me % irow ) . and . allocated ( me % icol )) then if ( print_matrix ) then do r = 1 , m ! print by row row = '0' row ( pack ( me % icol , mask = me % irow == r )) = 'X' write ( iunit , '(*(A1))' ) row end do else write ( iunit , '(A,1X,*(I3,\",\"))' ) 'irow:' , me % irow write ( iunit , '(A,1X,*(I3,\",\"))' ) 'icol:' , me % icol end if if ( allocated ( me % ngrp )) then write ( iunit , '(A)' ) '' write ( iunit , '(A)' ) '---Sparsity partition---' write ( iunit , '(A,1x,I5)' ) 'Number of groups:' , me % maxgrp write ( iunit , '(A,1x,*(I5,1X))' ) 'Group array:     ' , me % ngrp end if end if write ( iunit , '(A)' ) '' ! print linear pattern if available if ( me % linear_sparsity_computed ) then write ( iunit , '(A)' ) '---Linear sparsity pattern---' if ( allocated ( me % linear_icol ) . and . allocated ( me % linear_irow )) then if ( print_matrix ) then do r = 1 , m ! print by row row = '0' row ( pack ( me % linear_icol , mask = me % linear_irow == r )) = 'X' write ( iunit , '(*(A1))' ) row end do else write ( iunit , '(A,1X,*(I3,\",\"))' ) 'irow:' , me % linear_irow write ( iunit , '(A,1X,*(I3,\",\"))' ) 'icol:' , me % linear_icol write ( iunit , '(A,1X,*(E30.16,\",\"))' ) 'vals:' , me % linear_vals end if end if write ( iunit , '(A)' ) '' end if end subroutine print_sparsity","tags":"","url":"proc/print_sparsity.html"},{"title":"print_sparsity_pattern – NumDiff","text":"private  subroutine print_sparsity_pattern(me, iunit) Print the sparsity pattern in vector form ( irow , icol ). Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) Source Code subroutine print_sparsity_pattern ( me , iunit ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) call me % sparsity % print ( me % n , me % m , iunit , dense = . false .) end subroutine print_sparsity_pattern","tags":"","url":"proc/print_sparsity_pattern.html"},{"title":"print_sparsity_matrix – NumDiff","text":"private  subroutine print_sparsity_matrix(me, iunit) Print the sparsity pattern in matrix form. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) Source Code subroutine print_sparsity_matrix ( me , iunit ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) call me % sparsity % print ( me % n , me % m , iunit , dense = . true .) end subroutine print_sparsity_matrix","tags":"","url":"proc/print_sparsity_matrix.html"},{"title":"terminate – NumDiff","text":"private  subroutine terminate(me) A user-callable routine. When called, it will terminate\nall computations and return. The istat return code will be\nset to -1 . This can be called in the function or the info function. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me Source Code subroutine terminate ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me if ( me % exception_raised ) return ! check for existing exceptions me % istat = - 1 me % error_msg = 'Terminated by the user' me % exception_raised = . true . end subroutine terminate","tags":"","url":"proc/terminate~2.html"},{"title":"raise_exception – NumDiff","text":"private  subroutine raise_exception(me, istat, routine, error_msg) Raise an exception. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: istat error code. character(len=*), intent(in) :: routine the routine where the error was raised. character(len=*), intent(in) :: error_msg error message string. Called by proc~~raise_exception~~CalledByGraph proc~raise_exception numdiff_type%raise_exception proc~compute_jacobian numdiff_type%compute_jacobian proc~compute_jacobian->proc~raise_exception proc~compute_perturbation_vector numdiff_type%compute_perturbation_vector proc~compute_jacobian->proc~compute_perturbation_vector proc~compute_jacobian_partitioned compute_jacobian_partitioned proc~compute_jacobian_partitioned->proc~raise_exception proc~compute_jacobian_standard compute_jacobian_standard proc~compute_jacobian_standard->proc~raise_exception proc~compute_jacobian_with_diff compute_jacobian_with_diff proc~compute_jacobian_with_diff->proc~raise_exception proc~compute_perturb_vector numdiff_type%compute_perturb_vector proc~compute_perturb_vector->proc~raise_exception proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->proc~raise_exception proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~raise_exception proc~compute_jacobian_for_sparsity numdiff_type%compute_jacobian_for_sparsity proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity proc~initialize_numdiff numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~raise_exception proc~set_numdiff_bounds numdiff_type%set_numdiff_bounds proc~initialize_numdiff->proc~set_numdiff_bounds proc~set_sparsity_mode numdiff_type%set_sparsity_mode proc~initialize_numdiff->proc~set_sparsity_mode proc~initialize_numdiff_for_diff numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~raise_exception proc~initialize_numdiff_for_diff->proc~set_numdiff_bounds proc~initialize_numdiff_for_diff->proc~set_sparsity_mode proc~set_dpert numdiff_type%set_dpert proc~set_dpert->proc~raise_exception proc~set_numdiff_bounds->proc~raise_exception proc~set_numdiff_sparsity_bounds numdiff_type%set_numdiff_sparsity_bounds proc~set_numdiff_sparsity_bounds->proc~raise_exception proc~set_sparsity_mode->proc~raise_exception proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~set_sparsity_pattern numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~raise_exception proc~compute_jacobian_dense numdiff_type%compute_jacobian_dense proc~compute_jacobian_dense->proc~compute_jacobian proc~compute_jacobian_times_vector numdiff_type%compute_jacobian_times_vector proc~compute_jacobian_times_vector->proc~compute_jacobian proc~compute_perturbation_vector->proc~compute_perturb_vector proc~compute_sparsity_perturbation_vector numdiff_type%compute_sparsity_perturbation_vector proc~compute_sparsity_perturbation_vector->proc~compute_perturb_vector proc~compute_jacobian_for_sparsity->proc~compute_sparsity_perturbation_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine raise_exception ( me , istat , routine , error_msg ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: istat !! error code. character ( len =* ), intent ( in ) :: routine !! the routine where the error was raised. character ( len =* ), intent ( in ) :: error_msg !! error message string. me % istat = istat me % error_msg = 'Error in ' // trim ( routine ) // ' : ' // trim ( error_msg ) me % exception_raised = . true . end subroutine raise_exception","tags":"","url":"proc/raise_exception.html"},{"title":"clear_exceptions – NumDiff","text":"private  subroutine clear_exceptions(me) Clear all exceptions. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me Source Code subroutine clear_exceptions ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me me % istat = 0 if ( allocated ( me % error_msg )) deallocate ( me % error_msg ) me % exception_raised = . false . end subroutine clear_exceptions","tags":"","url":"proc/clear_exceptions.html"},{"title":"get_error_status – NumDiff","text":"private  subroutine get_error_status(me, istat, error_msg) Returns the current error code and message. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me integer, intent(out), optional :: istat error code ( istat=0 means no errors). character(len=:), intent(out), optional, allocatable :: error_msg error message string. Source Code subroutine get_error_status ( me , istat , error_msg ) implicit none class ( numdiff_type ), intent ( in ) :: me integer , intent ( out ), optional :: istat !! error code (`istat=0` means no errors). character ( len = :), allocatable , intent ( out ), optional :: error_msg !! error message string. if ( present ( istat )) istat = me % istat if ( present ( error_msg )) then if ( allocated ( me % error_msg )) then error_msg = me % error_msg else error_msg = '' end if end if end subroutine get_error_status","tags":"","url":"proc/get_error_status.html"},{"title":"finite_diff_method – NumDiff","text":"public interface finite_diff_method constructor Calls interface~~finite_diff_method~~CallsGraph interface~finite_diff_method finite_diff_method proc~initialize_finite_difference_method initialize_finite_difference_method interface~finite_diff_method->proc~initialize_finite_difference_method Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function initialize_finite_difference_method (id, name, class, dx_factors, df_factors, df_den_factor) result(me) Constructor for a finite_diff_method . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: id unique ID for the method character(len=*), intent(in) :: name the name of the method integer, intent(in) :: class 2=backward diffs, 3=central diffs, etc... integer, intent(in), dimension(:) :: dx_factors multiplicative factors for dx perturbation integer, intent(in), dimension(:) :: df_factors multiplicative factors for accumulating function evaluations integer, intent(in) :: df_den_factor denominator factor for finite difference equation (times dx) Return Value type( finite_diff_method )","tags":"","url":"interface/finite_diff_method.html"},{"title":"unique_int – NumDiff","text":"private  function unique_int(vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value integer, dimension(:), allocatable unique elements of ivec Calls proc~~unique_int~~CallsGraph proc~unique_int unique_int interface~expand_vector expand_vector proc~unique_int->interface~expand_vector interface~sort_ascending sort_ascending proc~unique_int->interface~sort_ascending proc~expand_vector_int expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap swap proc~sort_ascending_int->interface~swap proc~sort_ascending_real->interface~swap proc~swap_int swap_int interface~swap->proc~swap_int proc~swap_real swap_real interface~swap->proc~swap_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~unique_int~~CalledByGraph proc~unique_int unique_int interface~unique unique interface~unique->proc~unique_int proc~divide_interval divide_interval proc~divide_interval->interface~unique proc~put_in_cache function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function unique_int ( vec , chunk_size ) result ( ivec_unique ) implicit none integer , dimension (:), intent ( in ) :: vec !! a vector of integers integer , intent ( in ) :: chunk_size !! chunk size for adding to arrays integer , dimension (:), allocatable :: ivec_unique !! unique elements of `ivec` integer , dimension ( size ( vec )) :: ivec !! temp copy of vec integer :: i !! counter integer :: n !! number of unique elements ! first we sort it: ivec = vec ! make a copy call sort_ascending ( ivec ) ! add the first element: n = 1 ivec_unique = [ ivec ( 1 )] ! walk through array and get the unique ones: if ( size ( ivec ) > 1 ) then do i = 2 , size ( ivec ) if ( ivec ( i ) /= ivec ( i - 1 )) then call expand_vector ( ivec_unique , n , chunk_size , val = ivec ( i )) end if end do call expand_vector ( ivec_unique , n , chunk_size , finished = . true .) end if end function unique_int","tags":"","url":"proc/unique_int.html"},{"title":"unique_real – NumDiff","text":"private  function unique_real(vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value real(kind=wp), dimension(:), allocatable unique elements of ivec Calls proc~~unique_real~~CallsGraph proc~unique_real unique_real interface~expand_vector expand_vector proc~unique_real->interface~expand_vector interface~sort_ascending sort_ascending proc~unique_real->interface~sort_ascending proc~expand_vector_int expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap swap proc~sort_ascending_int->interface~swap proc~sort_ascending_real->interface~swap proc~swap_int swap_int interface~swap->proc~swap_int proc~swap_real swap_real interface~swap->proc~swap_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~unique_real~~CalledByGraph proc~unique_real unique_real interface~unique unique interface~unique->proc~unique_real proc~divide_interval divide_interval proc~divide_interval->interface~unique proc~put_in_cache function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function unique_real ( vec , chunk_size ) result ( ivec_unique ) implicit none real ( wp ), dimension (:), intent ( in ) :: vec !! a vector of integers integer , intent ( in ) :: chunk_size !! chunk size for adding to arrays real ( wp ), dimension (:), allocatable :: ivec_unique !! unique elements of `ivec` real ( wp ), dimension ( size ( vec )) :: ivec !! temp copy of vec integer :: i !! counter integer :: n !! number of unique elements ! first we sort it: ivec = vec ! make a copy call sort_ascending ( ivec ) ! add the first element: n = 1 ivec_unique = [ ivec ( 1 )] ! walk through array and get the unique ones: if ( size ( ivec ) > 1 ) then do i = 2 , size ( ivec ) if ( ivec ( i ) /= ivec ( i - 1 )) then call expand_vector ( ivec_unique , n , chunk_size , val = ivec ( i )) end if end do call expand_vector ( ivec_unique , n , chunk_size , finished = . true .) end if end function unique_real","tags":"","url":"proc/unique_real.html"},{"title":"equal_within_tol – NumDiff","text":"public pure function equal_within_tol(vals, tol) result(equal) Returns true if the values in the array are the same\n(to within the specified absolute tolerance). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vals a set of values real(kind=wp), intent(in) :: tol a positive tolerance value Return Value logical true if they are equal\nwithin the tolerance Called by proc~~equal_within_tol~~CalledByGraph proc~equal_within_tol equal_within_tol proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->proc~equal_within_tol proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~equal_within_tol Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function equal_within_tol ( vals , tol ) result ( equal ) implicit none real ( wp ), dimension (:), intent ( in ) :: vals !! a set of values real ( wp ), intent ( in ) :: tol !! a positive tolerance value logical :: equal !! true if they are equal !! within the tolerance equal = all ( abs ( vals - vals ( 1 )) <= abs ( tol ) ) end function equal_within_tol","tags":"","url":"proc/equal_within_tol.html"},{"title":"divide_interval – NumDiff","text":"public  function divide_interval(num_points) result(points) Returns a set of slightly randomized equally-spaced\n  points that divide an interval. Example: for num_points = 3: o---|---|---|---o\n         1   2   3 returns: [0.25308641972530865, 0.5061728394506173, 0.759259259175926] . Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_points the number of points in the interval Return Value real(kind=wp), dimension(:), allocatable the resultant vector Calls proc~~divide_interval~~CallsGraph proc~divide_interval divide_interval interface~unique unique proc~divide_interval->interface~unique proc~unique_int unique_int interface~unique->proc~unique_int proc~unique_real unique_real interface~unique->proc~unique_real interface~expand_vector expand_vector proc~unique_int->interface~expand_vector interface~sort_ascending sort_ascending proc~unique_int->interface~sort_ascending proc~unique_real->interface~expand_vector proc~unique_real->interface~sort_ascending proc~expand_vector_int expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap swap proc~sort_ascending_int->interface~swap proc~sort_ascending_real->interface~swap proc~swap_int swap_int interface~swap->proc~swap_int proc~swap_real swap_real interface~swap->proc~swap_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~divide_interval~~CalledByGraph proc~divide_interval divide_interval proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function divide_interval ( num_points ) result ( points ) implicit none integer , intent ( in ) :: num_points !! the number of points in the interval real ( wp ), dimension (:), allocatable :: points !! the resultant vector real ( wp ), parameter :: noise = 1.012345678901234567_wp !! a noise value. Not a round number !! so as to avoid freak zeros in the !! jacobian real ( wp ), parameter :: min_val = 1 0.0_wp * epsilon ( 1.0_wp ) !! the minimize distance from the lower bound real ( wp ), parameter :: max_val = 1.0_wp - min_val !! the minimize distance from the upper bound integer :: i !! counter real ( wp ) :: delta !! step size real ( wp ), dimension (:), allocatable :: tmp !! a temp array to hold the values delta = 1.0_wp / ( num_points + 1 ) allocate ( tmp ( num_points )) do i = 1 , num_points tmp ( i ) = min ( max ( min_val , delta * i * noise ), max_val ) end do ! this is to protect for the min/max case if there ! are enough points so that some are duplicated near ! the bounds: points = unique ( tmp , chunk_size = 10 ) end function divide_interval","tags":"","url":"proc/divide_interval.html"},{"title":"expand_vector_int – NumDiff","text":"private pure subroutine expand_vector_int(vec, n, chunk_size, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Called by proc~~expand_vector_int~~CalledByGraph proc~expand_vector_int expand_vector_int interface~expand_vector expand_vector interface~expand_vector->proc~expand_vector_int proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->interface~expand_vector proc~resize_sparsity_vectors numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random->proc~resize_sparsity_vectors proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->interface~expand_vector proc~compute_sparsity_random_2->proc~resize_sparsity_vectors proc~divide_interval divide_interval proc~compute_sparsity_random_2->proc~divide_interval proc~resize_sparsity_vectors->interface~expand_vector proc~unique_int unique_int proc~unique_int->interface~expand_vector proc~unique_real unique_real proc~unique_real->interface~expand_vector interface~unique unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval->interface~unique proc~put_in_cache function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine expand_vector_int ( vec , n , chunk_size , val , finished ) implicit none integer , dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ) :: chunk_size !! allocate `vec` in blocks of this size (>0) integer , intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) integer , dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector_int","tags":"","url":"proc/expand_vector_int.html"},{"title":"expand_vector_real – NumDiff","text":"private pure subroutine expand_vector_real(vec, n, chunk_size, val, finished) Add elements to the real vector in chunks. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) real(kind=wp), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Called by proc~~expand_vector_real~~CalledByGraph proc~expand_vector_real expand_vector_real interface~expand_vector expand_vector interface~expand_vector->proc~expand_vector_real proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->interface~expand_vector proc~resize_sparsity_vectors numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random->proc~resize_sparsity_vectors proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->interface~expand_vector proc~compute_sparsity_random_2->proc~resize_sparsity_vectors proc~divide_interval divide_interval proc~compute_sparsity_random_2->proc~divide_interval proc~resize_sparsity_vectors->interface~expand_vector proc~unique_int unique_int proc~unique_int->interface~expand_vector proc~unique_real unique_real proc~unique_real->interface~expand_vector interface~unique unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval->interface~unique proc~put_in_cache function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine expand_vector_real ( vec , n , chunk_size , val , finished ) implicit none real ( wp ), dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ) :: chunk_size !! allocate `vec` in blocks of this size (>0) real ( wp ), intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) real ( wp ), dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector_real","tags":"","url":"proc/expand_vector_real.html"},{"title":"sort_ascending_int – NumDiff","text":"private  subroutine sort_ascending_int(ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec Calls proc~~sort_ascending_int~~CallsGraph proc~sort_ascending_int sort_ascending_int interface~swap swap proc~sort_ascending_int->interface~swap proc~swap_int swap_int interface~swap->proc~swap_int proc~swap_real swap_real interface~swap->proc~swap_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sort_ascending_int~~CalledByGraph proc~sort_ascending_int sort_ascending_int interface~sort_ascending sort_ascending interface~sort_ascending->proc~sort_ascending_int proc~unique_int unique_int proc~unique_int->interface~sort_ascending proc~unique_real unique_real proc~unique_real->interface~sort_ascending interface~unique unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval divide_interval proc~divide_interval->interface~unique proc~put_in_cache function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_ascending_int ( ivec ) implicit none integer , dimension (:), intent ( inout ) :: ivec call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_int","tags":"","url":"proc/sort_ascending_int.html"},{"title":"sort_ascending_real – NumDiff","text":"private  subroutine sort_ascending_real(ivec) Sorts a real array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: ivec Calls proc~~sort_ascending_real~~CallsGraph proc~sort_ascending_real sort_ascending_real interface~swap swap proc~sort_ascending_real->interface~swap proc~swap_int swap_int interface~swap->proc~swap_int proc~swap_real swap_real interface~swap->proc~swap_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sort_ascending_real~~CalledByGraph proc~sort_ascending_real sort_ascending_real interface~sort_ascending sort_ascending interface~sort_ascending->proc~sort_ascending_real proc~unique_int unique_int proc~unique_int->interface~sort_ascending proc~unique_real unique_real proc~unique_real->interface~sort_ascending interface~unique unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval divide_interval proc~divide_interval->interface~unique proc~put_in_cache function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_ascending_real ( ivec ) implicit none real ( wp ), dimension (:), intent ( inout ) :: ivec call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_real","tags":"","url":"proc/sort_ascending_real.html"},{"title":"swap_int – NumDiff","text":"private pure elemental subroutine swap_int(i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 Called by proc~~swap_int~~CalledByGraph proc~swap_int swap_int interface~swap swap interface~swap->proc~swap_int proc~sort_ascending_int sort_ascending_int proc~sort_ascending_int->interface~swap proc~sort_ascending_real sort_ascending_real proc~sort_ascending_real->interface~swap interface~sort_ascending sort_ascending interface~sort_ascending->proc~sort_ascending_int interface~sort_ascending->proc~sort_ascending_real proc~unique_int unique_int proc~unique_int->interface~sort_ascending proc~unique_real unique_real proc~unique_real->interface~sort_ascending interface~unique unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval divide_interval proc~divide_interval->interface~unique proc~put_in_cache function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap_int ( i1 , i2 ) implicit none integer , intent ( inout ) :: i1 integer , intent ( inout ) :: i2 integer :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_int","tags":"","url":"proc/swap_int.html"},{"title":"swap_real – NumDiff","text":"private pure elemental subroutine swap_real(i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: i1 real(kind=wp), intent(inout) :: i2 Called by proc~~swap_real~~CalledByGraph proc~swap_real swap_real interface~swap swap interface~swap->proc~swap_real proc~sort_ascending_int sort_ascending_int proc~sort_ascending_int->interface~swap proc~sort_ascending_real sort_ascending_real proc~sort_ascending_real->interface~swap interface~sort_ascending sort_ascending interface~sort_ascending->proc~sort_ascending_int interface~sort_ascending->proc~sort_ascending_real proc~unique_int unique_int proc~unique_int->interface~sort_ascending proc~unique_real unique_real proc~unique_real->interface~sort_ascending interface~unique unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval divide_interval proc~divide_interval->interface~unique proc~put_in_cache function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap_real ( i1 , i2 ) implicit none real ( wp ), intent ( inout ) :: i1 real ( wp ), intent ( inout ) :: i2 real ( wp ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_real","tags":"","url":"proc/swap_real.html"},{"title":"expand_vector – NumDiff","text":"public interface expand_vector Calls interface~~expand_vector~~CallsGraph interface~expand_vector expand_vector proc~expand_vector_int expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real expand_vector_real interface~expand_vector->proc~expand_vector_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~expand_vector~~CalledByGraph interface~expand_vector expand_vector proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->interface~expand_vector proc~resize_sparsity_vectors numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random->proc~resize_sparsity_vectors proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->interface~expand_vector proc~compute_sparsity_random_2->proc~resize_sparsity_vectors proc~divide_interval divide_interval proc~compute_sparsity_random_2->proc~divide_interval proc~resize_sparsity_vectors->interface~expand_vector proc~unique_int unique_int proc~unique_int->interface~expand_vector proc~unique_real unique_real proc~unique_real->interface~expand_vector interface~unique unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval->interface~unique proc~put_in_cache function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine expand_vector_int (vec, n, chunk_size, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) private pure subroutine expand_vector_real (vec, n, chunk_size, val, finished) Add elements to the real vector in chunks. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) real(kind=wp), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n )","tags":"","url":"interface/expand_vector.html"},{"title":"unique – NumDiff","text":"public interface unique Calls interface~~unique~~CallsGraph interface~unique unique proc~unique_int unique_int interface~unique->proc~unique_int proc~unique_real unique_real interface~unique->proc~unique_real interface~expand_vector expand_vector proc~unique_int->interface~expand_vector interface~sort_ascending sort_ascending proc~unique_int->interface~sort_ascending proc~unique_real->interface~expand_vector proc~unique_real->interface~sort_ascending proc~expand_vector_int expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap swap proc~sort_ascending_int->interface~swap proc~sort_ascending_real->interface~swap proc~swap_int swap_int interface~swap->proc~swap_int proc~swap_real swap_real interface~swap->proc~swap_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~unique~~CalledByGraph interface~unique unique proc~divide_interval divide_interval proc~divide_interval->interface~unique proc~put_in_cache function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function unique_int (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value integer, dimension(:), allocatable unique elements of ivec private  function unique_real (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value real(kind=wp), dimension(:), allocatable unique elements of ivec","tags":"","url":"interface/unique.html"},{"title":"sort_ascending – NumDiff","text":"public interface sort_ascending Calls interface~~sort_ascending~~CallsGraph interface~sort_ascending sort_ascending proc~sort_ascending_int sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap swap proc~sort_ascending_int->interface~swap proc~sort_ascending_real->interface~swap proc~swap_int swap_int interface~swap->proc~swap_int proc~swap_real swap_real interface~swap->proc~swap_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~sort_ascending~~CalledByGraph interface~sort_ascending sort_ascending proc~unique_int unique_int proc~unique_int->interface~sort_ascending proc~unique_real unique_real proc~unique_real->interface~sort_ascending interface~unique unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval divide_interval proc~divide_interval->interface~unique proc~put_in_cache function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine sort_ascending_int (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_real (ivec) Sorts a real array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: ivec","tags":"","url":"interface/sort_ascending.html"},{"title":"swap – NumDiff","text":"private interface swap Calls interface~~swap~~CallsGraph interface~swap swap proc~swap_int swap_int interface~swap->proc~swap_int proc~swap_real swap_real interface~swap->proc~swap_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~swap~~CalledByGraph interface~swap swap proc~sort_ascending_int sort_ascending_int proc~sort_ascending_int->interface~swap proc~sort_ascending_real sort_ascending_real proc~sort_ascending_real->interface~swap interface~sort_ascending sort_ascending interface~sort_ascending->proc~sort_ascending_int interface~sort_ascending->proc~sort_ascending_real proc~unique_int unique_int proc~unique_int->interface~sort_ascending proc~unique_real unique_real proc~unique_real->interface~sort_ascending interface~unique unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval divide_interval proc~divide_interval->interface~unique proc~put_in_cache function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure elemental subroutine swap_int (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap_real (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: i1 real(kind=wp), intent(inout) :: i2","tags":"","url":"interface/swap.html"},{"title":"dsm – NumDiff","text":"public  subroutine dsm(m, n, npairs, indrow, indcol, ngrp, maxgrp, mingrp, info, ipntr, jpntr) The purpose of dsm is to determine an optimal or near-\noptimal consistent partition of the columns of a sparse m by n matrix a . the sparsity pattern of the matrix a is specified by\nthe arrays indrow and indcol . on input the indices\nfor the non-zero elements of a are indrow(k),indcol(k), k = 1,2,...,npairs . the ( indrow , indcol ) pairs may be specified in any order.\nduplicate input pairs are permitted, but the subroutine\neliminates them. the subroutine partitions the columns of a into groups\nsuch that columns in the same group do not have a\nnon-zero in the same row position. a partition of the\ncolumns of a with this property is consistent with the\ndirect determination of a . Arguments Type Intent Optional Attributes Name integer, intent(in) :: m number of rows of a (>0) integer, intent(in) :: n number of columns of a (>0) integer, intent(in) :: npairs number of ( indrow , indcol ) pairs used\nto describe the sparsity pattern of a (>0) integer, intent(inout), dimension(npairs) :: indrow an integer array of length npairs . on input indrow must contain the row indices of the non-zero elements of a .\non output indrow is permuted so that the corresponding\ncolumn indices are in non-decreasing order. the column\nindices can be recovered from the array jpntr . integer, intent(inout), dimension(npairs) :: indcol an integer array of length npairs . on input indcol must contain the column indices of the non-zero elements of a . on output indcol is permuted so that the corresponding\nrow indices are in non-decreasing order. the row indices\ncan be recovered from the array ipntr . integer, intent(out), dimension(n) :: ngrp specifies the partition of the columns of a .\ncolumn jcol belongs to group ngrp(jcol) . integer, intent(out) :: maxgrp the number of groups in the partition\nof the columns of a . integer, intent(out) :: mingrp a lower bound for the number of groups\nin any consistent partition of the\ncolumns of a . integer, intent(out) :: info for normal termination info = 1 .\nif m , n , or npairs is not positive,\nthen info = 0 . if the k-th element of indrow is not an integer between\n1 and m or the k-th element of indcol is not an integer between 1 and n,\nthen info = -k . integer, intent(out), dimension(m+1) :: ipntr an integer output array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 .\nnote that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(out), dimension(n+1) :: jpntr jpntr is an integer output array of length n + 1 which\nspecifies the locations of the row indices in indrow.\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 .\nnote that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . Calls proc~~dsm~~CallsGraph proc~dsm dsm proc~degr degr proc~dsm->proc~degr proc~ido ido proc~dsm->proc~ido proc~numsrt numsrt proc~dsm->proc~numsrt proc~seq seq proc~dsm->proc~seq proc~setr setr proc~dsm->proc~setr proc~slo slo proc~dsm->proc~slo proc~srtdat srtdat proc~dsm->proc~srtdat proc~ido->proc~numsrt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dsm~~CalledByGraph proc~dsm dsm proc~dsm_wrapper sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dsm ( m , n , Npairs , Indrow , Indcol , Ngrp , Maxgrp , Mingrp , Info , Ipntr , Jpntr ) implicit none integer , intent ( in ) :: m !! number of rows of `a` (>0) integer , intent ( in ) :: n !! number of columns of `a` (>0) integer , intent ( in ) :: npairs !! number of (`indrow`,`indcol`) pairs used !! to describe the sparsity pattern of `a` (>0) integer , intent ( out ) :: maxgrp !! the number of groups in the partition !! of the columns of `a`. integer , intent ( out ) :: mingrp !! a lower bound for the number of groups !! in any consistent partition of the !! columns of `a`. integer , intent ( out ) :: info !! for normal termination `info = 1`. !! if `m`, `n`, or `npairs` is not positive, !! then `info = 0`. if the k-th element of !! `indrow` is not an integer between !! 1 and m or the k-th element of `indcol` !! is not an integer between 1 and n, !! then `info = -k`. integer , dimension ( npairs ), intent ( inout ) :: indrow !! an integer array of length `npairs`. on input `indrow` !! must contain the row indices of the non-zero elements of `a`. !! on output `indrow` is permuted so that the corresponding !! column indices are in non-decreasing order. the column !! indices can be recovered from the array `jpntr`. integer , dimension ( npairs ), intent ( inout ) :: indcol !! an integer array of length `npairs`. on input `indcol` !! must contain the column indices of the non-zero elements of !! `a`. on output `indcol` is permuted so that the corresponding !! row indices are in non-decreasing order. the row indices !! can be recovered from the array `ipntr`. integer , dimension ( n ), intent ( out ) :: ngrp !! specifies the partition of the columns of `a`. !! column `jcol` belongs to group `ngrp(jcol)`. integer , dimension ( m + 1 ), intent ( out ) :: ipntr !! an integer output array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! note that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n + 1 ), intent ( out ) :: jpntr !! jpntr is an integer output array of length n + 1 which !! specifies the locations of the row indices in indrow. !! the row indices for column j are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! note that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( max ( m , 6 * n )) :: iwa !! an integer work array integer :: i , ir , j , jp , k , maxclq , nnz , numgrp !  check the input data. Info = 0 if ( m < 1 . or . n < 1 . or . Npairs < 1 ) return do k = 1 , Npairs Info = - k if ( Indrow ( k ) < 1 . or . Indrow ( k ) > m . or . Indcol ( k ) < 1 . or . Indcol ( k ) > n ) return enddo Info = 1 !  sort the data structure by columns. call srtdat ( n , Npairs , Indrow , Indcol , Jpntr , Iwa ) !  compress the data and determine the number of !  non-zero elements of a. do i = 1 , m Iwa ( i ) = 0 enddo nnz = 1 do j = 1 , n k = nnz do jp = Jpntr ( j ) , Jpntr ( j + 1 ) - 1 ir = Indrow ( jp ) if ( Iwa ( ir ) /= j ) then Indrow ( nnz ) = ir nnz = nnz + 1 Iwa ( ir ) = j endif enddo Jpntr ( j ) = k enddo Jpntr ( n + 1 ) = nnz !  extend the data structure to rows. call setr ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ) !  determine a lower bound for the number of groups. Mingrp = 0 do i = 1 , m Mingrp = max ( Mingrp , Ipntr ( i + 1 ) - Ipntr ( i )) enddo !  determine the degree sequence for the intersection !  graph of the columns of a. call degr ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( n + 1 )) !  color the intersection graph of the columns of a !  with the smallest-last (sl) ordering. call slo ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( 4 * n + 1 ), maxclq ,& Iwa ( 1 ), Iwa ( n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( 3 * n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Ngrp , Maxgrp , & Iwa ( n + 1 )) Mingrp = max ( Mingrp , maxclq ) !  exit if the smallest-last ordering is optimal. if ( Maxgrp == Mingrp ) return !  color the intersection graph of the columns of a !  with the incidence-degree (id) ordering. call ido ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( 4 * n + 1 ), & maxclq , Iwa ( 1 ), Iwa ( n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( 3 * n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Iwa ( 1 ), numgrp , & Iwa ( n + 1 )) Mingrp = max ( Mingrp , maxclq ) !  retain the better of the two orderings so far. if ( numgrp < Maxgrp ) then Maxgrp = numgrp do j = 1 , n Ngrp ( j ) = Iwa ( j ) enddo !  exit if the incidence-degree ordering is optimal. if ( Maxgrp == Mingrp ) return endif !  color the intersection graph of the columns of a !  with the largest-first (lf) ordering. call numsrt ( n , n - 1 , Iwa ( 5 * n + 1 ), - 1 , Iwa ( 4 * n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Iwa ( 1 ), numgrp , & Iwa ( n + 1 )) !  retain the best of the three orderings and exit. if ( numgrp < Maxgrp ) then Maxgrp = numgrp do j = 1 , n Ngrp ( j ) = Iwa ( j ) enddo endif end subroutine dsm","tags":"","url":"proc/dsm.html"},{"title":"degr – NumDiff","text":"private  subroutine degr(n, indrow, jpntr, indcol, ipntr, ndeg, iwa) Given the sparsity pattern of an m by n matrix a ,\n  this subroutine determines the degree sequence for\n  the intersection graph of the columns of a . In graph-theory terminology, the intersection graph of\n  the columns of a is the loopless graph g with vertices a(j), j = 1,2,...,n where a(j) is the j -th column of a and with edge (a(i),a(j)) if and only if columns i and j have a non-zero in the same row position. Note The value of m is not needed by degr and is\n      therefore not present in the subroutine statement. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, intent(in), dimension(*) :: indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, intent(in), dimension(n+1) :: jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(*) :: indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, intent(in), dimension(*) :: ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(out), dimension(n) :: ndeg an integer output array of length n which\nspecifies the degree sequence. the degree of the j -th column of a is ndeg(j) . integer, dimension(n) :: iwa an integer work array of length n Called by proc~~degr~~CalledByGraph proc~degr degr proc~dsm dsm proc~dsm->proc~degr proc~dsm_wrapper sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine degr ( n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , Iwa ) implicit none integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , dimension ( * ), intent ( in ) :: indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ), intent ( in ) :: jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ), intent ( in ) :: indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ), intent ( in ) :: ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ), intent ( out ) :: ndeg !! an integer output array of length `n` which !! specifies the degree sequence. the degree of the !! `j`-th column of `a` is `ndeg(j)`. integer , dimension ( n ) :: iwa !! an integer work array of length `n` integer :: ic , ip , ir , jcol , jp ! initialization block. do jp = 1 , n Ndeg ( jp ) = 0 Iwa ( jp ) = 0 enddo ! compute the degree sequence by determining the contributions ! to the degrees from the current(jcol) column and further ! columns which have not yet been considered. do jcol = 2 , n Iwa ( jcol ) = n ! determine all positions (ir,jcol) which correspond ! to non-zeroes in the matrix. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! for each row ir, determine all positions (ir,ic) ! which correspond to non-zeroes in the matrix. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! array iwa marks columns which have contributed to ! the degree count of column jcol. update the degree ! counts of these columns as well as column jcol. if ( Iwa ( ic ) < jcol ) then Iwa ( ic ) = jcol Ndeg ( ic ) = Ndeg ( ic ) + 1 Ndeg ( jcol ) = Ndeg ( jcol ) + 1 endif enddo enddo enddo end subroutine degr","tags":"","url":"proc/degr.html"},{"title":"ido – NumDiff","text":"private  subroutine ido(m, n, Indrow, Jpntr, Indcol, Ipntr, Ndeg, List, Maxclq, Iwa1, Iwa2, Iwa3, Iwa4) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines an incidence-degree ordering of the\ncolumns of a . the incidence-degree ordering is defined for the loopless\ngraph g with vertices a(j), j = 1,2,...,n where a(j) is the j -th column of a and with edge (a(i),a(j)) if and only if\ncolumns i and j have a non-zero in the same row position. the incidence-degree ordering is determined recursively by\nletting list(k), k = 1,...,n be a column with maximal\nincidence to the subgraph spanned by the ordered columns.\namong all the columns of maximal incidence, ido chooses a\ncolumn of maximal degree. Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a . integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, intent(in), dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, intent(in), dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, intent(in), dimension(m+1) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(n) :: Ndeg an integer input array of length n which specifies\nthe degree sequence. the degree of the j -th column\nof a is ndeg(j) . integer, intent(out), dimension(n) :: List an integer output array of length n which specifies\nthe incidence-degree ordering of the columns of a . the j -th\ncolumn in this order is list(j) . integer, intent(out) :: Maxclq an integer output variable set to the size\nof the largest clique found during the ordering. integer, dimension(0:n-1) :: Iwa1 integer work array of length n . integer, dimension(n) :: Iwa2 integer work array of length n . integer, dimension(n) :: Iwa3 integer work array of length n . integer, dimension(n) :: Iwa4 integer work array of length n . Calls proc~~ido~~CallsGraph proc~ido ido proc~numsrt numsrt proc~ido->proc~numsrt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ido~~CalledByGraph proc~ido ido proc~dsm dsm proc~dsm->proc~ido proc~dsm_wrapper sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine ido ( m , n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , List , Maxclq , & Iwa1 , Iwa2 , Iwa3 , Iwa4 ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of `a`. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , intent ( out ) :: Maxclq !! an integer output variable set to the size !! of the largest clique found during the ordering. integer , dimension ( * ), intent ( in ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ), intent ( in ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ), intent ( in ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( m + 1 ), intent ( in ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ), intent ( in ) :: Ndeg !! an integer input array of length `n` which specifies !! the degree sequence. the degree of the `j`-th column !! of `a` is `ndeg(j)`. integer , dimension ( n ), intent ( out ) :: List !! an integer output array of length `n` which specifies !! the incidence-degree ordering of the columns of `a`. the `j`-th !! column in this order is `list(j)`. integer , dimension ( 0 : n - 1 ) :: Iwa1 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa2 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa3 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa4 !! integer work array of length `n`. integer :: ic , ip , ir , jcol , jp , maxinc , maxlst , ncomp , & numinc , numlst , numord , numwgt ! sort the degree sequence. call numsrt ( n , n - 1 , Ndeg , - 1 , Iwa4 , Iwa2 , Iwa3 ) ! initialization block. ! ! create a doubly-linked list to access the incidences of the ! columns. the pointers for the linked list are as follows. ! ! each un-ordered column ic is in a list (the incidence list) ! of columns with the same incidence. ! ! iwa1(numinc) is the first column in the numinc list ! unless iwa1(numinc) = 0. in this case there are ! no columns in the numinc list. ! ! iwa2(ic) is the column before ic in the incidence list ! unless iwa2(ic) = 0. in this case ic is the first ! column in this incidence list. ! ! iwa3(ic) is the column after ic in the incidence list ! unless iwa3(ic) = 0. in this case ic is the last ! column in this incidence list. ! ! if ic is an un-ordered column, then list(ic) is the ! incidence of ic to the graph induced by the ordered ! columns. if jcol is an ordered column, then list(jcol) ! is the incidence-degree order of column jcol. maxinc = 0 do jp = n , 1 , - 1 ic = Iwa4 ( jp ) Iwa1 ( n - jp ) = 0 Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( 0 ) if ( Iwa1 ( 0 ) > 0 ) Iwa2 ( Iwa1 ( 0 )) = ic Iwa1 ( 0 ) = ic Iwa4 ( jp ) = 0 List ( jp ) = 0 enddo ! DETERMINE THE MAXIMAL SEARCH LENGTH FOR THE LIST ! OF COLUMNS OF MAXIMAL INCIDENCE. maxlst = 0 do ir = 1 , m maxlst = maxlst + ( Ipntr ( ir + 1 ) - Ipntr ( ir )) ** 2 enddo maxlst = maxlst / n Maxclq = 0 numord = 1 ! BEGINNING OF ITERATION LOOP. ! UPDATE THE SIZE OF THE LARGEST CLIQUE ! FOUND DURING THE ORDERING. 100 if ( maxinc == 0 ) ncomp = 0 ncomp = ncomp + 1 if ( maxinc + 1 == ncomp ) Maxclq = max ( Maxclq , ncomp ) ! CHOOSE A COLUMN JCOL OF MAXIMAL DEGREE AMONG THE ! COLUMNS OF MAXIMAL INCIDENCE MAXINC. 200 jp = Iwa1 ( maxinc ) if ( jp > 0 ) then numwgt = - 1 do numlst = 1 , maxlst if ( Ndeg ( jp ) > numwgt ) then numwgt = Ndeg ( jp ) jcol = jp endif jp = Iwa3 ( jp ) if ( jp <= 0 ) exit enddo List ( jcol ) = numord numord = numord + 1 ! TERMINATION TEST. if ( numord > n ) then ! INVERT THE ARRAY LIST. do jcol = 1 , n Iwa2 ( List ( jcol )) = jcol enddo do jp = 1 , n List ( jp ) = Iwa2 ( jp ) enddo else ! DELETE COLUMN JCOL FROM THE MAXINC LIST. if ( Iwa2 ( jcol ) == 0 ) then Iwa1 ( maxinc ) = Iwa3 ( jcol ) else Iwa3 ( Iwa2 ( jcol )) = Iwa3 ( jcol ) endif if ( Iwa3 ( jcol ) > 0 ) Iwa2 ( Iwa3 ( jcol )) = Iwa2 ( jcol ) ! FIND ALL COLUMNS ADJACENT TO COLUMN JCOL. Iwa4 ( jcol ) = n ! DETERMINE ALL POSITIONS (IR,JCOL) WHICH CORRESPOND ! TO NON-ZEROES IN THE MATRIX. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! FOR EACH ROW IR, DETERMINE ALL POSITIONS (IR,IC) ! WHICH CORRESPOND TO NON-ZEROES IN THE MATRIX. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! ARRAY IWA4 MARKS COLUMNS WHICH ARE ADJACENT TO ! COLUMN JCOL. if ( Iwa4 ( ic ) < numord ) then Iwa4 ( ic ) = numord ! UPDATE THE POINTERS TO THE CURRENT INCIDENCE LISTS. numinc = List ( ic ) List ( ic ) = List ( ic ) + 1 maxinc = max ( maxinc , List ( ic )) ! DELETE COLUMN IC FROM THE NUMINC LIST. if ( Iwa2 ( ic ) == 0 ) then Iwa1 ( numinc ) = Iwa3 ( ic ) else Iwa3 ( Iwa2 ( ic )) = Iwa3 ( ic ) endif if ( Iwa3 ( ic ) > 0 ) Iwa2 ( Iwa3 ( ic )) = Iwa2 ( ic ) ! ADD COLUMN IC TO THE NUMINC+1 LIST. Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( numinc + 1 ) if ( Iwa1 ( numinc + 1 ) > 0 ) Iwa2 ( Iwa1 ( numinc + 1 )) = ic Iwa1 ( numinc + 1 ) = ic endif enddo enddo ! END OF ITERATION LOOP. goto 100 endif else maxinc = maxinc - 1 goto 200 endif end subroutine ido","tags":"","url":"proc/ido.html"},{"title":"numsrt – NumDiff","text":"private  subroutine numsrt(n, Nmax, Num, Mode, Index, Last, Next) Given a sequence of integers, this subroutine groups\n  together those indices with the same sequence value\n  and, optionally, sorts the sequence into either\n  ascending or descending order. The sequence of integers is defined by the array num ,\n  and it is assumed that the integers are each from the set 0,1,...,nmax . on output the indices k such that num(k) = l for any l = 0,1,...,nmax can be obtained from the arrays\n  last and next as follows. k = last ( l ) while ( k /= 0 ) k = next ( k ) Optionally, the subroutine produces an array index so that\n  the sequence num(index(i)), i = 1,2,...,n is sorted. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable. integer :: Nmax a positive integer input variable. integer, dimension(n) :: Num an input array of length n which contains the\nsequence of integers to be grouped and sorted. it\nis assumed that the integers are each from the set 0,1,...,nmax . integer :: Mode an integer input variable. the sequence num is\nsorted in ascending order if mode is positive and in\ndescending order if mode is negative. if mode is 0,\nno sorting is done. integer, dimension(n) :: Index an integer output array of length n set so\nthat the sequence num(index(i)), i = 1,2,...,n is sorted according to the setting of mode.\nif mode is 0, index is not referenced. integer, dimension(0:Nmax) :: Last an integer output array of length nmax + 1 . the\nindex of num for the last occurrence of l is last(l) for any l = 0,1,...,nmax unless last(l) = 0 . in\nthis case l does not appear in num . integer, dimension(n) :: Next an integer output array of length n . if num(k) = l , then the index of num for the previous\noccurrence of l is next(k) for any l = 0,1,...,nmax unless next(k) = 0 . in this case there is no previous\noccurrence of l in num . Called by proc~~numsrt~~CalledByGraph proc~numsrt numsrt proc~dsm dsm proc~dsm->proc~numsrt proc~ido ido proc~dsm->proc~ido proc~ido->proc~numsrt proc~dsm_wrapper sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine numsrt ( n , Nmax , Num , Mode , Index , Last , Next ) implicit none integer , intent ( in ) :: n !! a positive integer input variable. integer :: Nmax !! a positive integer input variable. integer :: Mode !! an integer input variable. the sequence `num` is !! sorted in ascending order if `mode` is positive and in !! descending order if `mode` is negative. if `mode` is 0, !! no sorting is done. integer , dimension ( n ) :: Num !! an input array of length `n` which contains the !! sequence of integers to be grouped and sorted. it !! is assumed that the integers are each from the set !! `0,1,...,nmax`. integer , dimension ( n ) :: Index !! an integer output array of length `n` set so !! that the sequence !! `num(index(i)), i = 1,2,...,n` !! is sorted according to the setting of mode. !! if `mode` is 0, `index` is not referenced. integer , dimension ( 0 : Nmax ) :: Last !! an integer output array of length `nmax + 1`. the !! index of `num` for the last occurrence of `l` is `last(l)` !! for any `l = 0,1,...,nmax` unless `last(l) = 0`. in !! this case `l` does not appear in `num`. integer , dimension ( n ) :: Next !! an integer output array of length `n`. if !! `num(k) = l`, then the index of `num` for the previous !! occurrence of `l` is `next(k)` for any `l = 0,1,...,nmax` !! unless `next(k) = 0`. in this case there is no previous !! occurrence of `l` in `num`. integer :: i , j , jinc , jl , ju , k , l ! determine the arrays next and last. do i = 0 , Nmax Last ( i ) = 0 enddo do k = 1 , n l = Num ( k ) Next ( k ) = Last ( l ) Last ( l ) = k enddo if ( Mode /= 0 ) then ! store the pointers to the sorted array in index. i = 1 if ( Mode > 0 ) then jl = 0 ju = Nmax jinc = 1 else jl = Nmax ju = 0 jinc = - 1 endif do j = jl , ju , jinc k = Last ( j ) do if ( k == 0 ) exit Index ( i ) = k i = i + 1 k = Next ( k ) enddo enddo end if end subroutine numsrt","tags":"","url":"proc/numsrt.html"},{"title":"seq – NumDiff","text":"private  subroutine seq(n, Indrow, Jpntr, Indcol, Ipntr, List, Ngrp, Maxgrp, Iwa) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines a consistent partition of the\ncolumns of a by a sequential algorithm. a consistent partition is defined in terms of the loopless\ngraph g with vertices a(j), j = 1,2,...,n where a(j) is the j -th column of a and with edge (a(i),a(j)) if and only if\ncolumns i and j have a non-zero in the same row position. a partition of the columns of a into groups is consistent\nif the columns in any group are not adjacent in the graph g .\nin graph-theory terminology, a consistent partition of the\ncolumns of a corresponds to a coloring of the graph g . the subroutine examines the columns in the order specified\nby the array list, and assigns the current column to the\ngroup with the smallest possible number. note that the value of m is not needed by seq and is\ntherefore not present in the subroutine statement. Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(*) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(n) :: List an integer input array of length n which specifies\nthe order to be used by the sequential algorithm.\nthe j -th column in this order is list(j) . integer, dimension(n) :: Ngrp an integer output array of length n which specifies\nthe partition of the columns of a . column jcol belongs\nto group ngrp(jcol) . integer :: Maxgrp an integer output variable which specifies the\nnumber of groups in the partition of the columns of a . integer, dimension(n) :: Iwa an integer work array of length n Called by proc~~seq~~CalledByGraph proc~seq seq proc~dsm dsm proc~dsm->proc~seq proc~dsm_wrapper sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine seq ( n , Indrow , Jpntr , Indcol , Ipntr , List , Ngrp , Maxgrp , Iwa ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Maxgrp !! an integer output variable which specifies the !! number of groups in the partition of the columns of `a`. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ) :: List !! an integer input array of length `n` which specifies !! the order to be used by the sequential algorithm. !! the `j`-th column in this order is `list(j)`. integer , dimension ( n ) :: Ngrp !! an integer output array of length `n` which specifies !! the partition of the columns of `a`. column `jcol` belongs !! to group `ngrp(jcol)`. integer , dimension ( n ) :: Iwa !! an integer work array of length `n` integer :: ic , ip , ir , j , jcol , jp ! initialization block. Maxgrp = 0 do jp = 1 , n Ngrp ( jp ) = n Iwa ( jp ) = 0 enddo ! beginning of iteration loop. do j = 1 , n jcol = List ( j ) ! find all columns adjacent to column jcol. ! ! determine all positions (ir,jcol) which correspond ! to non-zeroes in the matrix. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! for each row ir, determine all positions (ir,ic) ! which correspond to non-zeroes in the matrix. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! array iwa marks the group numbers of the ! columns which are adjacent to column jcol. Iwa ( Ngrp ( ic )) = j enddo enddo ! assign the smallest un-marked group number to jcol. do jp = 1 , Maxgrp if ( Iwa ( jp ) /= j ) then Maxgrp = Maxgrp - 1 exit end if enddo Maxgrp = Maxgrp + 1 Ngrp ( jcol ) = jp enddo ! end of iteration loop. end subroutine seq","tags":"","url":"proc/seq.html"},{"title":"setr – NumDiff","text":"private  subroutine setr(m, n, Indrow, Jpntr, Indcol, Ipntr, Iwa) given a column-oriented definition of the sparsity pattern\nof an m by n matrix a , this subroutine determines a\nrow-oriented definition of the sparsity pattern of a . on input the column-oriented definition is specified by\nthe arrays indrow and jpntr . on output the row-oriented\ndefinition is specified by the arrays indcol and ipntr . Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a . integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer output array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(m+1) :: Ipntr an integer output array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(1) is set to 1 and that ipntr(m+1)-1 is\nthen the number of non-zero elements of the matrix a . integer, dimension(m) :: Iwa an integer work array of length m . Called by proc~~setr~~CalledByGraph proc~setr setr proc~dsm dsm proc~dsm->proc~setr proc~dsm_wrapper sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine setr ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of `a`. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer output array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( m + 1 ) :: Ipntr !! an integer output array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(1)` is set to 1 and that `ipntr(m+1)-1` is !! then the number of non-zero elements of the matrix `a`. integer , dimension ( m ) :: Iwa !! an integer work array of length `m`. integer :: ir , jcol , jp ! store in array iwa the counts of non-zeroes in the rows. do ir = 1 , m Iwa ( ir ) = 0 enddo do jp = 1 , Jpntr ( n + 1 ) - 1 Iwa ( Indrow ( jp )) = Iwa ( Indrow ( jp )) + 1 enddo ! set pointers to the start of the rows in indcol. Ipntr ( 1 ) = 1 do ir = 1 , m Ipntr ( ir + 1 ) = Ipntr ( ir ) + Iwa ( ir ) Iwa ( ir ) = Ipntr ( ir ) enddo ! fill indcol. do jcol = 1 , n do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) Indcol ( Iwa ( ir )) = jcol Iwa ( ir ) = Iwa ( ir ) + 1 enddo enddo end subroutine setr","tags":"","url":"proc/setr.html"},{"title":"slo – NumDiff","text":"private  subroutine slo(n, Indrow, Jpntr, Indcol, Ipntr, Ndeg, List, Maxclq, Iwa1, Iwa2, Iwa3, Iwa4) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines the smallest-last ordering of the\ncolumns of a . the smallest-last ordering is defined for the loopless\ngraph g with vertices a(j), j = 1,2,...,n where a(j) is the j -th column of a and with edge (a(i),a(j)) if and only if\ncolumns i and j have a non-zero in the same row position. the smallest-last ordering is determined recursively by\nletting list(k), k = n,...,1 be a column with least degree\nin the subgraph spanned by the un-ordered columns. note that the value of m is not needed by slo and is\ntherefore not present in the subroutine statement. Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(*) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(n) :: Ndeg an integer input array of length n which specifies\nthe degree sequence. the degree of the j -th column\nof a is ndeg(j) . integer, dimension(n) :: List an integer output array of length n which specifies\nthe smallest-last ordering of the columns of a . the j -th\ncolumn in this order is list(j) . integer :: Maxclq an integer output variable set to the size\nof the largest clique found during the ordering. integer, dimension(0:n-1) :: Iwa1 integer work array of length n integer, dimension(n) :: Iwa2 integer work array of length n integer, dimension(n) :: Iwa3 integer work array of length n integer, dimension(n) :: Iwa4 integer work array of length n Called by proc~~slo~~CalledByGraph proc~slo slo proc~dsm dsm proc~dsm->proc~slo proc~dsm_wrapper sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine slo ( n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , List , Maxclq , Iwa1 , & Iwa2 , Iwa3 , Iwa4 ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Maxclq !! an integer output variable set to the size !! of the largest clique found during the ordering. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ) :: Ndeg !! an integer input array of length `n` which specifies !! the degree sequence. the degree of the `j`-th column !! of `a` is `ndeg(j)`. integer , dimension ( n ) :: List !! an integer output array of length `n` which specifies !! the smallest-last ordering of the columns of `a`. the `j`-th !! column in this order is `list(j)`. integer , dimension ( 0 : n - 1 ) :: Iwa1 !! integer work array of length `n` integer , dimension ( n ) :: Iwa2 !! integer work array of length `n` integer , dimension ( n ) :: Iwa3 !! integer work array of length `n` integer , dimension ( n ) :: Iwa4 !! integer work array of length `n` integer :: ic , ip , ir , jcol , jp , mindeg , numdeg , numord ! INITIALIZATION BLOCK. mindeg = n do jp = 1 , n Iwa1 ( jp - 1 ) = 0 Iwa4 ( jp ) = n List ( jp ) = Ndeg ( jp ) mindeg = min ( mindeg , Ndeg ( jp )) enddo ! CREATE A DOUBLY-LINKED LIST TO ACCESS THE DEGREES OF THE ! COLUMNS. THE POINTERS FOR THE LINKED LIST ARE AS FOLLOWS. ! ! EACH UN-ORDERED COLUMN IC IS IN A LIST (THE DEGREE LIST) ! OF COLUMNS WITH THE SAME DEGREE. ! ! IWA1(NUMDEG) IS THE FIRST COLUMN IN THE NUMDEG LIST ! UNLESS IWA1(NUMDEG) = 0. IN THIS CASE THERE ARE ! NO COLUMNS IN THE NUMDEG LIST. ! ! IWA2(IC) IS THE COLUMN BEFORE IC IN THE DEGREE LIST ! UNLESS IWA2(IC) = 0. IN THIS CASE IC IS THE FIRST ! COLUMN IN THIS DEGREE LIST. ! ! IWA3(IC) IS THE COLUMN AFTER IC IN THE DEGREE LIST ! UNLESS IWA3(IC) = 0. IN THIS CASE IC IS THE LAST ! COLUMN IN THIS DEGREE LIST. ! ! IF IC IS AN UN-ORDERED COLUMN, THEN LIST(IC) IS THE ! DEGREE OF IC IN THE GRAPH INDUCED BY THE UN-ORDERED ! COLUMNS. IF JCOL IS AN ORDERED COLUMN, THEN LIST(JCOL) ! IS THE SMALLEST-LAST ORDER OF COLUMN JCOL. do jp = 1 , n numdeg = Ndeg ( jp ) Iwa2 ( jp ) = 0 Iwa3 ( jp ) = Iwa1 ( numdeg ) if ( Iwa1 ( numdeg ) > 0 ) Iwa2 ( Iwa1 ( numdeg )) = jp Iwa1 ( numdeg ) = jp enddo Maxclq = 0 numord = n !  BEGINNING OF ITERATION LOOP. ! ! ! MARK THE SIZE OF THE LARGEST CLIQUE ! FOUND DURING THE ORDERING. 100 if ( mindeg + 1 == numord . and . Maxclq == 0 ) Maxclq = numord ! CHOOSE A COLUMN JCOL OF MINIMAL DEGREE MINDEG. 200 jcol = Iwa1 ( mindeg ) if ( jcol > 0 ) then List ( jcol ) = numord numord = numord - 1 ! TERMINATION TEST. if ( numord == 0 ) then ! INVERT THE ARRAY LIST. do jcol = 1 , n Iwa2 ( List ( jcol )) = jcol enddo do jp = 1 , n List ( jp ) = Iwa2 ( jp ) enddo else ! DELETE COLUMN JCOL FROM THE MINDEG LIST. Iwa1 ( mindeg ) = Iwa3 ( jcol ) if ( Iwa3 ( jcol ) > 0 ) Iwa2 ( Iwa3 ( jcol )) = 0 ! FIND ALL COLUMNS ADJACENT TO COLUMN JCOL. Iwa4 ( jcol ) = 0 ! DETERMINE ALL POSITIONS (IR,JCOL) WHICH CORRESPOND ! TO NON-ZEROES IN THE MATRIX. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! FOR EACH ROW IR, DETERMINE ALL POSITIONS (IR,IC) ! WHICH CORRESPOND TO NON-ZEROES IN THE MATRIX. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! ARRAY IWA4 MARKS COLUMNS WHICH ARE ADJACENT TO ! COLUMN JCOL. if ( Iwa4 ( ic ) > numord ) then Iwa4 ( ic ) = numord ! UPDATE THE POINTERS TO THE CURRENT DEGREE LISTS. numdeg = List ( ic ) List ( ic ) = List ( ic ) - 1 mindeg = min ( mindeg , List ( ic )) ! DELETE COLUMN IC FROM THE NUMDEG LIST. if ( Iwa2 ( ic ) == 0 ) then Iwa1 ( numdeg ) = Iwa3 ( ic ) else Iwa3 ( Iwa2 ( ic )) = Iwa3 ( ic ) endif if ( Iwa3 ( ic ) > 0 ) Iwa2 ( Iwa3 ( ic )) = Iwa2 ( ic ) ! ADD COLUMN IC TO THE NUMDEG-1 LIST. Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( numdeg - 1 ) if ( Iwa1 ( numdeg - 1 ) > 0 ) Iwa2 ( Iwa1 ( numdeg - 1 )) = ic Iwa1 ( numdeg - 1 ) = ic endif enddo enddo ! END OF ITERATION LOOP. goto 100 endif else mindeg = mindeg + 1 goto 200 endif end subroutine slo","tags":"","url":"proc/slo.html"},{"title":"srtdat – NumDiff","text":"private  subroutine srtdat(n, Nnz, Indrow, Indcol, Jpntr, Iwa) given the non-zero elements of an m by n matrix a in\narbitrary order as specified by their row and column\nindices, this subroutine permutes these elements so\nthat their column indices are in non-decreasing order. on input it is assumed that the elements are specified in indrow(k),indcol(k), k = 1,...,nnz . on output the elements are permuted so that indcol is\nin non-decreasing order. in addition, the array jpntr is set so that the row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that the value of m is not needed by srtdat and is\ntherefore not present in the subroutine statement. Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer :: Nnz a positive integer input variable set to the number\nof non-zero elements of a . integer, dimension(Nnz) :: Indrow an integer array of length nnz . on input indrow must contain the row indices of the non-zero elements of a .\non output indrow is permuted so that the corresponding\ncolumn indices of indcol are in non-decreasing order. integer, dimension(Nnz) :: Indcol an integer array of length nnz . on input indcol must contain the column indices of the non-zero elements\nof a . on output indcol is permuted so that these indices\nare in non-decreasing order. integer, dimension(n+1) :: Jpntr an integer output array of length n + 1 which\nspecifies the locations of the row indices in the output indrow . the row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(1) is set to 1 and that jpntr(n+1)-1 is then nnz . integer, dimension(n) :: Iwa an integer work array of length n . Called by proc~~srtdat~~CalledByGraph proc~srtdat srtdat proc~dsm dsm proc~dsm->proc~srtdat proc~dsm_wrapper sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm proc~compute_sparsity_random compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine srtdat ( n , Nnz , Indrow , Indcol , Jpntr , Iwa ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Nnz !! a positive integer input variable set to the number !! of non-zero elements of `a`. integer , dimension ( Nnz ) :: Indrow !! an integer array of length `nnz`. on input `indrow` !! must contain the row indices of the non-zero elements of `a`. !! on output `indrow` is permuted so that the corresponding !! column indices of `indcol` are in non-decreasing order. integer , dimension ( Nnz ) :: Indcol !! an integer array of length `nnz`. on input `indcol` !! must contain the column indices of the non-zero elements !! of `a`. on output `indcol` is permuted so that these indices !! are in non-decreasing order. integer , dimension ( n + 1 ) :: Jpntr !! an integer output array of length `n + 1` which !! specifies the locations of the row indices in the output !! `indrow`. the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(1)` is set to 1 and that `jpntr(n+1)-1` !! is then `nnz`. integer , dimension ( n ) :: Iwa !! an integer work array of length `n`. integer :: i , j , k , l ! store in array iwa the counts of non-zeroes in the columns. do j = 1 , n Iwa ( j ) = 0 enddo do k = 1 , Nnz Iwa ( Indcol ( k )) = Iwa ( Indcol ( k )) + 1 enddo ! set pointers to the start of the columns in indrow. Jpntr ( 1 ) = 1 do j = 1 , n Jpntr ( j + 1 ) = Jpntr ( j ) + Iwa ( j ) Iwa ( j ) = Jpntr ( j ) enddo k = 1 ! begin in-place sort. do j = Indcol ( k ) if ( k >= Jpntr ( j ) ) then ! current element is in position. now examine the ! next element or the first un-sorted element in ! the j-th group. k = max ( k + 1 , Iwa ( j )) else ! current element is not in position. place element ! in position and make the displaced element the ! current element. l = Iwa ( j ) Iwa ( j ) = Iwa ( j ) + 1 i = Indrow ( k ) Indrow ( k ) = Indrow ( l ) Indcol ( k ) = Indcol ( l ) Indrow ( l ) = i Indcol ( l ) = j endif if ( k > Nnz ) exit end do end subroutine srtdat","tags":"","url":"proc/srtdat.html"},{"title":"fdjs – NumDiff","text":"public  subroutine fdjs(m, n, Col, Ind, Npntr, Ngrp, Numgrp, d, Fjacd, Fjac) Given a consistent partition of the columns of an m by n jacobian matrix into groups, this subroutine computes\n  approximations to those columns in a given group.  the\n  approximations are stored into either a column-oriented\n  or a row-oriented pattern. a partition is consistent if the columns in any group\n  do not have a non-zero in the same row position. approximations to the columns of the jacobian matrix in a\n  given group can be obtained by specifying a difference\n  parameter array d with d(jcol) non-zero if and only if jcol is a column in the group, and an approximation to jac*d where jac denotes the jacobian matrix of a mapping f. d can be defined with the following segment of code. do jcol = 1 , n d ( jcol ) = 0.0 if ( ngrp ( jcol ) == numgrp ) d ( jcol ) = eta ( jcol ) end do in the above code numgrp is the given group number, ngrp(jcol) is the group number of column jcol , and eta(jcol) is the difference parameter used to\n  approximate column jcol of the jacobian matrix.\n  suitable values for the array eta must be provided. as mentioned above, an approximation to jac*d must\n  also be provided. for example, the approximation f ( x + d ) - f ( x ) corresponds to the forward difference formula at x . Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of the jacobian matrix. integer, intent(in) :: n a positive integer input variable set to the number\nof columns of the jacobian matrix. logical, intent(in) :: Col a logical input variable. if col is set true, then the\njacobian approximations are stored into a column-oriented\npattern. if col is set false, then the jacobian\napproximations are stored into a row-oriented pattern. integer, dimension(*) :: Ind an integer input array which contains the row\nindices for the non-zeroes in the jacobian matrix\nif col is true, and contains the column indices for\nthe non-zeroes in the jacobian matrix if col is false. integer, dimension(*) :: Npntr an integer input array which specifies the\nlocations of the row indices in ind if col is true, and\nspecifies the locations of the column indices in ind if col is false. if col is true, the indices for column j are ind(k), k = npntr(j),...,npntr(j+1)-1 .\nif col is false, the indices for row i are ind(k), k = npntr(i),...,npntr(i+1)-1 . Note that npntr(n+1)-1 if col is true, or npntr(m+1)-1 if col is false, is then the number of non-zero elements\nof the jacobian matrix. integer, dimension(n) :: Ngrp an integer input array of length n which specifies\nthe partition of the columns of the jacobian matrix.\ncolumn jcol belongs to group ngrp(jcol) . integer :: Numgrp a positive integer input variable set to a group\nnumber in the partition. the columns of the jacobian\nmatrix in this group are to be estimated on this call. real(kind=wp), dimension(n) :: d an input array of length n which contains the\ndifference parameter vector for the estimate of\nthe jacobian matrix columns in group numgrp . real(kind=wp), dimension(m) :: Fjacd an input array of length m which contains\nan approximation to the difference vector jac*d ,\nwhere jac denotes the jacobian matrix. real(kind=wp), dimension(*) :: Fjac an output array of length nnz , where nnz is the\nnumber of its non-zero elements. at each call of fdjs , fjac is updated to include the non-zero elements of the\njacobian matrix for those columns in group numgrp . fjac should not be altered between successive calls to fdjs . Source Code subroutine fdjs ( m , n , Col , Ind , Npntr , Ngrp , Numgrp , d , Fjacd , Fjac ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of the jacobian matrix. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of the jacobian matrix. integer :: Numgrp !! a positive integer input variable set to a group !! number in the partition. the columns of the jacobian !! matrix in this group are to be estimated on this call. integer , dimension ( * ) :: Ind !! an integer input array which contains the row !! indices for the non-zeroes in the jacobian matrix !! if `col` is true, and contains the column indices for !! the non-zeroes in the jacobian matrix if `col` is false. integer , dimension ( * ) :: Npntr !! an integer input array which specifies the !! locations of the row indices in `ind` if `col` is true, and !! specifies the locations of the column indices in `ind` if !! `col` is false. if `col` is true, the indices for column `j` are !!       `ind(k), k = npntr(j),...,npntr(j+1)-1`. !! if `col` is false, the indices for row `i` are !!       `ind(k), k = npntr(i),...,npntr(i+1)-1`. !! ***Note*** that `npntr(n+1)-1` if `col` is true, or `npntr(m+1)-1` !! if `col` is false, is then the number of non-zero elements !! of the jacobian matrix. integer , dimension ( n ) :: Ngrp !! an integer input array of length `n` which specifies !! the partition of the columns of the jacobian matrix. !! column `jcol` belongs to group `ngrp(jcol)`. real ( wp ), dimension ( n ) :: d !! an input array of length `n` which contains the !! difference parameter vector for the estimate of !! the jacobian matrix columns in group `numgrp`. real ( wp ), dimension ( m ) :: Fjacd !! an input array of length `m` which contains !! an approximation to the difference vector `jac*d`, !! where `jac` denotes the jacobian matrix. real ( wp ), dimension ( * ) :: Fjac !! an output array of length `nnz`, where `nnz` is the !! number of its non-zero elements. at each call of `fdjs`, !! `fjac` is updated to include the non-zero elements of the !! jacobian matrix for those columns in group `numgrp`. `fjac` !! should not be altered between successive calls to `fdjs`. logical , intent ( in ) :: Col !! a logical input variable. if `col` is set true, then the !! jacobian approximations are stored into a column-oriented !! pattern. if `col` is set false, then the jacobian !! approximations are stored into a row-oriented pattern. integer :: ip , irow , jcol , jp ! compute estimates of jacobian matrix columns in group ! numgrp. the array fjacd must contain an approximation ! to jac*d, where jac denotes the jacobian matrix and d ! is a difference parameter vector with d(jcol) non-zero ! if and only if jcol is a column in group numgrp. if ( Col ) then ! column orientation. do jcol = 1 , n if ( Ngrp ( jcol ) == Numgrp ) then do jp = Npntr ( jcol ) , Npntr ( jcol + 1 ) - 1 irow = Ind ( jp ) Fjac ( jp ) = Fjacd ( irow ) / d ( jcol ) enddo endif enddo else ! row orientation. do irow = 1 , m do ip = Npntr ( irow ) , Npntr ( irow + 1 ) - 1 jcol = Ind ( ip ) if ( Ngrp ( jcol ) == Numgrp ) then Fjac ( ip ) = Fjacd ( irow ) / d ( jcol ) exit endif enddo enddo endif end subroutine fdjs","tags":"","url":"proc/fdjs.html"},{"title":"numdiff_cache_module – NumDiff","text":"For caching function evaluations. Uses numdiff_utilities_module iso_fortran_env numdiff_kinds_module module~~numdiff_cache_module~~UsesGraph module~numdiff_cache_module numdiff_cache_module iso_fortran_env iso_fortran_env module~numdiff_cache_module->iso_fortran_env module~numdiff_kinds_module numdiff_kinds_module module~numdiff_cache_module->module~numdiff_kinds_module module~numdiff_utilities_module numdiff_utilities_module module~numdiff_cache_module->module~numdiff_utilities_module module~numdiff_kinds_module->iso_fortran_env module~numdiff_utilities_module->module~numdiff_kinds_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~numdiff_cache_module~~UsedByGraph module~numdiff_cache_module numdiff_cache_module module~numerical_differentiation_module numerical_differentiation_module module~numerical_differentiation_module->module~numdiff_cache_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, private :: fx an [x,f(x)] cached pair. Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:), allocatable :: x vector of input values real(kind=wp), private, dimension(:), allocatable :: f vector of output functions f(x) note: only the elements indicated by ifs will have valid values. The others will\nbe dummy values. integer, private, dimension(:), allocatable :: ifs elements of f present in the cache\n(this is just an array of the indices\npresent in f ) type, public :: function_cache a vector function cache. Components Type Visibility Attributes Name Initial integer, private :: n = 0 size of x integer, private :: m = 0 size of f type( fx ), private, dimension(:), allocatable :: c the cache of f(x) integer, private :: chunk_size = 100 for resizing vectors\nin the unique function Type-Bound Procedures procedure, public :: initialize => initialize_cache procedure, public :: get => get_from_cache procedure, public :: put => put_in_cache procedure, public :: destroy => destroy_cache procedure, public :: print => print_cache Functions private pure function vector_djb_hash (r) result(hash) DJB hash algorithm for a real(wp) vector. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: r the vector Return Value integer(kind=ip) the hash value Subroutines private  subroutine initialize_cache (me, isize, n, m, chunk_size) Initialize the cache. Must be called first before use. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in) :: n number of independant variables (x) integer, intent(in) :: m number of functions (f) integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] private  subroutine print_cache (me, iunit) Print the contents of the cache. Used for debugging. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: iunit file unit for writing\n(assumed to be opened) private  subroutine get_from_cache (me, x, ifs, i, f, xfound, ffound) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x independant variable vector integer, intent(in), dimension(:) :: ifs elements of f needed integer, intent(out) :: i index in the hash table real(kind=wp), intent(out), dimension(:) :: f f(x) from the cache (if it was found) logical, intent(out) :: xfound if x was found in the cache logical, intent(out), dimension(size(ifs)) :: ffound which ifs were found in the cache private  subroutine put_in_cache (me, i, x, f, ifs) Put a value into the cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: i index in the hash table real(kind=wp), intent(in), dimension(:) :: x independant variable vector (dimension n ) real(kind=wp), intent(in), dimension(:) :: f function vector f(x) (dimension m ) integer, intent(in), dimension(:) :: ifs elements of f to add (should all be >0, <=m ) private  subroutine destroy_cache (me) Destroy a cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me","tags":"","url":"module/numdiff_cache_module.html"},{"title":"diff_module – NumDiff","text":"Numerical differentiation of a 1D function f(x) using Neville's process. Authors J. Oliver, \"An algorithm for numerical differentiation of a function\n     of one real variable\", Journal of Computational and Applied Mathematics\n     6 (2) (1980) 145–160. [Algol 60 source in original paper] David Kahaner, Fortran 77 code from NIST Jacob Williams : 2/17/2013 : Converted to modern Fortran.\n     Some refactoring, addition of test cases. Uses numdiff_kinds_module module~~diff_module~~UsesGraph module~diff_module diff_module module~numdiff_kinds_module numdiff_kinds_module module~diff_module->module~numdiff_kinds_module iso_fortran_env iso_fortran_env module~numdiff_kinds_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~diff_module~~UsedByGraph module~diff_module diff_module module~numerical_differentiation_module numerical_differentiation_module module~numerical_differentiation_module->module~diff_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private  function func(me, x) result(fx) interface to function for diff Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me real(kind=wp), intent(in) :: x Return Value real(kind=wp) Derived Types type, public :: diff_func class to define the function for diff Components Type Visibility Attributes Name Initial logical, private :: stop = .false. procedure( func ), private, pointer :: f => null() Type-Bound Procedures procedure, private :: faccur procedure, public :: set_function procedure, public :: compute_derivative => diff procedure, public :: terminate Subroutines private  subroutine set_function (me, f) Author Jacob Williams Date 12/27/2015 Set the function in a diff_func .\nMust be called before diff . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me procedure( func ) :: f private  subroutine terminate (me) Can be called by the user in the function to terminate the computation.\nThis will set ifail=-1 . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me private  subroutine diff (me, iord, x0, xmin, xmax, eps, accr, deriv, error, ifail) the procedure diff calculates the first, second or\nthird order derivative of a function by using neville's process to\nextrapolate from a sequence of simple polynomial approximations based on\ninterpolating points distributed symmetrically about x0 (or lying only on\none side of x0 should this be necessary).  if the specified tolerance is\nnon-zero then the procedure attempts to satisfy this absolute or relative\naccuracy requirement, while if it is unsuccessful or if the tolerance is\nset to zero then the result having the minimum achievable estimated error\nis returned instead. Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me integer, intent(in) :: iord 1, 2 or 3 specifies that the first, second or third order\nderivative,respectively, is required. real(kind=wp), intent(in) :: x0 the point at which the derivative of the function is to be calculated. real(kind=wp), intent(in) :: xmin xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: xmax xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: eps denotes the tolerance, either absolute or relative. eps=0 specifies that\nthe error is to be minimised, while eps>0 or eps<0 specifies that the\nabsolute or relative error, respectively, must not exceed abs(eps) if\npossible.  the accuracy requirement should not be made stricter than\nnecessary, since the amount of computation tends to increase as\nthe magnitude of eps decreases, and is particularly high when eps=0 . real(kind=wp), intent(in) :: accr denotes that the absolute ( accr>0 ) or relative ( accr<0 ) errors in the\ncomputed values of the function are most unlikely to exceed abs(accr) , which\nshould be as small as possible.  if the user cannot estimate accr with\ncomplete confidence, then it should be set to zero. real(kind=wp), intent(out) :: deriv the calculated value of the derivative real(kind=wp), intent(out) :: error an estimated upper bound on the magnitude of the absolute error in\nthe calculated result.  it should always be examined, since in extreme case\nmay indicate that there are no correct significant digits in the value\nreturned for derivative. integer, intent(out) :: ifail will have one of the following values on exit: 0 the procedure was successful. 1 the estimated error in the result exceeds the (non-zero) requested\n     error, but the most accurate result possible has been returned. 2 input data incorrect (derivative and error will be undefined). 3 the interval [ xmin , xmax ] is too small (derivative and error will be\n     undefined). -1 stopped by the user. private  subroutine faccur (me, h0, h1, facc, x0, twoinf, f0, f1, ifail) This procedure attempts to estimate the level of rounding errors in\nthe calculated function values near the point x0+h0 by fitting a\nleast-squares straight-line approximation to the function at the\nsix points x0+h0-j*h1 , ( j = 0,1,3,5,7,9 ), and then setting facc to\ntwice the largest deviation of the function values from this line. hi is adjusted if necessary so that it is approximately 8 times the\nsmallest spacing at which the function values are unequal near x0+h0 . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me real(kind=wp), intent(inout) :: h0 real(kind=wp), intent(inout) :: h1 real(kind=wp), intent(out) :: facc real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: twoinf real(kind=wp), intent(in) :: f0 real(kind=wp), intent(in) :: f1 integer, intent(out) :: ifail 0 if no error, -1 if user termination.","tags":"","url":"module/diff_module.html"},{"title":"numerical_differentiation_module – NumDiff","text":"Numerical differentiation module for computing the Jacobian matrix\n(the derivative matrix of m functions w.r.t. n variables) using\nfinite differences. Uses numdiff_kinds_module iso_fortran_env diff_module numdiff_cache_module dsm_module numdiff_utilities_module module~~numerical_differentiation_module~~UsesGraph module~numerical_differentiation_module numerical_differentiation_module iso_fortran_env iso_fortran_env module~numerical_differentiation_module->iso_fortran_env module~diff_module diff_module module~numerical_differentiation_module->module~diff_module module~dsm_module dsm_module module~numerical_differentiation_module->module~dsm_module module~numdiff_cache_module numdiff_cache_module module~numerical_differentiation_module->module~numdiff_cache_module module~numdiff_kinds_module numdiff_kinds_module module~numerical_differentiation_module->module~numdiff_kinds_module module~numdiff_utilities_module numdiff_utilities_module module~numerical_differentiation_module->module~numdiff_utilities_module module~diff_module->module~numdiff_kinds_module module~dsm_module->module~numdiff_kinds_module module~numdiff_cache_module->iso_fortran_env module~numdiff_cache_module->module~numdiff_kinds_module module~numdiff_cache_module->module~numdiff_utilities_module module~numdiff_kinds_module->iso_fortran_env module~numdiff_utilities_module->module~numdiff_kinds_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=wp), private, parameter :: zero = 0.0_wp Interfaces public        interface finite_diff_method constructor private  function initialize_finite_difference_method (id, name, class, dx_factors, df_factors, df_den_factor) result(me) Constructor for a finite_diff_method . Note factors are input as integers for convenience, but are converted\n      to reals for the actual computations. (note: this means we can't\n      currently define methods that have non-integer factors). Arguments Type Intent Optional Attributes Name integer, intent(in) :: id unique ID for the method character(len=*), intent(in) :: name the name of the method integer, intent(in) :: class 2=backward diffs, 3=central diffs, etc... integer, intent(in), dimension(:) :: dx_factors multiplicative factors for dx perturbation integer, intent(in), dimension(:) :: df_factors multiplicative factors for accumulating function evaluations integer, intent(in) :: df_den_factor denominator factor for finite difference equation (times dx) Return Value type( finite_diff_method ) Abstract Interfaces abstract interface private  subroutine func(me, x, f, funcs_to_compute) The function (vector array of output functions f , computed\nfrom a vector of input variables x ).\nThis must be defined for all computations. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x array of variables (size n ) real(kind=wp), intent(out), dimension(:) :: f array of functions (size m ) integer, intent(in), dimension(:) :: funcs_to_compute the elements of the\nfunction vector that need\nto be computed (the other\nare ignored) abstract interface private  subroutine spars_f(me, x) The function to compute the sparsity pattern.\nIt populates the irow and icol variables in the class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) abstract interface private  subroutine info_f(me, column, i, x) User-defined info function (optional).\nInforms user what is being done during Jacobian computation.\nIt can be used to perform any setup operations that need to\ndone on the user's end. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in), dimension(:) :: column the columns being computed. integer, intent(in) :: i perturbing these columns for the i th time (1,2,...) real(kind=wp), intent(in), dimension(:) :: x the nominal variable vector abstract interface private  subroutine jacobian_f(me, x, dx, jac) Actual function for computing the Jacobian\ncalled by compute_jacobian . Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0) for each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) Derived Types type, public :: finite_diff_method defines the finite difference method\nused to compute the Jacobian. Read more… Components Type Visibility Attributes Name Initial integer, private :: id = 0 unique ID for the method character(len=:), private, allocatable :: name the name of the method integer, private :: class = 0 2=backward diffs, 3=central diffs, etc... real(kind=wp), private, dimension(:), allocatable :: dx_factors multiplicative factors for dx perturbation real(kind=wp), private, dimension(:), allocatable :: df_factors multiplicative factors for accumulating function evaluations real(kind=wp), private :: df_den_factor = zero denominator factor for finite difference equation (times dx ) Constructor constructor private\n\n                    \n                    function initialize_finite_difference_method (id, name, class, dx_factors, df_factors, df_den_factor) Constructor for a finite_diff_method . Read more… Type-Bound Procedures procedure, public :: get_formula procedure, public :: print => print_finite_difference_method type, public :: meth_array to store an array of finite_diff_method types\nthis is used when the mode=2 option is used\nin numdiff_type Components Type Visibility Attributes Name Initial type( finite_diff_method ), private, dimension(:), allocatable :: meth type, public :: sparsity_pattern A sparsity pattern Components Type Visibility Attributes Name Initial logical, private :: sparsity_computed = .false. has the sparsity pattern already been computed? integer, private :: num_nonzero_elements = 0 number of nonzero elements in the jacobian\n(will be the dimension of irow and icol ) integer, private, dimension(:), allocatable :: irow sparsity pattern - rows of non-zero elements integer, private, dimension(:), allocatable :: icol sparsity pattern - columns of non-zero elements logical, private :: linear_sparsity_computed = .false. if the linear pattern has been populated integer, private :: num_nonzero_linear_elements = 0 number of constant elements in the jacobian integer, private, dimension(:), allocatable :: linear_irow linear sparsity pattern - rows of non-zero elements integer, private, dimension(:), allocatable :: linear_icol linear sparsity pattern - columns of non-zero elements real(kind=wp), private, dimension(:), allocatable :: linear_vals linear elements of the jacobian integer, private, dimension(:), allocatable :: indices index vector [1,2,...,num_nonzero_elements] for putting df into jac integer, private :: maxgrp = 0 the number of groups in the partition\nof the columns of a . integer, private, dimension(:), allocatable :: ngrp specifies the partition of the columns of a .\ncolumn jcol belongs to group ngrp(jcol) . size(n) Type-Bound Procedures procedure, private :: dsm_wrapper procedure, private :: compute_indices procedure, public :: destroy => destroy_sparsity procedure, public :: print => print_sparsity procedure, public :: columns_in_partition_group type, public :: numdiff_type base type for sparsity and Jacobian computations. Components Type Visibility Attributes Name Initial logical, private :: exception_raised = .false. if true, an exception has been raised integer, private :: istat = 0 a non-zero value will cause all routine to exit.\nthis can be set to -1 by calling terminate . character(len=:), private, allocatable :: error_msg error message (if istat/=0 ) integer, private :: n = 0 number of x variables integer, private :: m = 0 number of f functions real(kind=wp), private, dimension(:), allocatable :: xlow lower bounds on x real(kind=wp), private, dimension(:), allocatable :: xhigh upper bounds on x logical, private :: print_messages = .true. if true, warning messages are printed\nto the error_unit for any errors. integer, private :: chunk_size = 100 chuck size for allocating the arrays (>0) integer, private :: perturb_mode = 1 perturbation mode: Read more… real(kind=wp), private, dimension(:), allocatable :: dpert perturbation vector for x logical, private :: partition_sparsity_pattern = .false. to partition the sparsity pattern using dsm type( sparsity_pattern ), private :: sparsity the sparsity pattern real(kind=wp), private, dimension(:), allocatable :: xlow_for_sparsity lower bounds on x for computing sparsity (optional) real(kind=wp), private, dimension(:), allocatable :: xhigh_for_sparsity upper bounds on x for computing sparsity (optional) real(kind=wp), private, dimension(:), allocatable :: dpert_for_sparsity perturbation vector for x when computing\nsparsity for sparsity_mode=4 integer, private :: num_sparsity_points = 3 for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern.\nSee compute_sparsity_random_2 integer, private :: sparsity_perturb_mode = 1 perturbation mode (if sparsity_mode=4 ): Read more… logical, private :: compute_linear_sparsity_pattern = .false. to also compute the linear sparsity pattern real(kind=wp), private :: linear_sparsity_tol = epsilon(1.0_wp) the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), private :: function_precision_tol = epsilon(1.0_wp) the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, private :: mode = 1 1 = use meth (specified methods), 2 = use class (specified class, method is selected on-the-fly). type( finite_diff_method ), private, dimension(:), allocatable :: meth the finite difference method to use\ncompute the n th column of the Jacobian size(n) .  Either this or class is used integer, private, dimension(:), allocatable :: class the class of method to use to\ncompute the n th column of the Jacobian size(n) . Either this or meth is used type( meth_array ), private, dimension(:), allocatable :: class_meths array of methods for the specified classes.\nused with class when mode=2 real(kind=wp), private :: eps = 1.0e-9_wp tolerance parameter for diff real(kind=wp), private :: acc = 0.0_wp tolerance parameter for diff type( function_cache ), private :: cache if using the function cache logical, private :: use_diff = .false. if we are using the Neville's process method,\nrather than finite differences procedure( func ), private, pointer :: problem_func => null() the user-defined function procedure( func ), private, pointer :: compute_function => null() compute the user-defined function\nthis can point to the problem_func or, if using\nthe cache, it points to compute_function_with_cache . procedure( spars_f ), private, pointer :: compute_sparsity => null() for computing the sparsity pattern procedure( info_f ), private, pointer :: info_function => null() an optional function the user can define\nwhich is called when each column of the jacobian is computed.\nIt can be used to perform any setup operations. procedure( jacobian_f ), private, pointer :: jacobian_function => null() the low-level function called by compute_jacobian that actually computes the jacobian. Type-Bound Procedures procedure, public :: initialize => initialize_numdiff ../../ initialize the class procedure, public :: diff_initialize => initialize_numdiff_for_diff ../../ initialize the class procedure, public :: compute_jacobian ../../ main routine to compute the Jacobian\nusing the selected options. It\nreturns the sparse (vector) form. procedure, public :: compute_jacobian_dense ../../ return the dense size(m,n) matrix form of the Jacobian. procedure, public :: compute_jacobian_times_vector ../../ returns the product of the Jacobian\nmatrix and an input vector procedure, public :: destroy => destroy_numdiff_type ../../ destroy the class procedure, public :: print_sparsity_pattern ../../ print the sparsity pattern in vector form to a file procedure, public :: print_sparsity_matrix ../../ print the sparsity pattern in matrix form to a file procedure, public :: set_sparsity_pattern ../../ manually set the sparsity pattern procedure, public :: select_finite_diff_method ../../ select a method in a specified class so\nthat the variable bounds are not violated\nwhen by the perturbations. procedure, public :: select_finite_diff_method_for_partition_group version of select_finite_diff_method for partitioned sparsity pattern. procedure, public :: set_numdiff_bounds ../../ can be called to change the variable bounds. procedure, public :: compute_sparsity_pattern ../../ if the user needs to compute the sparsity pattern manually.\n(otherwise it will be done the first time the Jacobian is computed) procedure, public :: get_sparsity_pattern ../../ returns the sparsity pattern (if it is allocated) procedure, public :: terminate ../../ can be called by user to stop the computation procedure, public :: failed ../../ to check if an exception was raised. procedure, public :: get_error_status ../../ the status of error condition procedure, public :: set_dpert ../../ change the dpert values procedure, private :: destroy_sparsity_pattern ../../ destroy the sparsity pattern procedure, private :: compute_perturb_vector procedure, private :: compute_perturbation_vector ../../ computes the variable perturbation factor procedure, private :: compute_sparsity_perturbation_vector procedure, private :: perturb_x_and_compute_f procedure, private :: perturb_x_and_compute_f_partitioned procedure, private :: set_numdiff_sparsity_bounds procedure, private :: set_sparsity_mode procedure, private :: generate_dense_sparsity_partition procedure, private :: compute_jacobian_for_sparsity procedure, private :: resize_sparsity_vectors procedure, private :: raise_exception procedure, private :: clear_exceptions Functions private  function initialize_finite_difference_method (id, name, class, dx_factors, df_factors, df_den_factor) result(me) Constructor for a finite_diff_method . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: id unique ID for the method character(len=*), intent(in) :: name the name of the method integer, intent(in) :: class 2=backward diffs, 3=central diffs, etc... integer, intent(in), dimension(:) :: dx_factors multiplicative factors for dx perturbation integer, intent(in), dimension(:) :: df_factors multiplicative factors for accumulating function evaluations integer, intent(in) :: df_den_factor denominator factor for finite difference equation (times dx) Return Value type( finite_diff_method ) public  function get_all_methods_in_class (class) result(list_of_methods) Returns all the methods with the given class (i.e., number of points in the formula). Arguments Type Intent Optional Attributes Name integer, intent(in) :: class the class is the number of points in the\nfinite different computation Return Value type( meth_array ) all the methods with the specified class private pure function failed (me) Returns True if an exception has been raised. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me Return Value logical private  function integer_to_string (i, with_sign) result(str) Convert an integer to a string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i the integer logical, intent(in), optional :: with_sign also include the sign (default is False) Return Value character(len=:), allocatable integer converted to a string Subroutines private  subroutine print_finite_difference_method (me, iunit) Print the contents of a finite_diff_method . Used for debugging. Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me integer, intent(in) :: iunit file unit for printing\n(assumed to be opened) private  subroutine compute_function_with_cache (me, x, f, funcs_to_compute) Wrapper for computing the function, using the cache. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x array of variables (size n ) real(kind=wp), intent(out), dimension(:) :: f array of functions (size m ) integer, intent(in), dimension(:) :: funcs_to_compute the elements of the\nfunction vector that need\nto be computed (the other\nare ignored) private  subroutine get_formula (me, formula) Return a string with the finite difference formula. Read more… Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me character(len=:), intent(out), allocatable :: formula public  subroutine get_finite_diff_formula (id, formula, name) Return a string with the finite difference formula.\n  Input is the method id code. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: id the id code for the method character(len=:), intent(out), allocatable :: formula the formula string character(len=:), intent(out), optional, allocatable :: name private  subroutine get_finite_difference_method (id, fd, found) Return a finite_diff_method given the id code.\n  (the id codes begin at 1, are sequential, and uniquely define the method). Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: id the id code for the method type( finite_diff_method ), intent(out) :: fd this method (can be used\nin compute_jacobian ) logical, intent(out) :: found true if it was found private  subroutine select_finite_diff_method (me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in) :: x the variable value real(kind=wp), intent(in) :: xlow the variable lower bound real(kind=wp), intent(in) :: xhigh the variable upper bound real(kind=wp), intent(in) :: dx the perturbation value (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . private  subroutine select_finite_diff_method_for_partition_group (me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds for any variable in the group. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x the variable values real(kind=wp), intent(in), dimension(:) :: xlow the variable lower bounds real(kind=wp), intent(in), dimension(:) :: xhigh the variable upper bounds real(kind=wp), intent(in), dimension(:) :: dx the perturbation values (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . private  subroutine initialize_numdiff_for_diff (me, n, m, xlow, xhigh, problem_func, sparsity_mode, info, chunk_size, eps, acc, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points, print_messages) Alternate version of initialize_numdiff routine when\nusing diff to compute the Jacobian. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: Read more… procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] real(kind=wp), intent(in), optional :: eps tolerance parameter for diff if not present, default is 1.0e-9_wp real(kind=wp), intent(in), optional :: acc tolerance parameter for diff if not present, default is 0.0_wp integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity required if sparsity_mode=4 integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): Read more… real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. logical, intent(in), optional :: print_messages if true, print error messages to error_unit .\ndefault is True. private  subroutine set_numdiff_bounds (me, xlow, xhigh) Change the variable bounds in a numdiff_type . Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(:) :: xhigh upper bounds on x private  subroutine set_sparsity_mode (me, sparsity_mode, xlow_for_sparsity, xhigh_for_sparsity) Set sparsity mode. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. real(kind=wp), intent(in), optional, dimension(:) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. private  subroutine set_numdiff_sparsity_bounds (me, xlow, xhigh) Sets the variable bounds for sparsity in a numdiff_type .\n  These are only used for sparsity_mode=2 . Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), optional, dimension(:) :: xlow lower bounds on x to be used for\nsparsity computation. If not present,\nthen then xlow values in the class are used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh upper bounds on x to be used for\nsparsity computation. If not present,\nthen then xhigh values in the class are used. private  subroutine set_dpert (me, dpert) Change the dpert vector. Can be used after the class has been initialized\nto change the perturbation step sizes (e.g., after an iteration). Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: dpert perturbation vector for x private  subroutine initialize_numdiff (me, n, m, xlow, xhigh, perturb_mode, dpert, problem_func, sparsity_mode, jacobian_method, jacobian_methods, class, classes, info, chunk_size, partition_sparsity_pattern, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points) Initialize a numdiff_type class. This must be called first. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x integer, intent(in) :: perturb_mode perturbation mode: 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), dimension(n) :: dpert perturbation vector for x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. integer, intent(in), optional :: jacobian_method id code for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: jacobian_methods id codes for the finite difference method\nto use for each variable.\nsee get_finite_difference_method integer, intent(in), optional :: class method class for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: classes method class for the finite difference methods\nto use for each variable.\nsee get_finite_difference_method procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] logical, intent(in), optional :: partition_sparsity_pattern if the sparisty pattern is to\nbe partitioned using dsm [default is False] integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity for sparsity_mode=4 , the perturbation integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. private  subroutine destroy_numdiff_type (me) destroy the numdiff_type class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(out) :: me private  subroutine destroy_sparsity (me) destroy a sparsity_pattern type. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(out) :: me private  subroutine dsm_wrapper (me, n, m, info) Wrapper for dsm to compute the sparsity pattern partition. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me integer, intent(in) :: n number of columns of jacobian matrix integer, intent(in) :: m number of rows of jacobian matrix integer, intent(out) :: info status output from dsm private  subroutine columns_in_partition_group (me, igroup, n_cols, cols, nonzero_rows, indices, status_ok) Returns the columns in a sparsity partition group. Read more… Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: igroup group number. Should be >0 and <=me%mxgrp integer, intent(out) :: n_cols number of columns in the igroup group. integer, intent(out), dimension(:), allocatable :: cols the column numbers in the igroup group.\n(if none, then it is not allocated) integer, intent(out), dimension(:), allocatable :: nonzero_rows the row numbers of all the nonzero\nJacobian elements in this group integer, intent(out), dimension(:), allocatable :: indices nonzero indices in jac for a group logical, intent(out) :: status_ok true if the partition is valid private  subroutine destroy_sparsity_pattern (me) Destroy the sparsity pattern in the class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me private  subroutine compute_indices (me) Computes the indices vector in the class. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me private  subroutine set_sparsity_pattern (me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) To specify the sparsity pattern directly if it is already known. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in), dimension(:) :: irow sparsity pattern nonzero elements row indices integer, intent(in), dimension(:) :: icol sparsity pattern nonzero elements column indices integer, intent(in), optional, dimension(:) :: linear_irow linear sparsity pattern nonzero elements row indices integer, intent(in), optional, dimension(:) :: linear_icol linear sparsity pattern nonzero elements column indices real(kind=wp), intent(in), optional, dimension(:) :: linear_vals linear sparsity values (constant elements of the Jacobian) integer, intent(in), optional :: maxgrp DSM sparsity partition\n[only used if me%partition_sparsity_pattern=True ] integer, intent(in), optional, dimension(:) :: ngrp DSM sparsity partition (size n )\n[only used if me%partition_sparsity_pattern=True ] private  subroutine compute_sparsity_dense (me, x) assume all elements of Jacobian are non-zero. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) private  subroutine generate_dense_sparsity_partition (me) Generate a \"dense\" sparsity partition. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me private  subroutine compute_sparsity_random (me, x) Compute the sparsity pattern by computing the function at three\n\"random\" points in the [ xlow_for_sparsity , xhigh_for_sparsity ] interval\nand checking if the function values are the same. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n )\n(not used here) private  subroutine resize_sparsity_vectors (me, n_icol, n_irow, n_linear_icol, n_linear_irow, n_linear_vals) Resize the sparsity arrays after accumulating them. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(inout) :: n_icol integer, intent(inout) :: n_irow integer, intent(inout) :: n_linear_icol integer, intent(inout) :: n_linear_irow integer, intent(inout) :: n_linear_vals private  subroutine compute_sparsity_random_2 (me, x) Compute the sparsity pattern by computing a 2-point jacobian at a specified\nnumber of \"random\" points ( num_sparsity_points ) in the\n[ xlow_for_sparsity , xhigh_for_sparsity ] interval and checking if\nthey are the same. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n )\n(not used here) private  subroutine compute_sparsity_pattern (me, x, irow, icol, linear_irow, linear_icol, linear_vals) Computes the sparsity pattern and return it.\nUses the settings currently in the class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) private  subroutine get_sparsity_pattern (me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) Returns the sparsity pattern from the class.\nIf it hasn't been computed, the output arrays will not be allocated. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) integer, intent(out), optional :: maxgrp DSM sparsity partition integer, intent(out), optional, dimension(:), allocatable :: ngrp DSM sparsity partition private  subroutine compute_jacobian_dense (me, x, jac) just a wrapper for compute_jacobian , that returns a dense ( m x n ) matrix. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:,:), allocatable :: jac the jacobian matrix private  subroutine perturb_x_and_compute_f (me, x, dx_factor, dx, df_factor, column, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in) :: column the variable to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero private  subroutine compute_jacobian_times_vector (me, x, v, z) Returns the product J*v , where J is the m x n Jacobian matrix\n  and v is an n x 1 vector. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(:) :: v vector (size n ) real(kind=wp), intent(out), dimension(:) :: z The product J*v (size m ) private  subroutine compute_jacobian (me, x, jac) Compute the Jacobian. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector private  subroutine compute_jacobian_for_sparsity (me, i, class_meths, x, jac) A separate version of compute_jacobian to be used only when\n  computing the sparsity pattern in compute_sparsity_random_2 .\n  It uses class_meths and the sparsity dperts and bounds. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: i the column being computed type( meth_array ), intent(in) :: class_meths set of finite diff methods to use real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector private  subroutine compute_jacobian_standard (me, x, dx, jac) Compute the Jacobian using finite differences.\n(one column at a time) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) private  subroutine compute_jacobian_with_diff (me, x, dx, jac) Compute the Jacobian one element at a time using the Neville's process\nalgorithm diff . This takes a very large number of function evaluations,\nbut should give a very accurate answer. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) private  subroutine compute_jacobian_partitioned (me, x, dx, jac) Compute the Jacobian using finite differences,\n(using the partitioned sparsity pattern to compute multiple columns\nat a time). Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0) for each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector private  subroutine perturb_x_and_compute_f_partitioned (me, x, dx_factor, dx, df_factor, columns, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in), dimension(:) :: columns the variables to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero private  subroutine compute_perturb_vector (me, x, dpert, perturb_mode, dx) Compute dx , the perturbation vector for x Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dpert integer, intent(in) :: perturb_mode real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable private  subroutine compute_perturbation_vector (me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the gradients. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable private  subroutine compute_sparsity_perturbation_vector (me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the sparsity pattern. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable private  subroutine print_sparsity (me, n, m, iunit, dense) Print the sparsity pattern. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: n number of variables (columns of jacobian) integer, intent(in) :: m number of functions (rows of jacobian) integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) logical, intent(in), optional :: dense if present and true, the matrix form\nof the sparsity pattern is printed\n(default is vector form) private  subroutine print_sparsity_pattern (me, iunit) Print the sparsity pattern in vector form ( irow , icol ). Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) private  subroutine print_sparsity_matrix (me, iunit) Print the sparsity pattern in matrix form. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) private  subroutine terminate (me) A user-callable routine. When called, it will terminate\nall computations and return. The istat return code will be\nset to -1 . This can be called in the function or the info function. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me private  subroutine raise_exception (me, istat, routine, error_msg) Raise an exception. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: istat error code. character(len=*), intent(in) :: routine the routine where the error was raised. character(len=*), intent(in) :: error_msg error message string. private  subroutine clear_exceptions (me) Clear all exceptions. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me private  subroutine get_error_status (me, istat, error_msg) Returns the current error code and message. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me integer, intent(out), optional :: istat error code ( istat=0 means no errors). character(len=:), intent(out), optional, allocatable :: error_msg error message string.","tags":"","url":"module/numerical_differentiation_module.html"},{"title":"numdiff_utilities_module – NumDiff","text":"Utility routines. Uses numdiff_kinds_module module~~numdiff_utilities_module~~UsesGraph module~numdiff_utilities_module numdiff_utilities_module module~numdiff_kinds_module numdiff_kinds_module module~numdiff_utilities_module->module~numdiff_kinds_module iso_fortran_env iso_fortran_env module~numdiff_kinds_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~numdiff_utilities_module~~UsedByGraph module~numdiff_utilities_module numdiff_utilities_module module~numdiff_cache_module numdiff_cache_module module~numdiff_cache_module->module~numdiff_utilities_module module~numerical_differentiation_module numerical_differentiation_module module~numerical_differentiation_module->module~numdiff_utilities_module module~numerical_differentiation_module->module~numdiff_cache_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: max_size_for_insertion_sort = 20 max size for using insertion sort. Interfaces public        interface expand_vector private pure subroutine expand_vector_int (vec, n, chunk_size, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) private pure subroutine expand_vector_real (vec, n, chunk_size, val, finished) Add elements to the real vector in chunks. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) real(kind=wp), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) public        interface unique private  function unique_int (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value integer, dimension(:), allocatable unique elements of ivec private  function unique_real (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value real(kind=wp), dimension(:), allocatable unique elements of ivec public        interface sort_ascending private  subroutine sort_ascending_int (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_real (ivec) Sorts a real array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: ivec private        interface swap private pure elemental subroutine swap_int (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap_real (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: i1 real(kind=wp), intent(inout) :: i2 Functions private  function unique_int (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value integer, dimension(:), allocatable unique elements of ivec private  function unique_real (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value real(kind=wp), dimension(:), allocatable unique elements of ivec public pure function equal_within_tol (vals, tol) result(equal) Returns true if the values in the array are the same\n(to within the specified absolute tolerance). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vals a set of values real(kind=wp), intent(in) :: tol a positive tolerance value Return Value logical true if they are equal\nwithin the tolerance public  function divide_interval (num_points) result(points) Returns a set of slightly randomized equally-spaced\n  points that divide an interval. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_points the number of points in the interval Return Value real(kind=wp), dimension(:), allocatable the resultant vector Subroutines private pure subroutine expand_vector_int (vec, n, chunk_size, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) private pure subroutine expand_vector_real (vec, n, chunk_size, val, finished) Add elements to the real vector in chunks. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) real(kind=wp), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) private  subroutine sort_ascending_int (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_real (ivec) Sorts a real array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: ivec private pure elemental subroutine swap_int (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap_real (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: i1 real(kind=wp), intent(inout) :: i2","tags":"","url":"module/numdiff_utilities_module.html"},{"title":"numdiff_kinds_module – NumDiff","text":"Numeric kinds for NumDiff. Note The default real kind ( wp ) can be\n      changed using optional preprocessor flags.\n      This library was built with real kind: real(kind=real64) [8 bytes] Uses iso_fortran_env module~~numdiff_kinds_module~~UsesGraph module~numdiff_kinds_module numdiff_kinds_module iso_fortran_env iso_fortran_env module~numdiff_kinds_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~numdiff_kinds_module~~UsedByGraph module~numdiff_kinds_module numdiff_kinds_module module~diff_module diff_module module~diff_module->module~numdiff_kinds_module module~dsm_module dsm_module module~dsm_module->module~numdiff_kinds_module module~numdiff_cache_module numdiff_cache_module module~numdiff_cache_module->module~numdiff_kinds_module module~numdiff_utilities_module numdiff_utilities_module module~numdiff_cache_module->module~numdiff_utilities_module module~numdiff_utilities_module->module~numdiff_kinds_module module~numerical_differentiation_module numerical_differentiation_module module~numerical_differentiation_module->module~numdiff_kinds_module module~numerical_differentiation_module->module~diff_module module~numerical_differentiation_module->module~dsm_module module~numerical_differentiation_module->module~numdiff_cache_module module~numerical_differentiation_module->module~numdiff_utilities_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = real64 default real kind [8 bytes]","tags":"","url":"module/numdiff_kinds_module.html"},{"title":"dsm_module – NumDiff","text":"Jacobian partitioning using the DSM algorithm. Reference Argonne National Laboratory. MINPACK Project. July 1983.\n    Thomas F. Coleman, Burton S. Garbow, Jorge J. More Thomas F. Coleman, Burton S. Garbow, Jorge J. More, \"Algorithm 618:\n    FORTRAN subroutines for estimating sparse Jacobian Matrices\",\n    ACM Transactions on Mathematical Software (TOMS),\n    Volume 10 Issue 3, Sept. 1984, Pages 346-347 History Jacob Williams, Nov. 2016, extensive refactoring into modern Fortran. Uses numdiff_kinds_module module~~dsm_module~~UsesGraph module~dsm_module dsm_module module~numdiff_kinds_module numdiff_kinds_module module~dsm_module->module~numdiff_kinds_module iso_fortran_env iso_fortran_env module~numdiff_kinds_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~dsm_module~~UsedByGraph module~dsm_module dsm_module module~numerical_differentiation_module numerical_differentiation_module module~numerical_differentiation_module->module~dsm_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine dsm (m, n, npairs, indrow, indcol, ngrp, maxgrp, mingrp, info, ipntr, jpntr) The purpose of dsm is to determine an optimal or near-\noptimal consistent partition of the columns of a sparse m by n matrix a . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m number of rows of a (>0) integer, intent(in) :: n number of columns of a (>0) integer, intent(in) :: npairs number of ( indrow , indcol ) pairs used\nto describe the sparsity pattern of a (>0) integer, intent(inout), dimension(npairs) :: indrow an integer array of length npairs . on input indrow must contain the row indices of the non-zero elements of a .\non output indrow is permuted so that the corresponding\ncolumn indices are in non-decreasing order. the column\nindices can be recovered from the array jpntr . integer, intent(inout), dimension(npairs) :: indcol an integer array of length npairs . on input indcol must contain the column indices of the non-zero elements of a . on output indcol is permuted so that the corresponding\nrow indices are in non-decreasing order. the row indices\ncan be recovered from the array ipntr . integer, intent(out), dimension(n) :: ngrp specifies the partition of the columns of a .\ncolumn jcol belongs to group ngrp(jcol) . integer, intent(out) :: maxgrp the number of groups in the partition\nof the columns of a . integer, intent(out) :: mingrp a lower bound for the number of groups\nin any consistent partition of the\ncolumns of a . integer, intent(out) :: info for normal termination info = 1 .\nif m , n , or npairs is not positive,\nthen info = 0 . if the k-th element of indrow is not an integer between\n1 and m or the k-th element of indcol is not an integer between 1 and n,\nthen info = -k . integer, intent(out), dimension(m+1) :: ipntr an integer output array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 .\nnote that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(out), dimension(n+1) :: jpntr jpntr is an integer output array of length n + 1 which\nspecifies the locations of the row indices in indrow.\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 .\nnote that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . private  subroutine degr (n, indrow, jpntr, indcol, ipntr, ndeg, iwa) Given the sparsity pattern of an m by n matrix a ,\n  this subroutine determines the degree sequence for\n  the intersection graph of the columns of a . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, intent(in), dimension(*) :: indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, intent(in), dimension(n+1) :: jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(*) :: indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, intent(in), dimension(*) :: ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(out), dimension(n) :: ndeg an integer output array of length n which\nspecifies the degree sequence. the degree of the j -th column of a is ndeg(j) . integer, dimension(n) :: iwa an integer work array of length n private  subroutine ido (m, n, Indrow, Jpntr, Indcol, Ipntr, Ndeg, List, Maxclq, Iwa1, Iwa2, Iwa3, Iwa4) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines an incidence-degree ordering of the\ncolumns of a . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a . integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, intent(in), dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, intent(in), dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, intent(in), dimension(m+1) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(n) :: Ndeg an integer input array of length n which specifies\nthe degree sequence. the degree of the j -th column\nof a is ndeg(j) . integer, intent(out), dimension(n) :: List an integer output array of length n which specifies\nthe incidence-degree ordering of the columns of a . the j -th\ncolumn in this order is list(j) . integer, intent(out) :: Maxclq an integer output variable set to the size\nof the largest clique found during the ordering. integer, dimension(0:n-1) :: Iwa1 integer work array of length n . integer, dimension(n) :: Iwa2 integer work array of length n . integer, dimension(n) :: Iwa3 integer work array of length n . integer, dimension(n) :: Iwa4 integer work array of length n . private  subroutine numsrt (n, Nmax, Num, Mode, Index, Last, Next) Given a sequence of integers, this subroutine groups\n  together those indices with the same sequence value\n  and, optionally, sorts the sequence into either\n  ascending or descending order. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable. integer :: Nmax a positive integer input variable. integer, dimension(n) :: Num an input array of length n which contains the\nsequence of integers to be grouped and sorted. it\nis assumed that the integers are each from the set 0,1,...,nmax . integer :: Mode an integer input variable. the sequence num is\nsorted in ascending order if mode is positive and in\ndescending order if mode is negative. if mode is 0,\nno sorting is done. integer, dimension(n) :: Index an integer output array of length n set so\nthat the sequence num(index(i)), i = 1,2,...,n is sorted according to the setting of mode.\nif mode is 0, index is not referenced. integer, dimension(0:Nmax) :: Last an integer output array of length nmax + 1 . the\nindex of num for the last occurrence of l is last(l) for any l = 0,1,...,nmax unless last(l) = 0 . in\nthis case l does not appear in num . integer, dimension(n) :: Next an integer output array of length n . if num(k) = l , then the index of num for the previous\noccurrence of l is next(k) for any l = 0,1,...,nmax unless next(k) = 0 . in this case there is no previous\noccurrence of l in num . private  subroutine seq (n, Indrow, Jpntr, Indcol, Ipntr, List, Ngrp, Maxgrp, Iwa) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines a consistent partition of the\ncolumns of a by a sequential algorithm. Read more… Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(*) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(n) :: List an integer input array of length n which specifies\nthe order to be used by the sequential algorithm.\nthe j -th column in this order is list(j) . integer, dimension(n) :: Ngrp an integer output array of length n which specifies\nthe partition of the columns of a . column jcol belongs\nto group ngrp(jcol) . integer :: Maxgrp an integer output variable which specifies the\nnumber of groups in the partition of the columns of a . integer, dimension(n) :: Iwa an integer work array of length n private  subroutine setr (m, n, Indrow, Jpntr, Indcol, Ipntr, Iwa) given a column-oriented definition of the sparsity pattern\nof an m by n matrix a , this subroutine determines a\nrow-oriented definition of the sparsity pattern of a . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a . integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer output array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(m+1) :: Ipntr an integer output array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(1) is set to 1 and that ipntr(m+1)-1 is\nthen the number of non-zero elements of the matrix a . integer, dimension(m) :: Iwa an integer work array of length m . private  subroutine slo (n, Indrow, Jpntr, Indcol, Ipntr, Ndeg, List, Maxclq, Iwa1, Iwa2, Iwa3, Iwa4) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines the smallest-last ordering of the\ncolumns of a . Read more… Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(*) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(n) :: Ndeg an integer input array of length n which specifies\nthe degree sequence. the degree of the j -th column\nof a is ndeg(j) . integer, dimension(n) :: List an integer output array of length n which specifies\nthe smallest-last ordering of the columns of a . the j -th\ncolumn in this order is list(j) . integer :: Maxclq an integer output variable set to the size\nof the largest clique found during the ordering. integer, dimension(0:n-1) :: Iwa1 integer work array of length n integer, dimension(n) :: Iwa2 integer work array of length n integer, dimension(n) :: Iwa3 integer work array of length n integer, dimension(n) :: Iwa4 integer work array of length n private  subroutine srtdat (n, Nnz, Indrow, Indcol, Jpntr, Iwa) given the non-zero elements of an m by n matrix a in\narbitrary order as specified by their row and column\nindices, this subroutine permutes these elements so\nthat their column indices are in non-decreasing order. Read more… Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer :: Nnz a positive integer input variable set to the number\nof non-zero elements of a . integer, dimension(Nnz) :: Indrow an integer array of length nnz . on input indrow must contain the row indices of the non-zero elements of a .\non output indrow is permuted so that the corresponding\ncolumn indices of indcol are in non-decreasing order. integer, dimension(Nnz) :: Indcol an integer array of length nnz . on input indcol must contain the column indices of the non-zero elements\nof a . on output indcol is permuted so that these indices\nare in non-decreasing order. integer, dimension(n+1) :: Jpntr an integer output array of length n + 1 which\nspecifies the locations of the row indices in the output indrow . the row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(1) is set to 1 and that jpntr(n+1)-1 is then nnz . integer, dimension(n) :: Iwa an integer work array of length n . public  subroutine fdjs (m, n, Col, Ind, Npntr, Ngrp, Numgrp, d, Fjacd, Fjac) Given a consistent partition of the columns of an m by n jacobian matrix into groups, this subroutine computes\n  approximations to those columns in a given group.  the\n  approximations are stored into either a column-oriented\n  or a row-oriented pattern. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of the jacobian matrix. integer, intent(in) :: n a positive integer input variable set to the number\nof columns of the jacobian matrix. logical, intent(in) :: Col a logical input variable. if col is set true, then the\njacobian approximations are stored into a column-oriented\npattern. if col is set false, then the jacobian\napproximations are stored into a row-oriented pattern. integer, dimension(*) :: Ind an integer input array which contains the row\nindices for the non-zeroes in the jacobian matrix\nif col is true, and contains the column indices for\nthe non-zeroes in the jacobian matrix if col is false. integer, dimension(*) :: Npntr an integer input array which specifies the\nlocations of the row indices in ind if col is true, and\nspecifies the locations of the column indices in ind if col is false. if col is true, the indices for column j are ind(k), k = npntr(j),...,npntr(j+1)-1 .\nif col is false, the indices for row i are ind(k), k = npntr(i),...,npntr(i+1)-1 . Note that npntr(n+1)-1 if col is true, or npntr(m+1)-1 if col is false, is then the number of non-zero elements\nof the jacobian matrix. integer, dimension(n) :: Ngrp an integer input array of length n which specifies\nthe partition of the columns of the jacobian matrix.\ncolumn jcol belongs to group ngrp(jcol) . integer :: Numgrp a positive integer input variable set to a group\nnumber in the partition. the columns of the jacobian\nmatrix in this group are to be estimated on this call. real(kind=wp), dimension(n) :: d an input array of length n which contains the\ndifference parameter vector for the estimate of\nthe jacobian matrix columns in group numgrp . real(kind=wp), dimension(m) :: Fjacd an input array of length m which contains\nan approximation to the difference vector jac*d ,\nwhere jac denotes the jacobian matrix. real(kind=wp), dimension(*) :: Fjac an output array of length nnz , where nnz is the\nnumber of its non-zero elements. at each call of fdjs , fjac is updated to include the non-zero elements of the\njacobian matrix for those columns in group numgrp . fjac should not be altered between successive calls to fdjs .","tags":"","url":"module/dsm_module.html"},{"title":"cache_module.f90 – NumDiff","text":"This file depends on sourcefile~~cache_module.f90~~EfferentGraph sourcefile~cache_module.f90 cache_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~cache_module.f90->sourcefile~kinds_module.f90 sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~cache_module.f90->sourcefile~utilities_module.f90 sourcefile~utilities_module.f90->sourcefile~kinds_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~cache_module.f90~~AfferentGraph sourcefile~cache_module.f90 cache_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~cache_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams ! !  For caching function evaluations. module numdiff_cache_module use iso_fortran_env , only : ip => int64 ! same number of bits as real(wp) use numdiff_kinds_module use numdiff_utilities_module , only : unique implicit none private type :: fx !! an [x,f(x)] cached pair. private real ( wp ), dimension (:), allocatable :: x !! vector of input values real ( wp ), dimension (:), allocatable :: f !! vector of output functions `f(x)` !! note: only the elements indicated by `ifs` !! will have valid values. The others will !! be dummy values. integer , dimension (:), allocatable :: ifs !! elements of `f` present in the cache !! (this is just an array of the indices !! present in `f`) end type fx type , public :: function_cache !! a vector function cache. private integer :: n = 0 !! size of `x` integer :: m = 0 !! size of `f` type ( fx ), dimension (:), allocatable :: c !! the cache of `f(x)` integer :: chunk_size = 100 !! for resizing vectors !! in the [[unique]] function contains private procedure , public :: initialize => initialize_cache procedure , public :: get => get_from_cache procedure , public :: put => put_in_cache procedure , public :: destroy => destroy_cache procedure , public :: print => print_cache end type function_cache contains !******************************************************************************* !******************************************************************************* !> !  Initialize the cache. Must be called first before use. subroutine initialize_cache ( me , isize , n , m , chunk_size ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: isize !! the size of the hash table integer , intent ( in ) :: n !! number of independant variables (x) integer , intent ( in ) :: m !! number of functions (f) integer , intent ( in ), optional :: chunk_size !! chunk size to speed up reallocation !! of arrays. A good value is a guess for !! the actual number of elements of `f` that !! will be saved per value of `x` [default is 100] call me % destroy () allocate ( me % c ( 0 : isize - 1 )) me % n = n me % m = m if ( present ( chunk_size )) then me % chunk_size = chunk_size else me % chunk_size = 100 end if end subroutine initialize_cache !******************************************************************************* !******************************************************************************* !> !  Print the contents of the cache. Used for debugging. subroutine print_cache ( me , iunit ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit for writing !! (assumed to be opened) integer :: i !! counter write ( iunit , '(A)' ) '' write ( iunit , '(A)' ) '------------------------' if ( allocated ( me % c )) then do i = 1 , size ( me % c ) if ( allocated ( me % c ( i )% x )) then write ( iunit , '(A)' ) '' write ( iunit , '(A,1X,I10)' ) 'Entry ' , i write ( iunit , '(A,1X,*(F27.16,1X))' ) 'x  :' , me % c ( i )% x if ( allocated ( me % c ( i )% f )) then write ( iunit , '(A,1X,*(I27,1X))' ) 'ifs:' , me % c ( i )% ifs write ( iunit , '(A,1X,*(F27.16,1X))' ) 'f  :' , me % c ( i )% f ( me % c ( i )% ifs ) end if write ( iunit , '(A)' ) '------------------------' end if end do else write ( iunit , '(A)' ) 'Cache is not initialized' write ( iunit , '(A)' ) '------------------------' end if write ( iunit , '(A)' ) '' end subroutine print_cache !******************************************************************************* !******************************************************************************* !> !  Check if the `x` vector is in the cache, if so return `f`. !  Note that only some of the elements may be present, so it will return !  the ones there are there, and indicate which ones were found. subroutine get_from_cache ( me , x , ifs , i , f , xfound , ffound ) implicit none class ( function_cache ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! independant variable vector integer , dimension (:), intent ( in ) :: ifs !! elements of `f` needed integer , intent ( out ) :: i !! index in the hash table real ( wp ), dimension (:), intent ( out ) :: f !! `f(x)` from the cache (if it was found) logical , intent ( out ) :: xfound !! if `x` was found in the cache logical , dimension ( size ( ifs )), intent ( out ) :: ffound !! which `ifs` were found in the cache integer :: j !! counter ! initialize: xfound = . false . ffound = . false . if ( allocated ( me % c )) then ! get index in the hash table: i = mod ( abs ( vector_djb_hash ( x )), int ( size ( me % c ), ip ) ) ! check the table: if ( allocated ( me % c ( i )% x ) . and . allocated ( me % c ( i )% f )) then if ( size ( me % c ( i )% x ) == size ( x ) . and . & size ( me % c ( i )% f ) == size ( f )) then if ( all ( me % c ( i )% x == x )) then xfound = . true . ! return the elements that were found in the cache: f ( me % c ( i )% ifs ) = me % c ( i )% f ( me % c ( i )% ifs ) ! what indices are in the cache? do j = 1 , size ( ifs ) ffound ( j ) = any ( ifs ( j ) == me % c ( i )% ifs ) end do end if end if end if else error stop 'Error: the cache has not been initialized.' end if end subroutine get_from_cache !******************************************************************************* !******************************************************************************* !> !  Put a value into the cache. subroutine put_in_cache ( me , i , x , f , ifs ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: i !! index in the hash table real ( wp ), dimension (:), intent ( in ) :: x !! independant variable vector (dimension `n`) real ( wp ), dimension (:), intent ( in ) :: f !! function vector `f(x)` (dimension `m`) integer , dimension (:), intent ( in ) :: ifs !! elements of `f` to add (should all be `>0, <=m`) real ( wp ), parameter :: null = huge ( 1.0_wp ) !! an unusual value to initialize arrays if ( allocated ( me % c )) then if ( i <= size ( me % c )) then if ( allocated ( me % c ( i )% x )) then ! we need to check if there is an x already there, ! which may already have some function indices present. ! if same x, then add the new indices to them. ! if a different x, then replace indices. if ( all ( me % c ( i )% x == x )) then ! this x is already present in this location. ! so merge the new f,ifs into what is already there. if ( allocated ( me % c ( i )% f )) then me % c ( i )% ifs = unique ([ me % c ( i )% ifs , ifs ],& chunk_size = me % chunk_size ) else allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% ifs = ifs end if me % c ( i )% f ( ifs ) = f ( ifs ) else ! replace existing x and f. me % c ( i )% x = x me % c ( i )% ifs = ifs if ( allocated ( me % c ( i )% f )) deallocate ( me % c ( i )% f ) allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% f ( ifs ) = f ( ifs ) end if else ! new entry in the cache: me % c ( i )% x = x allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% ifs = ifs me % c ( i )% f ( ifs ) = f ( ifs ) end if else error stop 'Error: invalid index in hash table.' end if else error stop 'Error: the cache has not been initialized.' end if end subroutine put_in_cache !******************************************************************************* !******************************************************************************* !> !  Destroy a cache. subroutine destroy_cache ( me ) implicit none class ( function_cache ), intent ( out ) :: me end subroutine destroy_cache !******************************************************************************* !******************************************************************************* !> !  DJB hash algorithm for a `real(wp)` vector. ! !### See also !  * J. Shahbazian, Fortran hashing algorithm, July 6, 2013 !   [Fortran Dev](https://fortrandev.wordpress.com/2013/07/06/fortran-hashing-algorithm/) pure function vector_djb_hash ( r ) result ( hash ) real ( wp ), dimension (:), intent ( in ) :: r !! the vector integer ( ip ) :: hash !! the hash value integer :: i !! counter hash = 5381_ip do i = 1 , size ( r ) hash = ishft ( hash , 5_ip ) + hash + transfer ( r ( i ), 1_ip ) end do end function vector_djb_hash !******************************************************************************* !******************************************************************************* end module numdiff_cache_module !*******************************************************************************","tags":"","url":"sourcefile/cache_module.f90.html"},{"title":"diff_module.f90 – NumDiff","text":"This file depends on sourcefile~~diff_module.f90~~EfferentGraph sourcefile~diff_module.f90 diff_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~diff_module.f90->sourcefile~kinds_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~diff_module.f90~~AfferentGraph sourcefile~diff_module.f90 diff_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~diff_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  Numerical differentiation of a 1D function `f(x)` using Neville's process. ! !## Authors !   * J. Oliver, \"An algorithm for numerical differentiation of a function !     of one real variable\", Journal of Computational and Applied Mathematics !     6 (2) (1980) 145–160. [Algol 60 source in original paper] !   * David Kahaner, Fortran 77 code from !     [NIST](ftp://math.nist.gov/pub/repository/diff/src/DIFF) !   * Jacob Williams : 2/17/2013 : Converted to modern Fortran. !     Some refactoring, addition of test cases. module diff_module use numdiff_kinds_module implicit none private type , public :: diff_func !! class to define the function for [[diff]] private logical :: stop = . false . procedure ( func ), pointer :: f => null () contains private procedure :: faccur procedure , public :: set_function procedure , public :: compute_derivative => diff procedure , public :: terminate end type diff_func abstract interface function func ( me , x ) result ( fx ) !! interface to function for [[diff]] import :: diff_func , wp implicit none class ( diff_func ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ) :: fx end function func end interface contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date:  12/27/2015 ! !  Set the function in a [[diff_func]]. !  Must be called before [[diff]]. subroutine set_function ( me , f ) implicit none class ( diff_func ), intent ( inout ) :: me procedure ( func ) :: f me % f => f end subroutine set_function !***************************************************************************************** !***************************************************************************************** !> !  Can be called by the user in the function to terminate the computation. !  This will set `ifail=-1`. subroutine terminate ( me ) implicit none class ( diff_func ), intent ( inout ) :: me me % stop = . true . end subroutine terminate !***************************************************************************************** !***************************************************************************************** !> !  the procedure `diff` calculates the first, second or !  third order derivative of a function by using neville's process to !  extrapolate from a sequence of simple polynomial approximations based on !  interpolating points distributed symmetrically about `x0` (or lying only on !  one side of `x0` should this be necessary).  if the specified tolerance is !  non-zero then the procedure attempts to satisfy this absolute or relative !  accuracy requirement, while if it is unsuccessful or if the tolerance is !  set to zero then the result having the minimum achievable estimated error !  is returned instead. subroutine diff ( me , iord , x0 , xmin , xmax , eps , accr , deriv , error , ifail ) implicit none class ( diff_func ), intent ( inout ) :: me integer , intent ( in ) :: iord !! 1, 2 or 3 specifies that the first, second or third order !! derivative,respectively, is required. real ( wp ), intent ( in ) :: x0 !! the point at which the derivative of the function is to be calculated. real ( wp ), intent ( in ) :: xmin !! `xmin`, `xmax` restrict the interpolating points to lie in [`xmin`, `xmax`], which !! should be the largest interval including `x0` in which the function is !! calculable and continuous. real ( wp ), intent ( in ) :: xmax !! `xmin`, `xmax` restrict the interpolating points to lie in [`xmin`, `xmax`], which !! should be the largest interval including `x0` in which the function is !! calculable and continuous. real ( wp ), intent ( in ) :: eps !! denotes the tolerance, either absolute or relative. `eps=0` specifies that !! the error is to be minimised, while `eps>0` or `eps<0` specifies that the !! absolute or relative error, respectively, must not exceed `abs(eps)` if !! possible.  the accuracy requirement should not be made stricter than !! necessary, since the amount of computation tends to increase as !! the magnitude of `eps` decreases, and is particularly high when `eps=0`. real ( wp ), intent ( in ) :: accr !! denotes that the absolute (`accr>0`) or relative (`accr<0`) errors in the !! computed values of the function are most unlikely to exceed `abs(accr)`, which !! should be as small as possible.  if the user cannot estimate `accr` with !! complete confidence, then it should be set to zero. real ( wp ), intent ( out ) :: deriv !! the calculated value of the derivative real ( wp ), intent ( out ) :: error !! an estimated upper bound on the magnitude of the absolute error in !! the calculated result.  it should always be examined, since in extreme case !! may indicate that there are no correct significant digits in the value !! returned for derivative. integer , intent ( out ) :: ifail !! will have one of the following values on exit: !!  *0* the procedure was successful. !!  *1* the estimated error in the result exceeds the (non-zero) requested !!      error, but the most accurate result possible has been returned. !!  *2* input data incorrect (derivative and error will be undefined). !!  *3* the interval [`xmin`, `xmax`] is too small (derivative and error will be !!      undefined). !!  *-1* stopped by the user. real ( wp ) :: acc , beta , beta4 , h , h0 , h1 , h2 , & newh1 , newh2 , heval , hprev , baseh , hacc1 , hacc2 , nhacc1 , & nhacc2 , minh , maxh , maxh1 , maxh2 , tderiv , f0 , twof0 , f1 , f2 , f3 , f4 , fmax , & maxfun , pmaxf , df1 , deltaf , pdelta , z , zpower , c0f0 , c1 , c2 , c3 , dnew , dprev , & re , te , newerr , temerr , newacc , pacc1 , pacc2 , facc1 , facc2 , acc0 , & acc1 , acc2 , relacc , twoinf , twosup , s , & d ( 10 ), denom ( 10 ), e ( 10 ), minerr ( 10 ), maxf ( 0 : 10 ), save ( 0 : 13 ), storef ( - 45 : 45 ), factor integer :: i , j , k , n , nmax , method , signh , fcount , init logical :: ignore ( 10 ), contin , saved real ( wp ) :: dummy1 , dummy2 integer , parameter :: eta = digits ( 1.0_wp ) - 1 !! minimum number of significant binary digits (apart from the !! sign digit) used to represent the mantissa of real(wp) numbers. it should !! be decreased by one if the computer truncates rather than rounds. integer , parameter :: inf = - minexponent ( 1.0_wp ) - 2 !! the largest possible positive integers subject to !! 2**(-inf) and -2**(-inf) being representable real(wp) numbers. integer , parameter :: sup = maxexponent ( 1.0_wp ) - 1 !! the largest possible positive integers subject to !! 2**sup and -2**sup being representable real(wp) numbers. real ( wp ), parameter :: sqrt2 = sqrt ( 2.0_wp ) !!  \\sqrt(2)  real ( wp ), parameter :: sqrt3 = sqrt ( 3.0_wp ) !!  \\sqrt(3)  me % stop = . false . ! execution commences with examination of input parameters if ( iord < 1 . or . iord > 3 . or . xmax <= xmin . or . & x0 > xmax . or . x0 < xmin . or . . not . associated ( me % f )) then ifail = 2 else acc = accr twoinf = 2.0_wp ** ( - inf ) twosup = 2.0_wp ** sup factor = 2.0_wp ** ( real (( inf + sup ), wp ) / 3 0.0_wp ) if ( factor < 25 6.0_wp ) factor = 25 6.0_wp maxh1 = xmax - x0 signh = 1 if ( x0 - xmin <= maxh1 ) then maxh2 = x0 - xmin else maxh2 = maxh1 maxh1 = x0 - xmin signh = - 1 end if relacc = 2.0_wp ** ( 1.0_wp - eta ) maxh1 = ( 1.0_wp - relacc ) * maxh1 maxh2 = ( 1.0_wp - relacc ) * maxh2 s = 12 8.0_wp * twoinf if ( abs ( x0 ) > 12 8.0_wp * twoinf * 2.0_wp ** eta ) s = abs ( x0 ) * 2.0_wp ** ( - eta ) if ( maxh1 < s ) then ! interval too small ifail = 3 return end if if ( acc < 0.0_wp ) then if ( - acc > relacc ) relacc = - acc acc = 0.0_wp end if ! determine the smallest spacing at which the calculated ! function values are unequal near x0. f0 = me % f ( x0 ) if ( me % stop ) then ifail = - 1 return end if twof0 = f0 + f0 if ( abs ( x0 ) > twoinf * 2.0_wp ** eta ) then h = abs ( x0 ) * 2.0_wp ** ( - eta ) z = 2.0_wp else h = twoinf z = 6 4.0_wp end if df1 = me % f ( x0 + signh * h ) - f0 if ( me % stop ) then ifail = - 1 return end if do if ( df1 /= 0.0_wp . or . z * h > maxh1 ) exit h = z * h df1 = me % f ( x0 + signh * h ) - f0 if ( me % stop ) then ifail = - 1 return end if if ( z /= 2.0_wp ) then if ( df1 /= 0.0_wp ) then h = h / z z = 2.0_wp df1 = 0.0_wp else if ( z * h > maxh1 ) z = 2.0_wp end if end if end do if ( df1 == 0.0_wp ) then ! constant function deriv = 0.0_wp error = 0.0_wp ifail = 0 return end if if ( h > maxh1 / 12 8.0_wp ) then ! minimum h too large ifail = 3 return end if h = 8.0_wp * h h1 = signh * h h0 = h1 h2 = - h1 minh = 2.0_wp ** ( - min ( inf , sup ) / iord ) if ( minh < h ) minh = h select case ( iord ) case ( 1 ) s = 8.0_wp case ( 2 ) s = 9.0_wp * sqrt3 case ( 3 ) s = 2 7.0_wp end select if ( minh > maxh1 / s ) then ifail = 3 return end if if ( minh > maxh2 / s . or . maxh2 < 12 8.0_wp * twoinf ) then method = 1 else method = 2 end if ! method 1 uses 1-sided formulae, and method 2 symmetric. ! now estimate accuracy of calculated function values. if ( method /= 2 . or . iord == 2 ) then if ( x0 /= 0.0_wp ) then dummy1 = 0.0_wp dummy2 = - h1 call me % faccur ( dummy1 , dummy2 , acc0 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return else acc0 = 0.0_wp end if end if if ( abs ( h1 ) > twosup / 12 8.0_wp ) then hacc1 = twosup else hacc1 = 12 8.0_wp * h1 end if if ( abs ( hacc1 ) / 4.0_wp < minh ) then hacc1 = 4.0_wp * signh * minh else if ( abs ( hacc1 ) > maxh1 ) then hacc1 = signh * maxh1 end if f1 = me % f ( x0 + hacc1 ) if ( me % stop ) then ifail = - 1 return end if call me % faccur ( hacc1 , h1 , acc1 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( method == 2 ) then hacc2 = - hacc1 if ( abs ( hacc2 ) > maxh2 ) hacc2 = - signh * maxh2 f1 = me % f ( x0 + hacc2 ) if ( me % stop ) then ifail = - 1 return end if call me % faccur ( hacc2 , h2 , acc2 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return end if nmax = 8 if ( eta > 36 ) nmax = 10 n = - 1 fcount = 0 deriv = 0.0_wp error = twosup init = 3 contin = . true . do n = n + 1 if (. not . contin ) exit if ( init == 3 ) then ! calculate coefficients for differentiation ! formulae and neville extrapolation algorithm if ( iord == 1 ) then beta = 2.0_wp else if ( method == 2 ) then beta = sqrt2 else beta = sqrt3 end if beta4 = beta ** 4 z = beta if ( method == 2 ) z = z ** 2 zpower = 1.0_wp do k = 1 , nmax zpower = z * zpower denom ( k ) = zpower - 1 end do if ( method == 2 . and . iord == 1 ) then e ( 1 ) = 5.0_wp e ( 2 ) = 6.3_wp do i = 3 , nmax e ( i ) = 6.81_wp end do else if (( method /= 2 . and . iord == 1 ) . or . & ( method == 2 . and . iord == 2 )) then e ( 1 ) = 1 0.0_wp e ( 2 ) = 1 6.0_wp e ( 3 ) = 2 0.36_wp e ( 4 ) = 2 3.0_wp e ( 5 ) = 2 4.46_wp do i = 6 , nmax e ( i ) = 2 6.0_wp end do if ( method == 2 . and . iord == 2 ) then do i = 1 , nmax e ( i ) = 2.0_wp * e ( i ) end do end if else if ( method /= 2 . and . iord == 2 ) then e ( 1 ) = 1 7.78_wp e ( 2 ) = 3 0.06_wp e ( 3 ) = 3 9.66_wp e ( 4 ) = 4 6.16_wp e ( 5 ) = 5 0.26_wp do i = 6 , nmax e ( i ) = 5 5.0_wp end do else if ( method == 2 . and . iord == 3 ) then e ( 1 ) = 2 5.97_wp e ( 2 ) = 4 1.22_wp e ( 3 ) = 5 0.95_wp e ( 4 ) = 5 6.4_wp e ( 5 ) = 5 9.3_wp do i = 6 , nmax e ( i ) = 6 2.0_wp end do else e ( 1 ) = 2 4.5_wp e ( 2 ) = 4 0.4_wp e ( 3 ) = 5 2.78_wp e ( 4 ) = 6 1.2_wp e ( 5 ) = 6 6.55_wp do i = 6 , nmax e ( i ) = 7 3.0_wp end do c0f0 = - twof0 / ( 3.0_wp * beta ) c1 = 3.0_wp / ( 3.0_wp * beta - 1.0_wp ) c2 = - 1.0_wp / ( 3.0_wp * ( beta - 1.0_wp )) c3 = 1.0_wp / ( 3.0_wp * beta * ( 5.0_wp - 2.0_wp * beta )) end if end if if ( init >= 2 ) then ! initialization of steplengths, accuracy and other parameters heval = signh * minh h = heval baseh = heval maxh = maxh2 if ( method == 1 ) maxh = maxh1 do k = 1 , nmax minerr ( k ) = twosup ignore ( k ) = . false . end do if ( method == 1 ) newacc = acc1 if ( method == - 1 ) newacc = acc2 if ( method == 2 ) newacc = ( acc1 + acc2 ) / 2.0_wp if ( newacc < acc ) newacc = acc if (( method /= 2 . or . iord == 2 ) . and . newacc < acc0 ) newacc = acc0 if ( method /= - 1 ) then facc1 = acc1 nhacc1 = hacc1 newh1 = h1 end if if ( method /= 1 ) then facc2 = acc2 nhacc2 = hacc2 newh2 = h2 else facc2 = 0.0_wp nhacc2 = 0.0_wp end if init = 1 j = 0 saved = . false . end if ! calculate new or initial function values if ( init == 1 . and . ( n == 0 . or . iord == 1 ) . and . & . not .( method == 2 . and . fcount >= 45 )) then if ( method == 2 ) then fcount = fcount + 1 f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if storef ( fcount ) = f1 f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if storef ( - fcount ) = f2 else j = j + 1 if ( j <= fcount ) then f1 = storef ( j * method ) else f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if end if else f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if if ( method == 2 ) then f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if end if end if if ( n == 0 ) then if ( method == 2 . and . iord == 3 ) then pdelta = f1 - f2 pmaxf = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if deltaf = f1 - f2 maxfun = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if else if ( method /= 2 . and . iord >= 2 ) then if ( iord == 2 ) then f3 = f1 else f4 = f1 heval = beta * heval f3 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if heval = beta * heval f2 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if end if ! evaluate a new approximation dnew to the derivative if ( n > nmax ) then n = nmax do i = 1 , n maxf ( i - 1 ) = maxf ( i ) end do end if if ( method == 2 ) then maxf ( n ) = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp if ( iord == 1 ) then dnew = ( f1 - f2 ) / 2.0_wp else if ( iord == 2 ) then dnew = f1 + f2 - twof0 else dnew = - pdelta pdelta = deltaf deltaf = f1 - f2 dnew = dnew + 0.5_wp * deltaf if ( maxf ( n ) < pmaxf ) maxf ( n ) = pmaxf pmaxf = maxfun maxfun = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp end if else maxf ( n ) = abs ( f1 ) if ( iord == 1 ) then dnew = f1 - f0 else if ( iord == 2 ) then dnew = ( twof0 - 3.0_wp * f3 + f1 ) / 3.0_wp if ( maxf ( n ) < abs ( f3 )) maxf ( n ) = abs ( f3 ) f3 = f2 f2 = f1 else dnew = c3 * f1 + c2 * f2 + c1 * f4 + c0f0 if ( maxf ( n ) < abs ( f2 )) maxf ( n ) = abs ( f2 ) if ( maxf ( n ) < abs ( f4 )) maxf ( n ) = abs ( f4 ) f4 = f3 f3 = f2 f2 = f1 end if end if if ( abs ( h ) > 1 ) then dnew = dnew / h ** iord else if ( 12 8.0_wp * abs ( dnew ) > twosup * abs ( h ) ** iord ) then dnew = twosup / 12 8.0_wp else dnew = dnew / h ** iord end if end if if ( init == 0 ) then ! update estimated accuracy of function values newacc = acc if (( method /= 2 . or . iord == 2 ) . and . newacc < acc0 ) newacc = acc0 if ( method /= - 1 . and . abs ( nhacc1 ) <= 1.125_wp * abs ( heval ) / beta4 ) then nhacc1 = heval pacc1 = facc1 call me % faccur ( nhacc1 , newh1 , facc1 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( facc1 < pacc1 ) facc1 = ( 3.0_wp * facc1 + pacc1 ) / 4.0_wp end if if ( method /= 1 . and . abs ( nhacc2 ) <= 1.125_wp * abs ( heval ) / beta4 ) then if ( method == 2 ) then f1 = f2 nhacc2 = - heval else nhacc2 = heval end if pacc2 = facc2 call me % faccur ( nhacc2 , newh2 , facc2 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( facc2 < pacc2 ) facc2 = ( 3.0_wp * facc2 + pacc2 ) / 4.0_wp end if if ( method == 1 . and . newacc < facc1 ) newacc = facc1 if ( method == - 1 . and . newacc < facc2 ) newacc = facc2 if ( method == 2 . and . newacc < ( facc1 + facc2 ) / 2.0_wp ) & newacc = ( facc1 + facc2 ) / 2.0_wp end if ! evaluate successive elements of the current row in the neville ! array, estimating and examining the truncation and rounding ! errors in each contin = n < nmax hprev = abs ( h ) fmax = maxf ( n ) if (( method /= 2 . or . iord == 2 ) . and . fmax < abs ( f0 )) fmax = abs ( f0 ) do k = 1 , n dprev = d ( k ) d ( k ) = dnew dnew = dprev + ( dprev - dnew ) / denom ( k ) te = abs ( dnew - d ( k )) if ( fmax < maxf ( n - k )) fmax = maxf ( n - k ) hprev = hprev / beta if ( newacc >= relacc * fmax ) then re = newacc * e ( k ) else re = relacc * fmax * e ( k ) end if if ( re /= 0.0_wp ) then if ( hprev > 1 ) then re = re / hprev ** iord else if ( 2.0_wp * re > twosup * hprev ** iord ) then re = twosup / 2.0_wp else re = re / hprev ** iord end if end if newerr = te + re if ( te > re ) newerr = 1.25_wp * newerr if (. not . ignore ( k )) then if (( init == 0 . or . ( k == 2 . and . . not . ignore ( 1 ))) & . and . newerr < error ) then deriv = d ( k ) error = newerr end if if ( init == 1 . and . n == 1 ) then tderiv = d ( 1 ) temerr = newerr end if if ( minerr ( k ) < twosup / 4.0_wp ) then s = 4.0_wp * minerr ( k ) else s = twosup end if if ( te > re . or . newerr > s ) then ignore ( k ) = . true . else contin = . true . end if if ( newerr < minerr ( k )) minerr ( k ) = newerr if ( init == 1 . and . n == 2 . and . k == 1 . and . . not . ignore ( 1 )) then if ( newerr < temerr ) then tderiv = d ( 1 ) temerr = newerr end if if ( temerr < error ) then deriv = tderiv error = temerr end if end if end if end do if ( n < nmax ) d ( n + 1 ) = dnew if ( eps < 0.0_wp ) then s = abs ( eps * deriv ) else s = eps end if if ( error <= s ) then contin = . false . else if ( init == 1 . and . ( n == 2 . or . ignore ( 1 ))) then if (( ignore ( 1 ) . or . ignore ( 2 )) . and . saved ) then saved = . false . n = 2 h = beta * save ( 0 ) heval = beta * save ( 1 ) maxf ( 0 ) = save ( 2 ) maxf ( 1 ) = save ( 3 ) maxf ( 2 ) = save ( 4 ) d ( 1 ) = save ( 5 ) d ( 2 ) = save ( 6 ) d ( 3 ) = save ( 7 ) minerr ( 1 ) = save ( 8 ) minerr ( 2 ) = save ( 9 ) if ( method == 2 . and . iord == 3 ) then pdelta = save ( 10 ) deltaf = save ( 11 ) pmaxf = save ( 12 ) maxfun = save ( 13 ) else if ( method /= 2 . and . iord >= 2 ) then f2 = save ( 10 ) f3 = save ( 11 ) if ( iord == 3 ) f4 = save ( 12 ) end if init = 0 ignore ( 1 ) = . false . ignore ( 2 ) = . false . else if (. not . ( ignore ( 1 ) . or . ignore ( 2 )) . and . n == 2 & . and . beta4 * factor * abs ( heval ) <= maxh ) then ! save all current values in case of return to current point saved = . true . save ( 0 ) = h save ( 1 ) = heval save ( 2 ) = maxf ( 0 ) save ( 3 ) = maxf ( 1 ) save ( 4 ) = maxf ( 2 ) save ( 5 ) = d ( 1 ) save ( 6 ) = d ( 2 ) save ( 7 ) = d ( 3 ) save ( 8 ) = minerr ( 1 ) save ( 9 ) = minerr ( 2 ) if ( method == 2 . and . iord == 3 ) then save ( 10 ) = pdelta save ( 11 ) = deltaf save ( 12 ) = pmaxf save ( 13 ) = maxfun else if ( method /= 2 . and . iord >= 2 ) then save ( 10 ) = f2 save ( 11 ) = f3 if ( iord == 3 ) save ( 12 ) = f4 end if h = factor * baseh heval = h baseh = h n = - 1 else init = 0 h = beta * h heval = beta * heval end if else if ( contin . and . beta * abs ( heval ) <= maxh ) then h = beta * h heval = beta * heval else if ( method /= 1 ) then contin = . true . if ( method == 2 ) then init = 3 method = - 1 if ( iord /= 2 ) then if ( x0 /= 0.0_wp ) then dummy1 = 0.0_wp dummy2 = - h0 call me % faccur ( dummy1 , dummy2 , acc0 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return else acc0 = 0.0_wp end if end if else init = 2 method = 1 end if n = - 1 signh = - signh else contin = . false . end if end do if ( eps < 0.0_wp ) then s = abs ( eps * deriv ) else s = eps end if ifail = 0 if ( eps /= 0.0_wp . and . error > s ) ifail = 1 end if end subroutine diff !***************************************************************************************** !***************************************************************************************** !> ! This procedure attempts to estimate the level of rounding errors in ! the calculated function values near the point `x0+h0` by fitting a ! least-squares straight-line approximation to the function at the ! six points `x0+h0-j*h1`, (`j = 0,1,3,5,7,9`), and then setting `facc` to ! twice the largest deviation of the function values from this line. ! `hi` is adjusted if necessary so that it is approximately 8 times the ! smallest spacing at which the function values are unequal near `x0+h0`. subroutine faccur ( me , h0 , h1 , facc , x0 , twoinf , f0 , f1 , ifail ) implicit none class ( diff_func ), intent ( inout ) :: me real ( wp ), intent ( inout ) :: h0 real ( wp ), intent ( inout ) :: h1 real ( wp ), intent ( out ) :: facc real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: twoinf real ( wp ), intent ( in ) :: f0 real ( wp ), intent ( in ) :: f1 integer , intent ( out ) :: ifail !! 0 if no error, -1 if user termination. real ( wp ) :: a0 , a1 , f00 , f001 , f2 , deltaf , t0 , t1 , df ( 5 ) integer :: j ifail = 0 t0 = 0.0_wp t1 = 0.0_wp if ( h0 /= 0.0_wp ) then if ( x0 + h0 /= 0.0_wp ) then f00 = f1 else h0 = 0.875_wp * h0 f00 = me % f ( x0 + h0 ) if ( me % stop ) then ifail = - 1 return end if end if if ( abs ( h1 ) >= 3 2.0_wp * twoinf ) h1 = h1 / 8.0_wp if ( 1 6.0_wp * abs ( h1 ) > abs ( h0 )) h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp f001 = me % f ( x0 + h0 - h1 ) if ( me % stop ) then ifail = - 1 return end if if ( f001 == f00 ) then if ( 25 6.0_wp * abs ( h1 ) <= abs ( h0 )) then h1 = 2.0_wp * h1 do f001 = me % f ( x0 + h0 - h1 ) if ( me % stop ) then ifail = - 1 return end if if ( f001 /= f00 . or . 25 6.0_wp * abs ( h1 ) > abs ( h0 )) exit h1 = 2.0_wp * h1 end do h1 = 8.0_wp * h1 else h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp end if else if ( 25 6.0_wp * twoinf <= abs ( h0 )) then do f001 = me % f ( x0 + h0 - h1 / 2.0_wp ) if ( me % stop ) then ifail = - 1 return end if if ( f001 == f00 . or . abs ( h1 ) < 4.0_wp * twoinf ) exit h1 = h1 / 2.0_wp end do h1 = 8.0_wp * h1 if ( 1 6.0_wp * abs ( h1 ) > abs ( h0 )) h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp else h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp end if end if else f00 = f0 end if do j = 1 , 5 f2 = me % f ( x0 + h0 - real ( 2 * j - 1 , wp ) * h1 ) if ( me % stop ) then ifail = - 1 return end if df ( j ) = f2 - f00 t0 = t0 + df ( j ) t1 = t1 + real ( 2 * j - 1 , wp ) * df ( j ) end do a0 = ( 3 3.0_wp * t0 - 5.0_wp * t1 ) / 7 3.0_wp a1 = ( - 5.0_wp * t0 + 1.2_wp * t1 ) / 7 3.0_wp facc = abs ( a0 ) do j = 1 , 5 deltaf = abs ( df ( j ) - ( a0 + real ( 2 * j - 1 , wp ) * a1 )) if ( facc < deltaf ) facc = deltaf end do facc = 2.0_wp * facc end subroutine faccur !***************************************************************************************** !***************************************************************************************** end module diff_module !*****************************************************************************************","tags":"","url":"sourcefile/diff_module.f90.html"},{"title":"numerical_differentiation_module.f90 – NumDiff","text":"This file depends on sourcefile~~numerical_differentiation_module.f90~~EfferentGraph sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~cache_module.f90 cache_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~cache_module.f90 sourcefile~diff_module.f90 diff_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~diff_module.f90 sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~dsm_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~numerical_differentiation_module.f90->sourcefile~kinds_module.f90 sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~utilities_module.f90 sourcefile~cache_module.f90->sourcefile~kinds_module.f90 sourcefile~cache_module.f90->sourcefile~utilities_module.f90 sourcefile~diff_module.f90->sourcefile~kinds_module.f90 sourcefile~dsm_module.f90->sourcefile~kinds_module.f90 sourcefile~utilities_module.f90->sourcefile~kinds_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams !  date: October 29, 2016 ! !  Numerical differentiation module for computing the Jacobian matrix !  (the derivative matrix of `m` functions w.r.t. `n` variables) using !  finite differences. module numerical_differentiation_module use numdiff_kinds_module use numdiff_utilities_module use iso_fortran_env , only : error_unit use dsm_module , only : dsm use diff_module , only : diff_func use numdiff_cache_module , only : function_cache implicit none private real ( wp ), parameter :: zero = 0.0_wp type , public :: finite_diff_method !! defines the finite difference method !! used to compute the Jacobian. !! !! See: [[get_finite_difference_method]] !! for the different methods. private integer :: id = 0 !! unique ID for the method character ( len = :), allocatable :: name !! the name of the method integer :: class = 0 !! 2=backward diffs, 3=central diffs, etc... real ( wp ), dimension (:), allocatable :: dx_factors !! multiplicative factors for `dx` perturbation real ( wp ), dimension (:), allocatable :: df_factors !! multiplicative factors for accumulating function evaluations real ( wp ) :: df_den_factor = zero !! denominator factor for finite difference equation (times `dx`) contains private procedure , public :: get_formula procedure , public :: print => print_finite_difference_method end type finite_diff_method interface finite_diff_method !! constructor module procedure initialize_finite_difference_method end interface type , public :: meth_array !! to store an array of [[finite_diff_method]] types !! this is used when the `mode=2` option is used !! in [[numdiff_type]] private type ( finite_diff_method ), dimension (:), allocatable :: meth end type meth_array type , public :: sparsity_pattern !! A sparsity pattern private logical :: sparsity_computed = . false . !! has the sparsity pattern already been computed? integer :: num_nonzero_elements = 0 !! number of nonzero elements in the jacobian !! (will be the dimension of `irow` and `icol`) integer , dimension (:), allocatable :: irow !! sparsity pattern - rows of non-zero elements integer , dimension (:), allocatable :: icol !! sparsity pattern - columns of non-zero elements logical :: linear_sparsity_computed = . false . !! if the linear pattern has been populated integer :: num_nonzero_linear_elements = 0 !! number of constant elements in the jacobian integer , dimension (:), allocatable :: linear_irow !! linear sparsity pattern - rows of non-zero elements integer , dimension (:), allocatable :: linear_icol !! linear sparsity pattern - columns of non-zero elements real ( wp ), dimension (:), allocatable :: linear_vals !! linear elements of the jacobian integer , dimension (:), allocatable :: indices !! index vector !! `[1,2,...,num_nonzero_elements]` !! for putting `df` into `jac` integer :: maxgrp = 0 !! the number of groups in the partition !! of the columns of `a`. integer , dimension (:), allocatable :: ngrp !! specifies the partition of the columns of `a`. !! column `jcol` belongs to group `ngrp(jcol)`. !! `size(n)` contains private procedure :: dsm_wrapper procedure :: compute_indices procedure , public :: destroy => destroy_sparsity procedure , public :: print => print_sparsity procedure , public :: columns_in_partition_group end type sparsity_pattern type , public :: numdiff_type !! base type for sparsity and Jacobian computations. private logical :: exception_raised = . false . !! if true, an exception has been raised integer :: istat = 0 !! a non-zero value will cause all routine to exit. !! this can be set to `-1` by calling [[terminate]]. character ( len = :), allocatable :: error_msg !! error message (if `istat/=0`) integer :: n = 0 !! number of `x` variables integer :: m = 0 !! number of `f` functions real ( wp ), dimension (:), allocatable :: xlow !! lower bounds on `x` real ( wp ), dimension (:), allocatable :: xhigh !! upper bounds on `x` logical :: print_messages = . true . !! if true, warning messages are printed !! to the `error_unit` for any errors. integer :: chunk_size = 100 !! chuck size for allocating the arrays (>0) integer :: perturb_mode = 1 !! perturbation mode: !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), dimension (:), allocatable :: dpert !! perturbation vector for `x` logical :: partition_sparsity_pattern = . false . !! to partition the sparsity pattern using [[dsm]] type ( sparsity_pattern ) :: sparsity !! the sparsity pattern real ( wp ), dimension (:), allocatable :: xlow_for_sparsity !! lower bounds on `x` for computing sparsity (optional) real ( wp ), dimension (:), allocatable :: xhigh_for_sparsity !! upper bounds on `x` for computing sparsity (optional) real ( wp ), dimension (:), allocatable :: dpert_for_sparsity !! perturbation vector for `x` when computing !! sparsity for `sparsity_mode=4` integer :: num_sparsity_points = 3 !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. !! See [[compute_sparsity_random_2]] integer :: sparsity_perturb_mode = 1 !! perturbation mode (if `sparsity_mode=4`): !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` ! if computing the sparsity pattern, we also have an option to ! compute the linear pattern, which indicates constant elements ! of the jacobian. these elements don't need to be computed again. logical :: compute_linear_sparsity_pattern = . false . !! to also compute the linear sparsity pattern real ( wp ) :: linear_sparsity_tol = epsilon ( 1.0_wp ) !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ) :: function_precision_tol = epsilon ( 1.0_wp ) !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] integer :: mode = 1 !! **1** = use `meth` (specified methods), !! **2** = use `class` (specified class, method is selected on-the-fly). type ( finite_diff_method ), dimension (:), allocatable :: meth !! the finite difference method to use !! compute the `n`th column of the Jacobian !! `size(n)`.  Either this or `class` is used integer , dimension (:), allocatable :: class !! the class of method to use to !! compute the `n`th column of the Jacobian !! `size(n)`. Either this or `meth` is used type ( meth_array ), dimension (:), allocatable :: class_meths !! array of methods for the specified classes. !! used with `class` when `mode=2` ! parameters when using diff: real ( wp ) :: eps = 1.0e-9_wp !! tolerance parameter for [[diff]] real ( wp ) :: acc = 0.0_wp !! tolerance parameter for [[diff]] type ( function_cache ) :: cache !! if using the function cache logical :: use_diff = . false . !! if we are using the Neville's process method, !! rather than finite differences procedure ( func ), pointer :: problem_func => null () !! the user-defined function ! these are required to be defined by the user: procedure ( func ), pointer :: compute_function => null () !! compute the user-defined function !! this can point to the `problem_func` or, if using !! the cache, it points to [[compute_function_with_cache]]. procedure ( spars_f ), pointer :: compute_sparsity => null () !! for computing the sparsity pattern procedure ( info_f ), pointer :: info_function => null () !! an optional function the user can define !! which is called when each column of the jacobian is computed. !! It can be used to perform any setup operations. procedure ( jacobian_f ), pointer :: jacobian_function => null () !! the low-level function called by [[compute_jacobian]] !! that actually computes the jacobian. contains private procedure , public :: initialize => initialize_numdiff !! initialize the class procedure , public :: diff_initialize => initialize_numdiff_for_diff !! initialize the class procedure , public :: compute_jacobian !! main routine to compute the Jacobian !! using the selected options. It !! returns the sparse (vector) form. procedure , public :: compute_jacobian_dense !! return the dense `size(m,n)` !! matrix form of the Jacobian. procedure , public :: compute_jacobian_times_vector !! returns the product of the Jacobian !! matrix and an input vector procedure , public :: destroy => destroy_numdiff_type !! destroy the class procedure , public :: print_sparsity_pattern !! print the sparsity pattern in vector form to a file procedure , public :: print_sparsity_matrix !! print the sparsity pattern in matrix form to a file procedure , public :: set_sparsity_pattern !! manually set the sparsity pattern procedure , public :: select_finite_diff_method !! select a method in a specified class so !! that the variable bounds are not violated !! when by the perturbations. procedure , public :: select_finite_diff_method_for_partition_group !! version of [[select_finite_diff_method]] !! for partitioned sparsity pattern. procedure , public :: set_numdiff_bounds !! can be called to change the variable bounds. procedure , public :: compute_sparsity_pattern !! if the user needs to compute the sparsity pattern manually. !! (otherwise it will be done the first time the Jacobian is computed) procedure , public :: get_sparsity_pattern !! returns the sparsity pattern (if it is allocated) procedure , public :: terminate !! can be called by user to stop the computation procedure , public :: failed !! to check if an exception was raised. procedure , public :: get_error_status !! the status of error condition procedure , public :: set_dpert !! change the `dpert` values ! internal routines: procedure :: destroy_sparsity_pattern !! destroy the sparsity pattern procedure :: compute_perturb_vector procedure :: compute_perturbation_vector !! computes the variable perturbation factor procedure :: compute_sparsity_perturbation_vector procedure :: perturb_x_and_compute_f procedure :: perturb_x_and_compute_f_partitioned procedure :: set_numdiff_sparsity_bounds procedure :: set_sparsity_mode procedure :: generate_dense_sparsity_partition procedure :: compute_jacobian_for_sparsity procedure :: resize_sparsity_vectors procedure :: raise_exception procedure :: clear_exceptions end type numdiff_type abstract interface subroutine func ( me , x , f , funcs_to_compute ) !! The function (vector array of output functions `f`, computed !! from a vector of input variables `x`). !! This must be defined for all computations. import :: numdiff_type , wp implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! array of variables (size `n`) real ( wp ), dimension (:), intent ( out ) :: f !! array of functions (size `m`) integer , dimension (:), intent ( in ) :: funcs_to_compute !! the elements of the !! function vector that need !! to be computed (the other !! are ignored) end subroutine func subroutine spars_f ( me , x ) !! The function to compute the sparsity pattern. !! It populates the `irow` and `icol` variables in the class. import :: numdiff_type , wp implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) end subroutine spars_f subroutine info_f ( me , column , i , x ) !! User-defined info function (optional). !! Informs user what is being done during Jacobian computation. !! It can be used to perform any setup operations that need to !! done on the user's end. import :: numdiff_type , wp implicit none class ( numdiff_type ), intent ( inout ) :: me integer , dimension (:), intent ( in ) :: column !! the columns being computed. integer , intent ( in ) :: i !! perturbing these columns for the `i`th time (1,2,...) real ( wp ), dimension (:), intent ( in ) :: x !! the nominal variable vector end subroutine info_f subroutine jacobian_f ( me , x , dx , jac ) !! Actual function for computing the Jacobian !! called by [[compute_jacobian]]. import :: numdiff_type , wp implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector (size `num_nonzero_elements`) end subroutine jacobian_f end interface ! other: public :: get_finite_diff_formula public :: get_all_methods_in_class contains !******************************************************************************* !******************************************************************************* !> !  Constructor for a [[finite_diff_method]]. ! !@note factors are input as integers for convenience, but are converted !      to reals for the actual computations. (note: this means we can't !      currently define methods that have non-integer factors). function initialize_finite_difference_method ( id , name , class , dx_factors ,& df_factors , df_den_factor ) result ( me ) implicit none type ( finite_diff_method ) :: me integer , intent ( in ) :: id !! unique ID for the method character ( len =* ), intent ( in ) :: name !! the name of the method integer , intent ( in ) :: class !! 2=backward diffs, 3=central diffs, etc... integer , dimension (:), intent ( in ) :: dx_factors !! multiplicative factors for dx perturbation integer , dimension (:), intent ( in ) :: df_factors !! multiplicative factors for accumulating function evaluations integer , intent ( in ) :: df_den_factor !! denominator factor for finite difference equation (times dx) if ( size ( dx_factors ) /= size ( df_factors )) then error stop 'Error in initialize_finite_difference_method: ' // & 'dx_factors and df_factors arrays must be the same size.' else me % id = id me % name = trim ( name ) me % class = class ! the following is not strictly necessary if the ! compiler fully supports auto-LHS allocation: allocate ( me % dx_factors ( size ( dx_factors ))) allocate ( me % df_factors ( size ( df_factors ))) me % dx_factors = real ( dx_factors , wp ) me % df_factors = real ( df_factors , wp ) me % df_den_factor = real ( df_den_factor , wp ) end if end function initialize_finite_difference_method !******************************************************************************* !******************************************************************************* !> !  Print the contents of a [[finite_diff_method]]. Used for debugging. subroutine print_finite_difference_method ( me , iunit ) implicit none class ( finite_diff_method ), intent ( in ) :: me integer , intent ( in ) :: iunit !! file unit for printing !! (assumed to be opened) write ( iunit , '(A,1X,I5)' ) 'id            :' , me % id write ( iunit , '(A,1X,A)' ) 'name          :' , me % name write ( iunit , '(A,1X,I5)' ) 'class         :' , me % class write ( iunit , '(A,1X,*(I5,\",\"))' ) 'dx_factors    :' , int ( me % dx_factors ) write ( iunit , '(A,1X,*(I5,\",\"))' ) 'df_factors    :' , int ( me % df_factors ) write ( iunit , '(A,1X,I5)' ) 'df_den_factor :' , int ( me % df_den_factor ) end subroutine print_finite_difference_method !******************************************************************************* !******************************************************************************* !> !  Wrapper for computing the function, using the cache. subroutine compute_function_with_cache ( me , x , f , funcs_to_compute ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! array of variables (size `n`) real ( wp ), dimension (:), intent ( out ) :: f !! array of functions (size `m`) integer , dimension (:), intent ( in ) :: funcs_to_compute !! the elements of the !! function vector that need !! to be computed (the other !! are ignored) integer :: i !! index in the cache logical , dimension ( size ( funcs_to_compute )) :: ffound !! functions found in the cache logical :: xfound !! if `x` was found in the cache if ( me % exception_raised ) return ! check for exceptions call me % cache % get ( x , funcs_to_compute , i , f , xfound , ffound ) if ( xfound . and . any ( ffound )) then ! at least one of the functions was found if ( all ( ffound )) return ! all were found ! compute the ones that weren't found, ! and add them to the cache: call me % problem_func ( x , f , pack ( funcs_to_compute , mask = (. not . ffound ))) call me % cache % put ( i , x , f , pack ( funcs_to_compute , mask = (. not . ffound ))) else ! compute the function and add it to the cache: call me % problem_func ( x , f , funcs_to_compute ) call me % cache % put ( i , x , f , funcs_to_compute ) end if end subroutine compute_function_with_cache !******************************************************************************* !******************************************************************************* !> !  Return a string with the finite difference formula. ! !### Example !  * For 3-point backward: `dfdx = (f(x-2h)-4f(x-h)+3f(x)) / (2h)` subroutine get_formula ( me , formula ) class ( finite_diff_method ), intent ( in ) :: me character ( len = :), allocatable , intent ( out ) :: formula integer :: i !! counter character ( len = :), allocatable :: x !! temp variable for integer to string conversion character ( len = :), allocatable :: f !! temp variable for integer to string conversion if ( allocated ( me % dx_factors ) . and . allocated ( me % df_factors )) then formula = 'dfdx = (' do i = 1 , size ( me % dx_factors ) if ( int ( me % df_factors ( i )) == 1 ) then if ( i == 1 ) then formula = formula // 'f(' else formula = formula // '+f(' end if elseif ( int ( me % df_factors ( i )) ==- 1 ) then formula = formula // '-f(' else if ( i == 1 ) then f = integer_to_string ( int ( me % df_factors ( i ))) else f = integer_to_string ( int ( me % df_factors ( i )), with_sign = . true .) end if formula = formula // trim ( adjustl ( f )) // 'f(' end if if ( int ( me % dx_factors ( i )) == 0 ) then formula = formula // 'x' elseif ( int ( me % dx_factors ( i )) == 1 ) then formula = formula // 'x+h' elseif ( int ( me % dx_factors ( i )) ==- 1 ) then formula = formula // 'x-h' else x = integer_to_string ( int ( me % dx_factors ( i )), with_sign = . true .) formula = formula // 'x' // trim ( adjustl ( x )) // 'h' end if formula = formula // ')' end do f = integer_to_string ( int ( me % df_den_factor )) if ( int ( me % df_den_factor ) == 1 ) then formula = formula // ') / h' else formula = formula // ') / (' // trim ( adjustl ( f )) // 'h)' end if else formula = '' end if end subroutine get_formula !******************************************************************************* !******************************************************************************* !> !  Return a string with the finite difference formula. !  Input is the method `id` code. ! !###See also: !  * [[get_formula]] subroutine get_finite_diff_formula ( id , formula , name ) implicit none integer , intent ( in ) :: id !! the id code for the method character ( len = :), allocatable , intent ( out ) :: formula !! the formula string character ( len = :), allocatable , intent ( out ), optional :: name type ( finite_diff_method ) :: fd logical :: found call get_finite_difference_method ( id , fd , found ) if ( found . and . fd % id /= 0 ) then call get_formula ( fd , formula ) if ( present ( name )) name = fd % name else formula = '' if ( present ( name )) name = '' end if end subroutine get_finite_diff_formula !******************************************************************************* !******************************************************************************* !> !  Return a [[finite_diff_method]] given the `id` code. !  (the `id` codes begin at 1, are sequential, and uniquely define the method). ! !### Available methods ! !   *  (f(x+h)-f(x)) / h  !   *  (f(x)-f(x-h)) / h  !   *  (f(x+h)-f(x-h)) / (2h)  !   *  (-3f(x)+4f(x+h)-f(x+2h)) / (2h)  !   *  (f(x-2h)-4f(x-h)+3f(x)) / (2h)  !   *  (-2f(x-h)-3f(x)+6f(x+h)-f(x+2h)) / (6h)  !   *  (f(x-2h)-6f(x-h)+3f(x)+2f(x+h)) / (6h)  !   *  (-11f(x)+18f(x+h)-9f(x+2h)+2f(x+3h)) / (6h)  !   *  (-2f(x-3h)+9f(x-2h)-18f(x-h)+11f(x)) / (6h)  !   *  (f(x-2h)-8f(x-h)+8f(x+h)-f(x+2h)) / (12h)  !   *  (-3f(x-h)-10f(x)+18f(x+h)-6f(x+2h)+f(x+3h)) / (12h)  !   *  (-f(x-3h)+6f(x-2h)-18f(x-h)+10f(x)+3f(x+h)) / (12h)  !   *  (-25f(x)+48f(x+h)-36f(x+2h)+16f(x+3h)-3f(x+4h)) / (12h)  !   *  (3f(x-4h)-16f(x-3h)+36f(x-2h)-48f(x-h)+25f(x)) / (12h)  !   *  (3f(x-2h)-30f(x-h)-20f(x)+60f(x+h)-15f(x+2h)+2f(x+3h)) / (60h)  !   *  (-2f(x-3h)+15f(x-2h)-60f(x-h)+20f(x)+30f(x+h)-3f(x+2h)) / (60h)  !   *  (-12f(x-h)-65f(x)+120f(x+h)-60f(x+2h)+20f(x+3h)-3f(x+4h)) / (60h)  !   *  (3f(x-4h)-20f(x-3h)+60f(x-2h)-120f(x-h)+65f(x)+12f(x+h)) / (60h)  !   *  (-137f(x)+300f(x+h)-300f(x+2h)+200f(x+3h)-75f(x+4h)+12f(x+5h)) / (60h)  !   *  (-12f(x-5h)+75f(x-4h)-200f(x-3h)+300f(x-2h)-300f(x-h)+137f(x)) / (60h)  !   *  (-f(x-3h)+9f(x-2h)-45f(x-h)+45f(x+h)-9f(x+2h)+f(x+3h)) / (60h)  !   *  (2f(x-2h)-24f(x-h)-35f(x)+80f(x+h)-30f(x+2h)+8f(x+3h)-f(x+4h)) / (60h)  !   *  (f(x-4h)-8f(x-3h)+30f(x-2h)-80f(x-h)+35f(x)+24f(x+h)-2f(x+2h)) / (60h)  !   *  (-10f(x-h)-77f(x)+150f(x+h)-100f(x+2h)+50f(x+3h)-15f(x+4h)+2f(x+5h)) / (60h)  !   *  (-2f(x-5h)+15f(x-4h)-50f(x-3h)+100f(x-2h)-150f(x-h)+77f(x)+10f(x+h)) / (60h)  !   *  (-147f(x)+360f(x+h)-450f(x+2h)+400f(x+3h)-225f(x+4h)+72f(x+5h)-10f(x+6h)) / (60h)  !   *  (10f(x-6h)-72f(x-5h)+225f(x-4h)-400f(x-3h)+450f(x-2h)-360f(x-h)+147f(x)) / (60h)  !   *  (-4f(x-3h)+42f(x-2h)-252f(x-h)-105f(x)+420f(x+h)-126f(x+2h)+28f(x+3h)-3f(x+4h)) / (420h)  !   *  (3f(x-4h)-28f(x-3h)+126f(x-2h)-420f(x-h)+105f(x)+252f(x+h)-42f(x+2h)+4f(x+3h)) / (420h)  !   *  (10f(x-2h)-140f(x-h)-329f(x)+700f(x+h)-350f(x+2h)+140f(x+3h)-35f(x+4h)+4f(x+5h)) / (420h)  !   *  (-4f(x-5h)+35f(x-4h)-140f(x-3h)+350f(x-2h)-700f(x-h)+329f(x)+140f(x+h)-10f(x+2h)) / (420h)  !   *  (-60f(x-h)-609f(x)+1260f(x+h)-1050f(x+2h)+700f(x+3h)-315f(x+4h)+84f(x+5h)-10f(x+6h)) / (420h)  !   *  (10f(x-6h)-84f(x-5h)+315f(x-4h)-700f(x-3h)+1050f(x-2h)-1260f(x-h)+609f(x)+60f(x+h)) / (420h)  !   *  (-1089f(x)+2940f(x+h)-4410f(x+2h)+4900f(x+3h)-3675f(x+4h)+1764f(x+5h)-490f(x+6h)+60f(x+7h)) / (420h)  !   *  (-60f(x-7h)+490f(x-6h)-1764f(x-5h)+3675f(x-4h)-4900f(x-3h)+4410f(x-2h)-2940f(x-h)+1089f(x)) / (420h)  !   *  (3f(x-4h)-32f(x-3h)+168f(x-2h)-672f(x-h)+672f(x+h)-168f(x+2h)+32f(x+3h)-3f(x+4h)) / (840h)  !   *  (-5f(x-3h)+60f(x-2h)-420f(x-h)-378f(x)+1050f(x+h)-420f(x+2h)+140f(x+3h)-30f(x+4h)+3f(x+5h)) / (840h)  !   *  (-3f(x-5h)+30f(x-4h)-140f(x-3h)+420f(x-2h)-1050f(x-h)+378f(x)+420f(x+h)-60f(x+2h)+5f(x+3h)) / (840h)  !   *  (15f(x-2h)-240f(x-h)-798f(x)+1680f(x+h)-1050f(x+2h)+560f(x+3h)-210f(x+4h)+48f(x+5h)-5f(x+6h)) / (840h)  !   *  (5f(x-6h)-48f(x-5h)+210f(x-4h)-560f(x-3h)+1050f(x-2h)-1680f(x-h)+798f(x)+240f(x+h)-15f(x+2h)) / (840h)  !   *  (-105f(x-h)-1338f(x)+2940f(x+h)-2940f(x+2h)+2450f(x+3h)-1470f(x+4h)+588f(x+5h)-140f(x+6h)+15f(x+7h)) / (840h)  !   *  (-15f(x-7h)+140f(x-6h)-588f(x-5h)+1470f(x-4h)-2450f(x-3h)+2940f(x-2h)-2940f(x-h)+1338f(x)+105f(x+h)) / (840h)  !   *  (-2283f(x)+6720f(x+h)-11760f(x+2h)+15680f(x+3h)-14700f(x+4h)+9408f(x+5h)-3920f(x+6h)+960f(x+7h)-105f(x+8h)) / (840h)  !   *  (105f(x-8h)-960f(x-7h)+3920f(x-6h)-9408f(x-5h)+14700f(x-4h)-15680f(x-3h)+11760f(x-2h)-6720f(x-h)+2283f(x)) / (840h)  !   *  (-2f(x-5h)+25f(x-4h)-150f(x-3h)+600f(x-2h)-2100f(x-h)+2100f(x+h)-600f(x+2h)+150f(x+3h)-25f(x+4h)+2f(x+5h)) / (2520h)  !   *  (5f(x-6h)-72f(x-5h)+495f(x-4h)-2200f(x-3h)+7425f(x-2h)-23760f(x-h)+23760f(x+h)-7425f(x+2h)+2200f(x+3h)-495f(x+4h)+ !        72f(x+5h)-5f(x+6h)) / (27720h)  !   *  (-15f(x-7h)+245f(x-6h)-1911f(x-5h)+9555f(x-4h)-35035f(x-3h)+105105f(x-2h)-315315f(x-h)+315315f(x+h)-105105f(x+2h)+ !        35035f(x+3h)-9555f(x+4h)+1911f(x+5h)-245f(x+6h)+15f(x+7h)) / (360360h)  !   *  (7f(x-8h)-128f(x-7h)+1120f(x-6h)-6272f(x-5h)+25480f(x-4h)-81536f(x-3h)+224224f(x-2h)-640640f(x-h)+640640f(x+h)- !        224224f(x+2h)+81536f(x+3h)-25480f(x+4h)+6272f(x+5h)-1120f(x+6h)+128f(x+7h)-7f(x+8h)) / (720720h)  ! !  Where f(x) is the user-defined function of x !  and h is a \"small\" perturbation. ! !### References !  * G. E. Mullges, F. Uhlig, \"Numerical Algorithms with Fortran\", Springer, 1996. !  * G. W. Griffiths, \"Numerical Analysis Using R\", Cambridge University Press, 2016. ! !@note This is the only routine that has to be changed if a new !      finite difference method is added. ! !@note The order within a class is assumed to be the order that we would prefer !      to use them (e.g., central diffs are first, etc.) This is used in !      the [[select_finite_diff_method]] routine. subroutine get_finite_difference_method ( id , fd , found ) implicit none integer , intent ( in ) :: id !! the id code for the method type ( finite_diff_method ), intent ( out ) :: fd !! this method (can be used !! in [[compute_jacobian]]) logical , intent ( out ) :: found !! true if it was found found = . true . select case ( id ) ! 2 point methods case ( 1 ) ! (f(x+h)-f(x)) / h fd = finite_diff_method ( id , '2-point forward 1' , 2 ,[ 1 , 0 ],[ 1 , - 1 ], 1 ) case ( 2 ) ! (f(x)-f(x-h)) / h fd = finite_diff_method ( id , '2-point backward 1' , 2 ,[ 0 , - 1 ],[ 1 , - 1 ], 1 ) ! 3 point methods case ( 3 ) ! (f(x+h)-f(x-h)) / (2h) fd = finite_diff_method ( id , '3-point central' , 3 ,[ 1 , - 1 ],[ 1 , - 1 ], 2 ) case ( 4 ) ! (-3f(x)+4f(x+h)-f(x+2h)) / (2h) fd = finite_diff_method ( id , '3-point forward 2' , 3 ,[ 0 , 1 , 2 ],[ - 3 , 4 , - 1 ], 2 ) case ( 5 ) ! (f(x-2h)-4f(x-h)+3f(x)) / (2h) fd = finite_diff_method ( id , '3-point backward 2' , 3 ,[ - 2 , - 1 , 0 ],[ 1 , - 4 , 3 ], 2 ) ! 4 point methods case ( 6 ) ! (-2f(x-h)-3f(x)+6f(x+h)-f(x+2h)) / (6h) fd = finite_diff_method ( id , '4-point forward 2' , 4 ,[ - 1 , 0 , 1 , 2 ],[ - 2 , - 3 , 6 , - 1 ], 6 ) case ( 7 ) ! (f(x-2h)-6f(x-h)+3f(x)+2f(x+h)) / (6h) fd = finite_diff_method ( id , '4-point backward 2' , 4 ,[ - 2 , - 1 , 0 , 1 ],[ 1 , - 6 , 3 , 2 ], 6 ) case ( 8 ) ! (-11f(x)+18f(x+h)-9f(x+2h)+2f(x+3h)) / (6h) fd = finite_diff_method ( id , '4-point forward 3' , 4 ,[ 0 , 1 , 2 , 3 ],[ - 11 , 18 , - 9 , 2 ], 6 ) case ( 9 ) ! (-2f(x-3h)+9f(x-2h)-18f(x-h)+11f(x)) / (6h) fd = finite_diff_method ( id , '4-point backward 3' , 4 ,[ - 3 , - 2 , - 1 , 0 ],[ - 2 , 9 , - 18 , 11 ], 6 ) ! 5 point methods case ( 10 ) ! (f(x-2h)-8f(x-h)+8f(x+h)-f(x+2h)) / (12h) fd = finite_diff_method ( id , '5-point central' , 5 ,[ - 2 , - 1 , 1 , 2 ],[ 1 , - 8 , 8 , - 1 ], 12 ) case ( 11 ) ! (-3f(x-h)-10f(x)+18f(x+h)-6f(x+2h)+f(x+3h)) / (12h) fd = finite_diff_method ( id , '5-point forward 3' , 5 ,[ - 1 , 0 , 1 , 2 , 3 ],[ - 3 , - 10 , 18 , - 6 , 1 ], 12 ) case ( 12 ) ! (-f(x-3h)+6f(x-2h)-18f(x-h)+10f(x)+3f(x+h)) / (12h) fd = finite_diff_method ( id , '5-point backward 3' , 5 ,[ - 3 , - 2 , - 1 , 0 , 1 ],[ - 1 , 6 , - 18 , 10 , 3 ], 12 ) case ( 13 ) ! (-25f(x)+48f(x+h)-36f(x+2h)+16f(x+3h)-3f(x+4h)) / (12h) fd = finite_diff_method ( id , '5-point forward 4' , 5 ,[ 0 , 1 , 2 , 3 , 4 ],[ - 25 , 48 , - 36 , 16 , - 3 ], 12 ) case ( 14 ) ! (3f(x-4h)-16f(x-3h)+36f(x-2h)-48f(x-h)+25f(x)) / (12h) fd = finite_diff_method ( id , '5-point backward 4' , 5 ,[ - 4 , - 3 , - 2 , - 1 , 0 ],[ 3 , - 16 , 36 , - 48 , 25 ], 12 ) ! 6 point methods case ( 15 ) ! (3f(x-2h)-30f(x-h)-20f(x)+60f(x+h)-15f(x+2h)+2f(x+3h)) / (60h) fd = finite_diff_method ( id , '6-point forward 3' , 6 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 ],[ 3 , - 30 , - 20 , 60 , - 15 , 2 ], 60 ) case ( 16 ) ! (-2f(x-3h)+15f(x-2h)-60f(x-h)+20f(x)+30f(x+h)-3f(x+2h)) / (60h) fd = finite_diff_method ( id , '6-point backward 3' , 6 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ - 2 , 15 , - 60 , 20 , 30 , - 3 ], 60 ) case ( 17 ) ! (-12f(x-h)-65f(x)+120f(x+h)-60f(x+2h)+20f(x+3h)-3f(x+4h)) / (60h) fd = finite_diff_method ( id , '6-point forward 4' , 6 ,[ - 1 , 0 , 1 , 2 , 3 , 4 ],[ - 12 , - 65 , 120 , - 60 , 20 , - 3 ], 60 ) case ( 18 ) ! (3f(x-4h)-20f(x-3h)+60f(x-2h)-120f(x-h)+65f(x)+12f(x+h)) / (60h) fd = finite_diff_method ( id , '6-point backward 4' , 6 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ 3 , - 20 , 60 , - 120 , 65 , 12 ], 60 ) case ( 19 ) ! (-137f(x)+300f(x+h)-300f(x+2h)+200f(x+3h)-75f(x+4h)+12f(x+5h)) / (60h) fd = finite_diff_method ( id , '6-point forward 5' , 6 ,[ 0 , 1 , 2 , 3 , 4 , 5 ],[ - 137 , 300 , - 300 , 200 , - 75 , 12 ], 60 ) case ( 20 ) ! (-12f(x-5h)+75f(x-4h)-200f(x-3h)+300f(x-2h)-300f(x-h)+137f(x)) / (60h) fd = finite_diff_method ( id , '6-point backward 5' , 6 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ - 12 , 75 , - 200 , 300 , - 300 , 137 ], 60 ) ! 7 point methods case ( 21 ) ! (-f(x-3h)+9f(x-2h)-45f(x-h)+45f(x+h)-9f(x+2h)+f(x+3h)) / (60h) fd = finite_diff_method ( id , '7-point central' , 7 ,[ - 3 , - 2 , - 1 , 1 , 2 , 3 ],[ - 1 , 9 , - 45 , 45 , - 9 , 1 ], 60 ) case ( 22 ) ! (2f(x-2h)-24f(x-h)-35f(x)+80f(x+h)-30f(x+2h)+8f(x+3h)-f(x+4h)) / (60h) fd = finite_diff_method ( id , '7-point forward 4' , 7 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 ],[ 2 , - 24 , - 35 , 80 , - 30 , 8 , - 1 ], 60 ) case ( 23 ) ! (f(x-4h)-8f(x-3h)+30f(x-2h)-80f(x-h)+35f(x)+24f(x+h)-2f(x+2h)) / (60h) fd = finite_diff_method ( id , '7-point backward 4' , 7 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ 1 , - 8 , 30 , - 80 , 35 , 24 , - 2 ], 60 ) case ( 24 ) ! (-10f(x-h)-77f(x)+150f(x+h)-100f(x+2h)+50f(x+3h)-15f(x+4h)+2f(x+5h)) / (60h) fd = finite_diff_method ( id , '7-point forward 5' , 7 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ - 10 , - 77 , 150 , - 100 , 50 , - 15 , 2 ], 60 ) case ( 25 ) ! (-2f(x-5h)+15f(x-4h)-50f(x-3h)+100f(x-2h)-150f(x-h)+77f(x)+10f(x+h)) / (60h) fd = finite_diff_method ( id , '7-point backward 5' , 7 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ - 2 , 15 , - 50 , 100 , - 150 , 77 , 10 ], 60 ) case ( 26 ) ! (-147f(x)+360f(x+h)-450f(x+2h)+400f(x+3h)-225f(x+4h)+72f(x+5h)-10f(x+6h)) / (60h) fd = finite_diff_method ( id , '7-point forward 6' , 7 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ - 147 , 360 , - 450 , 400 , - 225 , 72 , - 10 ], 60 ) case ( 27 ) ! (10f(x-6h)-72f(x-5h)+225f(x-4h)-400f(x-3h)+450f(x-2h)-360f(x-h)+147f(x)) / (60h) fd = finite_diff_method ( id , '7-point backward 6' , 7 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ 10 , - 72 , 225 , - 400 , 450 , - 360 , 147 ], 60 ) ! 8 point methods case ( 28 ) ! (-4f(x-3h)+42f(x-2h)-252f(x-h)-105f(x)+420f(x+h)-126f(x+2h)+28f(x+3h)-3f(x+4h)) / (420h) fd = finite_diff_method ( id , '8-point forward 4' , 8 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 ],[ - 4 , 42 , - 252 , - 105 , 420 , - 126 , 28 , - 3 ], 420 ) case ( 29 ) ! (3f(x-4h)-28f(x-3h)+126f(x-2h)-420f(x-h)+105f(x)+252f(x+h)-42f(x+2h)+4f(x+3h)) / (420h) fd = finite_diff_method ( id , '8-point backward 4' , 8 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 ],[ 3 , - 28 , 126 , - 420 , 105 , 252 , - 42 , 4 ], 420 ) case ( 30 ) ! (10f(x-2h)-140f(x-h)-329f(x)+700f(x+h)-350f(x+2h)+140f(x+3h)-35f(x+4h)+4f(x+5h)) / (420h) fd = finite_diff_method ( id , '8-point forward 5' , 8 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ 10 , - 140 , - 329 , 700 , - 350 , 140 , - 35 , 4 ], 420 ) case ( 31 ) ! (-4f(x-5h)+35f(x-4h)-140f(x-3h)+350f(x-2h)-700f(x-h)+329f(x)+140f(x+h)-10f(x+2h)) / (420h) fd = finite_diff_method ( id , '8-point backward 5' , 8 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ - 4 , 35 , - 140 , 350 , - 700 , 329 , 140 , - 10 ], 420 ) case ( 32 ) ! (-60f(x-h)-609f(x)+1260f(x+h)-1050f(x+2h)+700f(x+3h)-315f(x+4h)+84f(x+5h)-10f(x+6h)) / (420h) fd = finite_diff_method ( id , '8-point forward 6' , 8 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ - 60 , - 609 , 1260 , - 1050 , 700 , - 315 , 84 , - 10 ], 420 ) case ( 33 ) ! (10f(x-6h)-84f(x-5h)+315f(x-4h)-700f(x-3h)+1050f(x-2h)-1260f(x-h)+609f(x)+60f(x+h)) / (420h) fd = finite_diff_method ( id , '8-point backward 6' , 8 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ 10 , - 84 , 315 , - 700 , 1050 , - 1260 , 609 , 60 ], 420 ) case ( 34 ) ! (-1089f(x)+2940f(x+h)-4410f(x+2h)+4900f(x+3h)-3675f(x+4h)+1764f(x+5h)-490f(x+6h)+60f(x+7h)) / (420h) fd = finite_diff_method ( id , '8-point forward 7' , 8 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],[ - 1089 , 2940 , - 4410 , 4900 , - 3675 , 1764 , - 490 , 60 ], 420 ) case ( 35 ) ! (-60f(x-7h)+490f(x-6h)-1764f(x-5h)+3675f(x-4h)-4900f(x-3h)+4410f(x-2h)-2940f(x-h)+1089f(x)) / (420h) fd = finite_diff_method ( id , '8-point backward 7' , 8 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ - 60 , 490 , - 1764 , 3675 , - 4900 , 4410 , - 2940 , 1089 ], 420 ) ! 9 point methods case ( 36 ) ! (3f(x-4h)-32f(x-3h)+168f(x-2h)-672f(x-h)+672f(x+h)-168f(x+2h)+32f(x+3h)-3f(x+4h)) / (840h) fd = finite_diff_method ( id , '9-point central' , & 9 ,[ - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 ],[ 3 , - 32 , 168 , - 672 , 672 , - 168 , 32 , - 3 ], 840 ) case ( 37 ) ! (-5f(x-3h)+60f(x-2h)-420f(x-h)-378f(x)+1050f(x+h)-420f(x+2h)+140f(x+3h)-30f(x+4h)+3f(x+5h)) / (840h) fd = finite_diff_method ( id , '9-point forward 5' , & 9 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ - 5 , 60 , - 420 , - 378 , 1050 , - 420 , 140 , - 30 , 3 ], 840 ) case ( 38 ) ! (-3f(x-5h)+30f(x-4h)-140f(x-3h)+420f(x-2h)-1050f(x-h)+378f(x)+420f(x+h)-60f(x+2h)+5f(x+3h)) / (840h) fd = finite_diff_method ( id , '9-point backward 5' , & 9 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 ],[ - 3 , 30 , - 140 , 420 , - 1050 , 378 , 420 , - 60 , 5 ], 840 ) case ( 39 ) ! (15f(x-2h)-240f(x-h)-798f(x)+1680f(x+h)-1050f(x+2h)+560f(x+3h)-210f(x+4h)+48f(x+5h)-5f(x+6h)) / (840h) fd = finite_diff_method ( id , '9-point forward 6' , & 9 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ 15 , - 240 , - 798 , 1680 , - 1050 , 560 , - 210 , 48 , - 5 ], 840 ) case ( 40 ) ! (5f(x-6h)-48f(x-5h)+210f(x-4h)-560f(x-3h)+1050f(x-2h)-1680f(x-h)+798f(x)+240f(x+h)-15f(x+2h)) / (840h) fd = finite_diff_method ( id , '9-point backward 6' , & 9 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ 5 , - 48 , 210 , - 560 , 1050 , - 1680 , 798 , 240 , - 15 ], 840 ) case ( 41 ) ! (-105f(x-h)-1338f(x)+2940f(x+h)-2940f(x+2h)+2450f(x+3h)-1470f(x+4h)+588f(x+5h)-140f(x+6h)+15f(x+7h)) / (840h) fd = finite_diff_method ( id , '9-point forward 7' , & 9 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],[ - 105 , - 1338 , 2940 , - 2940 , 2450 , - 1470 , 588 , - 140 , 15 ], 840 ) case ( 42 ) ! (-15f(x-7h)+140f(x-6h)-588f(x-5h)+1470f(x-4h)-2450f(x-3h)+2940f(x-2h)-2940f(x-h)+1338f(x)+105f(x+h)) / (840h) fd = finite_diff_method ( id , '9-point backward 7' , & 9 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ - 15 , 140 , - 588 , 1470 , - 2450 , 2940 , - 2940 , 1338 , 105 ], 840 ) case ( 43 ) ! (-2283f(x)+6720f(x+h)-11760f(x+2h)+15680f(x+3h)-14700f(x+4h)+9408f(x+5h)-3920f(x+6h)+960f(x+7h)-105f(x+8h)) / (840h) fd = finite_diff_method ( id , '9-point forward 8' , & 9 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ],[ - 2283 , 6720 , - 11760 , 15680 , - 14700 , 9408 , - 3920 , 960 , - 105 ], 840 ) case ( 44 ) ! (105f(x-8h)-960f(x-7h)+3920f(x-6h)-9408f(x-5h)+14700f(x-4h)-15680f(x-3h)+11760f(x-2h)-6720f(x-h)+2283f(x)) / (840h) fd = finite_diff_method ( id , '9-point backward 8' , & 9 ,[ - 8 , - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ 105 , - 960 , 3920 , - 9408 , 14700 , - 15680 , 11760 , - 6720 , 2283 ], 840 ) ! 11 point methods case ( 500 ) ! (-2f(x-5h)+25f(x-4h)-150f(x-3h)+600f(x-2h)-2100f(x-h)+2100f(x+h)-600f(x+2h)+150f(x+3h)-25f(x+4h)+2f(x+5h)) / (2520h) fd = finite_diff_method ( id , '11-point central' , & 11 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 ],[ - 2 , 25 , - 150 , 600 , - 2100 , 2100 , - 600 , 150 , - 25 , 2 ], 2520 ) ! 13 point methods case ( 600 ) ! (5f(x-6h)-72f(x-5h)+495f(x-4h)-2200f(x-3h)+7425f(x-2h)-23760f(x-h)+23760f(x+h)-7425f(x+2h)+2200f(x+3h)-495f(x+4h)+72f(x+5h)-5f(x+6h)) / (27720h) fd = finite_diff_method ( id , '13-point central' , & 13 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 ],& [ 5 , - 72 , 495 , - 2200 , 7425 , - 23760 , 23760 , - 7425 , 2200 , - 495 , 72 , - 5 ], 27720 ) ! 15 point methods case ( 700 ) ! (-15f(x-7h)+245f(x-6h)-1911f(x-5h)+9555f(x-4h)-35035f(x-3h)+105105f(x-2h)-315315f(x-h)+315315f(x+h)-105105f(x+2h)+35035f(x+3h)-9555f(x+4h)+1911f(x+5h)-245f(x+6h)+15f(x+7h)) / (360360h) fd = finite_diff_method ( id , '15-point central' , & 15 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],& [ - 15 , 245 , - 1911 , 9555 , - 35035 , 105105 , - 315315 , 315315 , - 105105 , 35035 , - 9555 , 1911 , - 245 , 15 ], 360360 ) ! 17 point methods case ( 800 ) ! (7f(x-8h)-128f(x-7h)+1120f(x-6h)-6272f(x-5h)+25480f(x-4h)-81536f(x-3h)+224224f(x-2h)-640640f(x-h)+640640f(x+h)-224224f(x+2h)+81536f(x+3h)-25480f(x+4h)+6272f(x+5h)-1120f(x+6h)+128f(x+7h)-7f(x+8h)) / (720720h) fd = finite_diff_method ( id , '17-point central' , & 17 ,[ - 8 , - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ],& [ 7 , - 128 , 1120 , - 6272 , 25480 , - 81536 , 224224 , - 640640 , 640640 , - 224224 , 81536 , - 25480 , 6272 , - 1120 , 128 , - 7 ], 720720 ) case default found = . false . end select end subroutine get_finite_difference_method !******************************************************************************* !******************************************************************************* !> !  Returns all the methods with the given `class` !  (i.e., number of points in the formula). function get_all_methods_in_class ( class ) result ( list_of_methods ) implicit none integer , intent ( in ) :: class !! the `class` is the number of points in the !! finite different computation type ( meth_array ) :: list_of_methods !! all the methods with the specified `class` type ( finite_diff_method ) :: fd !! temp variable for getting a !! method from [[get_finite_difference_method]] integer :: id !! method id counter logical :: found !! status flag integer :: n !! temp size variable type ( finite_diff_method ), dimension (:), allocatable :: tmp !! for resizing `meth` array ! currently, the only way to do this is to call the ! get_finite_difference_method routine and see if there ! is one available. id = 0 do id = id + 1 call get_finite_difference_method ( id , fd , found ) if ( found ) then if ( fd % class == class ) then if ( allocated ( list_of_methods % meth )) then ! add to the list n = size ( list_of_methods % meth ) allocate ( tmp ( n + 1 )) tmp ( 1 : n ) = list_of_methods % meth tmp ( n + 1 ) = fd call move_alloc ( tmp , list_of_methods % meth ) ! ... this doesn't appear to work on Intel compiler ... !list_of_methods%meth = [list_of_methods%meth,fd]  ! add to the list else ! first element: allocate ( list_of_methods % meth ( 1 )) list_of_methods % meth = fd end if elseif ( fd % class > class ) then ! we assume they are in increasing order exit end if else exit ! done end if end do end function get_all_methods_in_class !******************************************************************************* !******************************************************************************* !> !  Select a finite diff method of a given `class` so that the perturbations !  of `x` will not violate the variable bounds. subroutine select_finite_diff_method ( me , x , xlow , xhigh , dx , list_of_methods , fd , status_ok ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x !! the variable value real ( wp ), intent ( in ) :: xlow !! the variable lower bound real ( wp ), intent ( in ) :: xhigh !! the variable upper bound real ( wp ), intent ( in ) :: dx !! the perturbation value (>0) type ( meth_array ), intent ( in ) :: list_of_methods !! list of available methods to choose from type ( finite_diff_method ), intent ( out ) :: fd !! this method can be used logical , intent ( out ) :: status_ok !! true if it really doesn't violate the bounds !! (say, the bounds are very close to each other) !! if `status_ok=False`, then the first method in !! the given class is returned in `fd`. integer :: i !! counter integer :: j !! counter real ( wp ) :: xs !! if `x` is outside the bounds, this is the value !! on the nearest bound. otherwise equal to `x`. real ( wp ) :: xp !! perturbed `x` value ! initialize: status_ok = . false . if ( me % exception_raised ) return ! check for exceptions ! make sure it is within the bounds xs = min ( xhigh , max ( xlow , x )) ! try all the methods in the class: do i = 1 , size ( list_of_methods % meth ) status_ok = . true . ! will be set to false if any ! perturbation violates the bounds ! check each of the perturbations: do j = 1 , size ( list_of_methods % meth ( i )% dx_factors ) xp = xs + list_of_methods % meth ( i )% dx_factors ( j ) * dx if ( xp < xlow . or . xp > xhigh ) then status_ok = . false . exit end if end do if ( status_ok ) then ! this one is OK to use fd = list_of_methods % meth ( i ) exit end if end do if (. not . status_ok ) then ! no method was found that doesn't violate the bounds, ! so just return the first one in the list. fd = list_of_methods % meth ( 1 ) end if end subroutine select_finite_diff_method !******************************************************************************* !******************************************************************************* !> !  Select a finite diff method of a given `class` so that the perturbations !  of `x` will not violate the variable bounds for any variable in the group. ! !  The `x` vector are only the variables in a group (not the full variable vector) subroutine select_finite_diff_method_for_partition_group ( me , x , xlow , xhigh , dx ,& list_of_methods , fd , status_ok ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! the variable values real ( wp ), dimension (:), intent ( in ) :: xlow !! the variable lower bounds real ( wp ), dimension (:), intent ( in ) :: xhigh !! the variable upper bounds real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation values (>0) type ( meth_array ), intent ( in ) :: list_of_methods !! list of available methods to choose from type ( finite_diff_method ), intent ( out ) :: fd !! this method can be used logical , intent ( out ) :: status_ok !! true if it really doesn't violate the bounds !! (say, the bounds are very close to each other) !! if `status_ok=False`, then the first method in !! the given class is returned in `fd`. integer :: i !! counter integer :: j !! counter real ( wp ), dimension ( size ( x )) :: xp !! perturbed `x` values real ( wp ), dimension ( size ( x )) :: xs !! if `x` is outside the bounds, this is the value !! on the nearest bound. otherwise equal to `x`. ! initialize: status_ok = . false . if ( me % exception_raised ) return ! check for exceptions ! make sure they are within the bounds xs = min ( xhigh , max ( xlow , x )) ! try all the methods in the class: do i = 1 , size ( list_of_methods % meth ) status_ok = . true . ! will be set to false if any ! perturbation violates the bounds ! check each of the perturbations: do j = 1 , size ( list_of_methods % meth ( i )% dx_factors ) xp = xs + list_of_methods % meth ( i )% dx_factors ( j ) * dx if ( any ( xp < xlow ) . or . any ( xp > xhigh )) then status_ok = . false . exit end if end do if ( status_ok ) then ! this one is OK to use fd = list_of_methods % meth ( i ) exit end if end do if (. not . status_ok ) then ! no method was found that doesn't violate the bounds, ! so just return the first one in the list. fd = list_of_methods % meth ( 1 ) end if end subroutine select_finite_diff_method_for_partition_group !******************************************************************************* !******************************************************************************* !> !  Alternate version of [[initialize_numdiff]] routine when !  using [[diff]] to compute the Jacobian. subroutine initialize_numdiff_for_diff ( me , n , m , xlow , xhigh ,& problem_func , sparsity_mode , info ,& chunk_size , eps , acc , cache_size ,& xlow_for_sparsity , xhigh_for_sparsity ,& dpert_for_sparsity , sparsity_perturb_mode ,& linear_sparsity_tol , function_precision_tol ,& num_sparsity_points , print_messages ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of `x` variables integer , intent ( in ) :: m !! number of `f` functions real ( wp ), dimension ( n ), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension ( n ), intent ( in ) :: xhigh !! upper bounds on `x` procedure ( func ) :: problem_func !! the user function that defines the problem !! (returns `m` functions) integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. procedure ( info_f ), optional :: info !! a function the user can define !! which is called when each column !! of the jacobian is computed. !! It can be used to perform any !! setup operations. integer , intent ( in ), optional :: chunk_size !! chunk size for allocating the arrays !! (must be >0) [default is 100] real ( wp ), intent ( in ), optional :: eps !! tolerance parameter for [[diff]] !! if not present, default is `1.0e-9_wp` real ( wp ), intent ( in ), optional :: acc !! tolerance parameter for [[diff]] !! if not present, default is `0.0_wp` integer , intent ( in ), optional :: cache_size !! if present, this is the cache size !! for the function cache !! (default is not to enable cache) real ( wp ), dimension ( n ), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: dpert_for_sparsity !! required if `sparsity_mode=4` integer , intent ( in ), optional :: sparsity_perturb_mode !! perturbation mode (required if `sparsity_mode=4`): !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` integer , intent ( in ), optional :: num_sparsity_points !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. real ( wp ), intent ( in ), optional :: linear_sparsity_tol !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ), intent ( in ), optional :: function_precision_tol !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] logical , intent ( in ), optional :: print_messages !! if true, print error messages to `error_unit`. !! default is True. logical :: cache !! if the cache is to be used me % use_diff = . true . ! cache: cache = present ( cache_size ) if ( cache ) cache = cache_size > 0 if ( cache ) then me % compute_function => compute_function_with_cache call me % cache % initialize ( cache_size , n , m ) else me % compute_function => problem_func call me % cache % destroy () end if ! functions: me % problem_func => problem_func me % jacobian_function => compute_jacobian_with_diff ! size of the problem: me % n = n me % m = m ! input variable bounds: call me % set_numdiff_bounds ( xlow , xhigh ) ! set the sparsity function call me % set_sparsity_mode ( sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) if ( sparsity_mode == 4 ) then ! these must be present, since we don't have a dpert and perturb mode for the gradients: if ( present ( dpert_for_sparsity ) . and . present ( sparsity_perturb_mode )) then me % dpert_for_sparsity = abs ( dpert_for_sparsity ) ! perturbation options: select case ( sparsity_perturb_mode ) case ( 1 : 3 ) me % sparsity_perturb_mode = sparsity_perturb_mode case default call me % raise_exception ( 1 , 'initialize_numdiff_for_diff' ,& 'sparsity_perturb_mode must be 1, 2, or 3.' ) return end select else call me % raise_exception ( 2 , 'initialize_numdiff_for_diff' ,& 'missing required inputs for sparsity mode 4' ) return end if end if ! if these aren't present, they will just keep the defaults: if ( present ( linear_sparsity_tol )) me % linear_sparsity_tol = linear_sparsity_tol if ( present ( function_precision_tol )) me % function_precision_tol = function_precision_tol if ( present ( num_sparsity_points )) me % num_sparsity_points = num_sparsity_points ! optional: if ( present ( chunk_size )) me % chunk_size = abs ( chunk_size ) if ( present ( eps )) me % eps = eps if ( present ( acc )) me % acc = acc if ( present ( info )) me % info_function => info if ( present ( print_messages )) me % print_messages = print_messages end subroutine initialize_numdiff_for_diff !******************************************************************************* !******************************************************************************* !> !  Change the variable bounds in a [[numdiff_type]]. ! !### See also !  * [[set_numdiff_sparsity_bounds]] ! !@note The bounds must be set when the class is initialized, !      but this routine can be used to change them later if required. subroutine set_numdiff_bounds ( me , xlow , xhigh ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension (:), intent ( in ) :: xhigh !! upper bounds on `x` integer :: i !! counter for error print character ( len = :), allocatable :: error_info !! error message info character ( len = :), allocatable :: istr !! for integer to string character ( len = 30 ) :: xlow_str , xhigh_str !! for real to string if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % xlow )) deallocate ( me % xlow ) if ( allocated ( me % xhigh )) deallocate ( me % xhigh ) if ( size ( xlow ) /= me % n . or . size ( xhigh ) /= me % n ) then call me % raise_exception ( 3 , 'set_numdiff_bounds' ,& 'invalid size of xlow or xhigh' ) return else if ( any ( xlow >= xhigh )) then error_info = 'all xlow must be < xhigh' do i = 1 , size ( xlow ) if ( xlow ( i ) >= xhigh ( i )) then istr = integer_to_string ( i ) write ( xlow_str , '(F30.16)' ) xlow ( i ) write ( xhigh_str , '(F30.16)' ) xhigh ( i ) error_info = error_info // new_line ( '' ) // '  Error for optimization variable ' // trim ( adjustl ( istr )) // & ': xlow=' // trim ( adjustl ( xlow_str )) // & ' >= xhigh=' // trim ( adjustl ( xhigh_str )) end if end do call me % raise_exception ( 4 , 'set_numdiff_bounds' , error_info ) return else allocate ( me % xlow ( me % n )) allocate ( me % xhigh ( me % n )) me % xlow = xlow me % xhigh = xhigh end if end subroutine set_numdiff_bounds !******************************************************************************* !******************************************************************************* !> !  Set sparsity mode. subroutine set_sparsity_mode ( me , sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. real ( wp ), dimension (:), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension (:), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. if ( me % exception_raised ) return ! check for exceptions ! set the sparsity function select case ( sparsity_mode ) case ( 1 ) ! dense me % compute_sparsity => compute_sparsity_dense case ( 3 ) ! user defined me % compute_sparsity => null () case ( 2 ) ! three-point simple method me % compute_sparsity => compute_sparsity_random ! in this case, we have the option of specifying ! separate bounds for computing the sparsity: call me % set_numdiff_sparsity_bounds ( xlow_for_sparsity , xhigh_for_sparsity ) case ( 4 ) ! compute 2-point jacobian in specified number of points me % compute_sparsity => compute_sparsity_random_2 ! in this case, we have the option of specifying ! separate bounds for computing the sparsity: call me % set_numdiff_sparsity_bounds ( xlow_for_sparsity , xhigh_for_sparsity ) case default call me % raise_exception ( 5 , 'set_sparsity_mode' ,& 'sparsity_mode must be 1, 2, 3, or 4.' ) return end select end subroutine set_sparsity_mode !******************************************************************************* !******************************************************************************* !> !  Sets the variable bounds for sparsity in a [[numdiff_type]]. !  These are only used for `sparsity_mode=2`. ! !### See also !  * [[set_numdiff_bounds]] ! !@note This routine assumes that `xlow` and `xhigh` have already !      been set in the class. subroutine set_numdiff_sparsity_bounds ( me , xlow , xhigh ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ), optional :: xlow !! lower bounds on `x` to be used for !! sparsity computation. If not present, !! then then `xlow` values in the class are used. real ( wp ), dimension (:), intent ( in ), optional :: xhigh !! upper bounds on `x` to be used for !! sparsity computation. If not present, !! then then `xhigh` values in the class are used. if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % xlow_for_sparsity )) deallocate ( me % xlow_for_sparsity ) if ( allocated ( me % xhigh_for_sparsity )) deallocate ( me % xhigh_for_sparsity ) if (. not . present ( xlow )) then allocate ( me % xlow_for_sparsity ( size ( me % xlow ))) me % xlow_for_sparsity = me % xlow else allocate ( me % xlow_for_sparsity ( size ( xlow ))) me % xlow_for_sparsity = xlow end if if (. not . present ( xhigh )) then allocate ( me % xhigh_for_sparsity ( size ( me % xhigh ))) me % xhigh_for_sparsity = me % xhigh else allocate ( me % xhigh_for_sparsity ( size ( xhigh ))) me % xhigh_for_sparsity = xhigh end if ! error checks: if ( size ( me % xlow_for_sparsity ) /= me % n . or . size ( me % xhigh_for_sparsity ) /= me % n ) then call me % raise_exception ( 6 , 'set_numdiff_sparsity_bounds' ,& 'invalid size of xlow or xhigh' ) else if ( any ( me % xlow_for_sparsity >= me % xhigh_for_sparsity )) then call me % raise_exception ( 7 , 'set_numdiff_sparsity_bounds' ,& 'all xlow must be < xhigh' ) end if end subroutine set_numdiff_sparsity_bounds !******************************************************************************* !******************************************************************************* !> !  Change the `dpert` vector. Can be used after the class has been initialized !  to change the perturbation step sizes (e.g., after an iteration). subroutine set_dpert ( me , dpert ) class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: dpert !! perturbation vector for `x` if ( size ( dpert ) /= me % n ) then call me % raise_exception ( 29 , 'set_dpert' ,& 'incorrect size of dpert array' ) else me % dpert = abs ( dpert ) ! update end if end subroutine set_dpert !******************************************************************************* !******************************************************************************* !> !  Initialize a [[numdiff_type]] class. This must be called first. ! !@note Only one of the following inputs can be used: `jacobian_method`, !      `jacobian_methods`, `class`, or `classes`. subroutine initialize_numdiff ( me , n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func , sparsity_mode , jacobian_method , jacobian_methods ,& class , classes , info , chunk_size , partition_sparsity_pattern ,& cache_size , xlow_for_sparsity , xhigh_for_sparsity ,& dpert_for_sparsity , sparsity_perturb_mode ,& linear_sparsity_tol , function_precision_tol ,& num_sparsity_points ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of `x` variables integer , intent ( in ) :: m !! number of `f` functions real ( wp ), dimension ( n ), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension ( n ), intent ( in ) :: xhigh !! upper bounds on `x` integer , intent ( in ) :: perturb_mode !! perturbation mode: !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), dimension ( n ), intent ( in ) :: dpert !! perturbation vector for `x` procedure ( func ) :: problem_func !! the user function that defines the problem !! (returns `m` functions) integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. integer , intent ( in ), optional :: jacobian_method !! `id` code for the finite difference method !! to use for all `n` variables. !! see [[get_finite_difference_method]] integer , dimension ( n ), intent ( in ), optional :: jacobian_methods !! `id` codes for the finite difference method !! to use for each variable. !! see [[get_finite_difference_method]] integer , intent ( in ), optional :: class !! method class for the finite difference method !! to use for all `n` variables. !! see [[get_finite_difference_method]] integer , dimension ( n ), intent ( in ), optional :: classes !! method class for the finite difference methods !! to use for each variable. !! see [[get_finite_difference_method]] procedure ( info_f ), optional :: info !! a function the user can define !! which is called when each column !! of the jacobian is computed. !! It can be used to perform any !! setup operations. integer , intent ( in ), optional :: chunk_size !! chunk size for allocating the arrays !! (must be >0) [default is 100] logical , intent ( in ), optional :: partition_sparsity_pattern !! if the sparisty pattern is to !! be partitioned using [[DSM]] !! [default is False] integer , intent ( in ), optional :: cache_size !! if present, this is the cache size !! for the function cache !! (default is not to enable cache) real ( wp ), dimension ( n ), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: dpert_for_sparsity !! for `sparsity_mode=4`, the perturbation integer , intent ( in ), optional :: sparsity_perturb_mode !! perturbation mode (required if `sparsity_mode=4`): !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), intent ( in ), optional :: linear_sparsity_tol !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ), intent ( in ), optional :: function_precision_tol !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] integer , intent ( in ), optional :: num_sparsity_points !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. integer :: i !! counter logical :: found !! flag for [[get_finite_difference_method]] logical :: cache !! if the cache is to be used me % use_diff = . false . ! cache: cache = present ( cache_size ) if ( cache ) cache = cache_size > 0 if ( cache ) then me % compute_function => compute_function_with_cache call me % cache % initialize ( cache_size , n , m ) else me % compute_function => problem_func call me % cache % destroy () end if ! functions: me % problem_func => problem_func if ( present ( partition_sparsity_pattern )) then me % partition_sparsity_pattern = partition_sparsity_pattern else me % partition_sparsity_pattern = . false . end if ! method: if ( allocated ( me % meth )) deallocate ( me % meth ) if ( allocated ( me % class )) deallocate ( me % class ) if ( allocated ( me % class_meths )) deallocate ( me % class_meths ) if ( present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & . not . present ( class ) . and . . not . present ( classes )) then ! use the same for all variable me % mode = 1 allocate ( me % meth ( n )) do i = 1 , n call get_finite_difference_method ( jacobian_method , me % meth ( i ), found ) if (. not . found ) then call me % raise_exception ( 8 , 'initialize_numdiff' ,& 'invalid jacobian_method' ) return end if end do elseif (. not . present ( jacobian_method ) . and . present ( jacobian_methods ) . and . & . not . present ( class ) . and . . not . present ( classes )) then ! specify a separate method for each variable me % mode = 1 allocate ( me % meth ( n )) do i = 1 , n call get_finite_difference_method ( jacobian_methods ( i ), me % meth ( i ), found ) if (. not . found ) then call me % raise_exception ( 9 , 'initialize_numdiff' ,& 'invalid jacobian_methods' ) return end if end do if ( me % partition_sparsity_pattern ) then call me % raise_exception ( 10 , 'initialize_numdiff' ,& 'when using partitioned sparsity pattern, ' // & 'all columns must use the same ' // & 'finite diff method.' ) return end if elseif (. not . present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & present ( class ) . and . . not . present ( classes )) then ! use the class for all variables me % mode = 2 allocate ( me % class ( n )) me % class = class allocate ( me % class_meths ( n )) me % class_meths ( 1 ) = get_all_methods_in_class ( class ) if ( n > 1 ) me % class_meths ( 2 : n ) = me % class_meths ( 1 ) ! just copy them over elseif (. not . present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & . not . present ( class ) . and . present ( classes )) then ! specify a separate class for each variable me % mode = 2 me % class = classes allocate ( me % class_meths ( n )) do i = 1 , n me % class_meths ( i ) = get_all_methods_in_class ( me % class ( i )) end do if ( me % partition_sparsity_pattern ) then call me % raise_exception ( 11 , 'initialize_numdiff' ,& 'when using partitioned sparsity pattern, ' // & 'all columns must use the same ' // & 'finite diff method.' ) end if else call me % raise_exception ( 12 , 'initialize_numdiff' ,& 'must specify one of either ' // & 'jacobian_method, jacobian_methods, class, or classes.' ) end if ! size of the problem: me % n = n me % m = m ! input variable bounds: call me % set_numdiff_bounds ( xlow , xhigh ) ! perturbation options: select case ( perturb_mode ) case ( 1 : 3 ) me % perturb_mode = perturb_mode case default call me % raise_exception ( 13 , 'initialize_numdiff' ,& 'perturb_mode must be 1, 2, or 3.' ) return end select if ( allocated ( me % dpert )) deallocate ( me % dpert ) allocate ( me % dpert ( n )) me % dpert = abs ( dpert ) ! optional: if ( present ( info )) me % info_function => info if ( present ( chunk_size )) me % chunk_size = abs ( chunk_size ) ! set the jacobian function, depending on the options: if ( me % partition_sparsity_pattern ) then me % jacobian_function => compute_jacobian_partitioned else me % jacobian_function => compute_jacobian_standard end if ! set the sparsity function call me % set_sparsity_mode ( sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) if ( present ( linear_sparsity_tol )) me % linear_sparsity_tol = linear_sparsity_tol if ( present ( function_precision_tol )) me % function_precision_tol = function_precision_tol if ( present ( num_sparsity_points )) me % num_sparsity_points = num_sparsity_points if ( present ( dpert_for_sparsity )) then me % dpert_for_sparsity = abs ( dpert_for_sparsity ) else me % dpert_for_sparsity = dpert ! use the same dpert as the jacobian end if if ( present ( sparsity_perturb_mode )) then select case ( sparsity_perturb_mode ) case ( 1 : 3 ) me % sparsity_perturb_mode = sparsity_perturb_mode case default call me % raise_exception ( 14 , 'initialize_numdiff' ,& 'sparsity_perturb_mode must be 1, 2, or 3.' ) return end select else me % sparsity_perturb_mode = perturb_mode ! use the same perturb mode as the jacobian end if end subroutine initialize_numdiff !******************************************************************************* !******************************************************************************* !> !  destroy the [[numdiff_type]] class. subroutine destroy_numdiff_type ( me ) implicit none class ( numdiff_type ), intent ( out ) :: me end subroutine destroy_numdiff_type !******************************************************************************* !******************************************************************************* !> !  destroy a [[sparsity_pattern]] type. subroutine destroy_sparsity ( me ) implicit none class ( sparsity_pattern ), intent ( out ) :: me end subroutine destroy_sparsity !******************************************************************************* !******************************************************************************* !> !  Wrapper for [[dsm]] to compute the sparsity pattern partition. subroutine dsm_wrapper ( me , n , m , info ) implicit none class ( sparsity_pattern ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of columns of jacobian matrix integer , intent ( in ) :: m !! number of rows of jacobian matrix integer , intent ( out ) :: info !! status output from [[dsm]] integer :: mingrp !! for call to [[dsm]] integer , dimension (:), allocatable :: ipntr !! for call to [[dsm]] integer , dimension (:), allocatable :: jpntr !! for call to [[dsm]] integer , dimension (:), allocatable :: irow !! for call to [[dsm]] !! (temp copy since [[dsm]] !! will modify it) integer , dimension (:), allocatable :: icol !! for call to [[dsm]] !! (temp copy since [[dsm]] !! will modify it) allocate ( ipntr ( m + 1 )) allocate ( jpntr ( n + 1 )) allocate ( me % ngrp ( n )) irow = me % irow icol = me % icol call dsm ( m , n , me % num_nonzero_elements ,& irow , icol ,& me % ngrp , me % maxgrp ,& mingrp , info , ipntr , jpntr ) end subroutine dsm_wrapper !******************************************************************************* !******************************************************************************* !> !  Returns the columns in a sparsity partition group. ! !@note This is just a wrapper to get data from `ngrp`. subroutine columns_in_partition_group ( me , igroup , n_cols , cols , nonzero_rows , indices , status_ok ) implicit none class ( sparsity_pattern ), intent ( in ) :: me integer , intent ( in ) :: igroup !! group number. Should be `>0` and `<=me%mxgrp` integer , intent ( out ) :: n_cols !! number of columns in the `igroup` group. integer , dimension (:), allocatable , intent ( out ) :: cols !! the column numbers in the `igroup` group. !! (if none, then it is not allocated) integer , dimension (:), allocatable , intent ( out ) :: nonzero_rows !! the row numbers of all the nonzero !! Jacobian elements in this group integer , dimension (:), allocatable , intent ( out ) :: indices !! nonzero indices in `jac` for a group logical , intent ( out ) :: status_ok !! true if the partition is valid integer :: i !! counter integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column integer :: num_nonzero_elements_in_group !! number of nonzero elements in a group integer , dimension (:), allocatable :: col_indices !! nonzero indices in `jac` for a column if ( me % maxgrp > 0 . and . allocated ( me % ngrp )) then status_ok = . true . n_cols = count ( me % ngrp == igroup ) if ( n_cols > 0 ) then allocate ( cols ( n_cols )) cols = pack ([( i , i = 1 , size ( me % ngrp ))], mask = me % ngrp == igroup ) end if ! get all the non-zero elements in each column: num_nonzero_elements_in_group = 0 ! initialize do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % icol == cols ( i )) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to ! compute in this column num_nonzero_elements_in_group = num_nonzero_elements_in_group + & num_nonzero_elements_in_col if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) !col_indices = pack(me%indices,mask=me%icol==cols(i)) block integer :: j , n n = 0 do j = 1 , size ( me % icol ) if ( me % icol ( j ) == cols ( i )) then n = n + 1 col_indices ( n ) = j end if end do end block if ( allocated ( nonzero_rows )) then nonzero_rows = [ nonzero_rows , me % irow ( col_indices )] indices = [ indices , col_indices ] else nonzero_rows = me % irow ( col_indices ) indices = col_indices end if end if end do else status_ok = . false . end if end subroutine columns_in_partition_group !******************************************************************************* !******************************************************************************* !> !  Destroy the sparsity pattern in the class. subroutine destroy_sparsity_pattern ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me call me % sparsity % destroy () end subroutine destroy_sparsity_pattern !******************************************************************************* !******************************************************************************* !> !  Computes the `indices` vector in the class. subroutine compute_indices ( me ) implicit none class ( sparsity_pattern ), intent ( inout ) :: me integer :: i !! counter allocate ( me % indices ( me % num_nonzero_elements )) !me%indices = [(i,i=1,me%num_nonzero_elements)] do i = 1 , me % num_nonzero_elements me % indices ( i ) = i end do end subroutine compute_indices !******************************************************************************* !******************************************************************************* !> !  To specify the sparsity pattern directly if it is already known. ! !@note If specifying the linear pattern, all three optional arguments !      must be present. subroutine set_sparsity_pattern ( me , irow , icol , linear_irow , linear_icol , linear_vals , maxgrp , ngrp ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , dimension (:), intent ( in ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), intent ( in ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), intent ( in ), optional :: linear_irow !! linear sparsity pattern nonzero elements row indices integer , dimension (:), intent ( in ), optional :: linear_icol !! linear sparsity pattern nonzero elements column indices real ( wp ), dimension (:), intent ( in ), optional :: linear_vals !! linear sparsity values (constant elements of the Jacobian) integer , intent ( in ), optional :: maxgrp !! DSM sparsity partition !! [only used if `me%partition_sparsity_pattern=True`] integer , dimension (:), intent ( in ), optional :: ngrp !! DSM sparsity partition (size `n`) !! [only used if `me%partition_sparsity_pattern=True`] integer :: info !! status output form [[dsm]] call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions if ( size ( irow ) /= size ( icol ) . or . any ( irow > me % m ) . or . any ( icol > me % n )) then call me % raise_exception ( 15 , 'set_sparsity_pattern' ,& 'invalid inputs' ) return else me % sparsity % sparsity_computed = . true . me % sparsity % num_nonzero_elements = size ( irow ) me % sparsity % irow = irow me % sparsity % icol = icol call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then if ( present ( maxgrp ) . and . present ( ngrp )) then ! use the user-input partition: if ( maxgrp > 0 . and . all ( ngrp >= 1 . and . ngrp <= maxgrp ) . and . size ( ngrp ) == me % n ) then me % sparsity % maxgrp = maxgrp me % sparsity % ngrp = ngrp else call me % raise_exception ( 28 , 'set_sparsity_pattern' ,& 'invalid sparsity partition inputs.' ) return end if else call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 16 , 'set_sparsity_pattern' ,& 'error partitioning sparsity pattern.' ) return end if end if end if end if ! linear pattern: if ( present ( linear_irow ) . and . present ( linear_icol ) . and . present ( linear_vals )) then if ( size ( linear_irow ) /= size ( linear_icol ) . or . & size ( linear_vals ) /= size ( linear_icol ) . or . & any ( linear_irow > me % m ) . or . & any ( linear_icol > me % n )) then call me % raise_exception ( 17 , 'set_sparsity_pattern' ,& 'invalid linear sparsity pattern' ) return else me % sparsity % linear_irow = linear_irow me % sparsity % linear_icol = linear_icol me % sparsity % linear_vals = linear_vals me % sparsity % linear_sparsity_computed = . true . me % sparsity % num_nonzero_linear_elements = size ( linear_irow ) end if end if end subroutine set_sparsity_pattern !******************************************************************************* !******************************************************************************* !> !  assume all elements of Jacobian are non-zero. subroutine compute_sparsity_dense ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) integer :: i !! counter integer :: r !! row counter integer :: c !! column counter call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions me % sparsity % num_nonzero_elements = me % m * me % n allocate ( me % sparsity % irow ( me % sparsity % num_nonzero_elements )) allocate ( me % sparsity % icol ( me % sparsity % num_nonzero_elements )) call me % sparsity % compute_indices () ! create the dense matrix: i = 0 do c = 1 , me % n do r = 1 , me % m i = i + 1 me % sparsity % irow ( i ) = r me % sparsity % icol ( i ) = c end do end do ! No real need for this, since it can't be partitioned (all elements are true) if ( me % partition_sparsity_pattern ) call me % generate_dense_sparsity_partition () me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_dense !******************************************************************************* !******************************************************************************* !> !  Generate a \"dense\" sparsity partition. subroutine generate_dense_sparsity_partition ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer :: i !! counter if ( me % exception_raised ) return ! check for exceptions me % sparsity % maxgrp = me % n allocate ( me % sparsity % ngrp ( me % n )) me % sparsity % ngrp = [( i , i = 1 , me % n )] end subroutine generate_dense_sparsity_partition !******************************************************************************* !******************************************************************************* !> !  Compute the sparsity pattern by computing the function at three !  \"random\" points in the [`xlow_for_sparsity`, `xhigh_for_sparsity`] interval !  and checking if the function values are the same. subroutine compute_sparsity_random ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) !! (not used here) integer :: i !! column counter integer :: j !! row counter integer :: n_icol !! `icol` size counter integer :: n_irow !! `irow` size counter integer :: n_linear_icol !! `linear_icol` size counter integer :: n_linear_irow !! `linear_irow` size counter integer :: n_linear_vals !! `linear_vals` size counter integer , dimension ( me % m ) :: idx !! indices to compute `[1,2,...,m]` real ( wp ), dimension ( me % n ) :: x1 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x2 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x3 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x4 !! perturbed variable vector real ( wp ), dimension ( me % m ) :: f1 !! function evaluation real ( wp ), dimension ( me % m ) :: f2 !! function evaluation real ( wp ), dimension ( me % m ) :: f3 !! function evaluation real ( wp ), dimension ( me % m ) :: f4 !! function evaluation real ( wp ) :: dfdx1 !! for linear sparsity estimation real ( wp ) :: dfdx2 !! for linear sparsity estimation real ( wp ) :: dfdx3 !! for linear sparsity estimation real ( wp ) :: dfdx !! for linear sparsity estimation integer :: info !! status output form [[dsm]] real ( wp ), dimension ( 4 ), parameter :: coeffs = [ 0.20123456787654321_wp ,& 0.40123456787654321_wp ,& 0.60123456787654321_wp ,& 0.80123456787654321_wp ] !! Pick three pseudo-random points roughly equally spaced. !! (add some noise in attempt to avoid freak zeros) !!```` !! xlow---|----|--x--|---xhigh !!        1    2     3 !!```` !! !! Also using an extra point to estimate the !! constant elements of the Jacobian. ! initialize: call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions ! error check: if (. not . allocated ( me % xlow_for_sparsity ) . or . . not . allocated ( me % xhigh_for_sparsity )) then call me % raise_exception ( 18 , 'compute_sparsity_random' ,& 'the x bounds have not been set.' ) return end if associate ( xlow => me % xlow_for_sparsity , xhigh => me % xhigh_for_sparsity ) ! we will compute all the functions: idx = [( i , i = 1 , me % m )] n_icol = 0 ! initialize vector size counters n_irow = 0 n_linear_icol = 0 n_linear_irow = 0 n_linear_vals = 0 ! define a nominal point roughly in the middle: x2 = xlow + ( xhigh - xlow ) * coeffs ( 2 ) call me % compute_function ( x2 , f2 , idx ) if ( me % exception_raised ) return ! check for exceptions if ( me % compute_linear_sparsity_pattern ) then ! we need another point where we perturb all the variables ! to check to make sure it is linear in only one variable. x4 = xlow + ( xhigh - xlow ) * coeffs ( 4 ) call me % compute_function ( x4 , f4 , idx ) if ( me % exception_raised ) return ! check for exceptions end if do i = 1 , me % n ! columns of Jacobian ! restore nominal: x1 = x2 x3 = x2 x1 ( i ) = xlow ( i ) + ( xhigh ( i ) - xlow ( i )) * coeffs ( 1 ) x3 ( i ) = xlow ( i ) + ( xhigh ( i ) - xlow ( i )) * coeffs ( 3 ) call me % compute_function ( x1 , f1 , idx ) if ( me % exception_raised ) return ! check for exceptions call me % compute_function ( x3 , f3 , idx ) if ( me % exception_raised ) return ! check for exceptions do j = 1 , me % m ! each function (rows of Jacobian) if ( equal_within_tol ([ f1 ( j ), f2 ( j ), f3 ( j )], me % function_precision_tol )) then ! no change in the function, so no sparsity element here. cycle else if ( me % compute_linear_sparsity_pattern ) then ! if computing the linear pattern separately. ! do the three points lie on a line? (x1,f1) -> (x2, f2), -> (x3,f3) ! [check that the slopes are equal within a tolerance] dfdx1 = ( f1 ( j ) - f2 ( j )) / ( x1 ( i ) - x2 ( i )) ! slope of line from 1->2 dfdx2 = ( f1 ( j ) - f3 ( j )) / ( x1 ( i ) - x3 ( i )) ! slope of line from 1->3 dfdx3 = ( f1 ( j ) - f4 ( j )) / ( x1 ( i ) - x4 ( i )) ! slope of line from 1->4 if ( equal_within_tol ([ dfdx1 , dfdx2 , dfdx3 ], me % linear_sparsity_tol )) then ! this is a linear element (constant value) dfdx = ( dfdx1 + dfdx2 + dfdx3 ) / 3.0_wp ! just take the average and use that call expand_vector ( me % sparsity % linear_icol , n_linear_icol , me % chunk_size , val = i ) call expand_vector ( me % sparsity % linear_irow , n_linear_irow , me % chunk_size , val = j ) call expand_vector ( me % sparsity % linear_vals , n_linear_vals , me % chunk_size , val = dfdx ) cycle ! this element will not be added to the nonlinear pattern end if end if ! otherwise, add it to the nonlinear pattern: call expand_vector ( me % sparsity % icol , n_icol , me % chunk_size , val = i ) call expand_vector ( me % sparsity % irow , n_irow , me % chunk_size , val = j ) end if end do end do ! resize to correct size: call me % resize_sparsity_vectors ( n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) end associate call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 19 , 'compute_sparsity_random' ,& 'error partitioning sparsity pattern.' ) return end if end if ! finished: me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_random !******************************************************************************* !******************************************************************************* !> !  Resize the sparsity arrays after accumulating them. subroutine resize_sparsity_vectors ( me , n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( inout ) :: n_icol integer , intent ( inout ) :: n_irow integer , intent ( inout ) :: n_linear_icol integer , intent ( inout ) :: n_linear_irow integer , intent ( inout ) :: n_linear_vals if ( me % exception_raised ) return ! check for exceptions ! resize to correct size: if ( allocated ( me % sparsity % icol )) then call expand_vector ( me % sparsity % icol , n_icol , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % irow , n_irow , me % chunk_size , finished = . true .) me % sparsity % num_nonzero_elements = size ( me % sparsity % irow ) else me % sparsity % num_nonzero_elements = 0 end if ! linear pattern (note: there may be no linear elements): me % sparsity % linear_sparsity_computed = me % compute_linear_sparsity_pattern . and . & allocated ( me % sparsity % linear_vals ) if ( me % sparsity % linear_sparsity_computed ) then call expand_vector ( me % sparsity % linear_icol , n_linear_icol , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % linear_irow , n_linear_irow , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % linear_vals , n_linear_vals , me % chunk_size , finished = . true .) me % sparsity % num_nonzero_linear_elements = n_linear_vals else me % sparsity % num_nonzero_linear_elements = 0 end if end subroutine resize_sparsity_vectors !******************************************************************************* !******************************************************************************* !> !  Compute the sparsity pattern by computing a 2-point jacobian at a specified !  number of \"random\" points (`num_sparsity_points`) in the !  [`xlow_for_sparsity`, `xhigh_for_sparsity`] interval and checking if !  they are the same. subroutine compute_sparsity_random_2 ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) !! (not used here) type :: jac_type !! so we can define an array of jacobian columns real ( wp ), dimension (:), allocatable :: jac !! a column of the jacobian end type jac_type real ( wp ), dimension (:), allocatable :: coeffs !! coefficients for computing `xp` real ( wp ), dimension (:,:), allocatable :: xp !! perturbed `x` array (size `n,num_sparsity_points`) type ( jac_type ), dimension (:), allocatable :: jac_array !! array of jacobian columns type ( sparsity_pattern ) :: tmp_sparsity_pattern !! will accumulate the pattern here !! and copy it into the class when !! finished. integer :: i !! counter for the number of points integer :: j !! counter integer :: icol !! column counter integer :: irow !! row counter real ( wp ) :: dfdx !! value of a jacobian element integer :: n_icol !! `icol` size counter integer :: n_irow !! `irow` size counter integer :: n_linear_icol !! `linear_icol` size counter integer :: n_linear_irow !! `linear_irow` size counter integer :: n_linear_vals !! `linear_vals` size counter type ( meth_array ) :: class_meths !! set of finite diff methods to use real ( wp ), dimension (:), allocatable :: jac !! array of jacobian element values integer :: info !! status output form [[dsm]] ! initialize: call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions ! error check: if (. not . allocated ( me % xlow_for_sparsity ) . or . . not . allocated ( me % xhigh_for_sparsity )) then call me % raise_exception ( 20 , 'compute_sparsity_random_2' ,& 'the x bounds have not been set.' ) return end if ! compute the coefficients: coeffs = divide_interval ( me % num_sparsity_points ) ! save the initial settings: tmp_sparsity_pattern = me % sparsity ! we create a provisional sparsity pattern here, ! to compute one row at a time: me % sparsity % irow = [( irow , irow = 1 , me % m )] me % sparsity % sparsity_computed = . true . me % sparsity % num_nonzero_elements = me % m call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) call me % generate_dense_sparsity_partition () n_icol = 0 n_irow = 0 n_linear_icol = 0 n_linear_irow = 0 n_linear_vals = 0 allocate ( jac ( me % num_sparsity_points )) ! the idea here is to compute the (dense) jacobian ! one column at at time, and keep a running track of ! the ones that have changed. ! first precompute the perturbation arrays for each point: allocate ( xp ( me % n , me % num_sparsity_points )) do i = 1 , me % num_sparsity_points xp (:, i ) = me % xlow_for_sparsity + ( me % xhigh_for_sparsity - me % xlow_for_sparsity ) * coeffs ( i ) end do ! we will use 2-point methods (simple differences): class_meths = get_all_methods_in_class ( 2 ) do icol = 1 , me % n ! column loop ! size the array: if ( allocated ( jac_array )) deallocate ( jac_array ) allocate ( jac_array ( me % num_sparsity_points )) ! compute the ith column of the jacobian: me % sparsity % icol = [( icol , j = 1 , me % m )] do i = 1 , me % num_sparsity_points call me % compute_jacobian_for_sparsity ( icol , class_meths , xp (:, i ), jac_array ( i )% jac ) if ( me % exception_raised ) return ! check for exceptions end do ! check each row: do irow = 1 , me % m ! get the jacobian values for this row,col for all the points: do j = 1 , me % num_sparsity_points jac ( j ) = jac_array ( j )% jac ( irow ) end do ! put the results into the tmp_sparsity_pattern if ( equal_within_tol ([ 0.0_wp , jac ], me % linear_sparsity_tol )) then ! they are all zero cycle else if ( me % compute_linear_sparsity_pattern ) then if ( equal_within_tol ( jac , me % linear_sparsity_tol )) then ! this is a linear element (constant value) dfdx = sum ( jac ) / me % num_sparsity_points ! just take the average and use that call expand_vector ( tmp_sparsity_pattern % linear_icol , n_linear_icol , me % chunk_size , val = icol ) call expand_vector ( tmp_sparsity_pattern % linear_irow , n_linear_irow , me % chunk_size , val = irow ) call expand_vector ( tmp_sparsity_pattern % linear_vals , n_linear_vals , me % chunk_size , val = dfdx ) cycle ! this element will not be added to the nonlinear pattern end if end if ! otherwise, add it to the nonlinear pattern: call expand_vector ( tmp_sparsity_pattern % icol , n_icol , me % chunk_size , val = icol ) call expand_vector ( tmp_sparsity_pattern % irow , n_irow , me % chunk_size , val = irow ) end if end do end do ! copy over the computed pattern: me % sparsity = tmp_sparsity_pattern ! resize to correct size: call me % resize_sparsity_vectors ( n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 21 , 'compute_sparsity_random_2' ,& 'error partitioning sparsity pattern.' ) return end if end if me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_random_2 !******************************************************************************* !******************************************************************************* !> !  Computes the sparsity pattern and return it. !  Uses the settings currently in the class. subroutine compute_sparsity_pattern ( me , x , irow , icol , linear_irow , linear_icol , linear_vals ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) integer , dimension (:), allocatable , intent ( out ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), allocatable , intent ( out ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_irow !! linear sparsity pattern !! nonzero elements row indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_icol !! linear sparsity pattern nonzero !! elements column indices real ( wp ), dimension (:), allocatable , intent ( out ), optional :: linear_vals !! linear sparsity values (constant !! elements of the Jacobian) if ( me % exception_raised ) return ! check for exceptions if ( associated ( me % compute_sparsity )) then call me % compute_sparsity ( x ) if ( me % exception_raised ) return ! check for exceptions call me % get_sparsity_pattern ( irow , icol , linear_irow , linear_icol , linear_vals ) end if end subroutine compute_sparsity_pattern !******************************************************************************* !******************************************************************************* !> !  Returns the sparsity pattern from the class. !  If it hasn't been computed, the output arrays will not be allocated. subroutine get_sparsity_pattern ( me , irow , icol ,& linear_irow , linear_icol , linear_vals ,& maxgrp , ngrp ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , dimension (:), allocatable , intent ( out ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), allocatable , intent ( out ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_irow !! linear sparsity pattern !! nonzero elements row indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_icol !! linear sparsity pattern nonzero !! elements column indices real ( wp ), dimension (:), allocatable , intent ( out ), optional :: linear_vals !! linear sparsity values (constant !! elements of the Jacobian) integer , intent ( out ), optional :: maxgrp !! DSM sparsity partition integer , dimension (:), allocatable , intent ( out ), optional :: ngrp !! DSM sparsity partition if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % sparsity % irow ) . and . allocated ( me % sparsity % icol )) then irow = me % sparsity % irow icol = me % sparsity % icol end if ! optional linear pattern output: if ( present ( linear_irow )) then if ( allocated ( me % sparsity % linear_irow )) linear_irow = me % sparsity % linear_irow end if if ( present ( linear_icol )) then if ( allocated ( me % sparsity % linear_icol )) linear_icol = me % sparsity % linear_icol end if if ( present ( linear_vals )) then if ( allocated ( me % sparsity % linear_vals )) linear_vals = me % sparsity % linear_vals end if ! optional DSM partition: if ( present ( ngrp ) . and . allocated ( me % sparsity % ngrp )) ngrp = me % sparsity % ngrp if ( present ( maxgrp )) maxgrp = me % sparsity % maxgrp end subroutine get_sparsity_pattern !******************************************************************************* !******************************************************************************* !> !  just a wrapper for [[compute_jacobian]], that returns a dense (`m x n`) matrix. ! !@note This one will include the constant elements if the linear pattern is available. subroutine compute_jacobian_dense ( me , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:,:), allocatable , intent ( out ) :: jac !! the jacobian matrix real ( wp ), dimension (:), allocatable :: jac_vec !! sparse jacobian representation integer :: i !! counter if ( me % exception_raised ) return ! check for exceptions ! size output matrix: allocate ( jac ( me % m , me % n )) ! convert to dense form: jac = zero ! compute sparse form of jacobian: call me % compute_jacobian ( x , jac_vec ) if ( me % exception_raised ) return ! check for exceptions if ( allocated ( jac_vec )) then ! add the nonlinear elements: do i = 1 , me % sparsity % num_nonzero_elements jac ( me % sparsity % irow ( i ), me % sparsity % icol ( i )) = jac_vec ( i ) end do deallocate ( jac_vec ) end if ! add the constant elements if necessary: do i = 1 , me % sparsity % num_nonzero_linear_elements jac ( me % sparsity % linear_irow ( i ), me % sparsity % linear_icol ( i )) = me % sparsity % linear_vals ( i ) end do end subroutine compute_jacobian_dense !******************************************************************************* !******************************************************************************* !> !  Perturb the specified optimization variable, and compute the function. !  This routine is designed so that `df` is accumulated as each function !  evaluation is done, to avoid having to allocate more temporary storage. subroutine perturb_x_and_compute_f ( me , x , dx_factor , dx ,& df_factor , column , idx , df ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! nominal variable vector real ( wp ), intent ( in ) :: dx_factor !! factor to multiply `dx` real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation value for this column real ( wp ), intent ( in ) :: df_factor !! factor to multiply function value integer , intent ( in ) :: column !! the variable to perturb integer , dimension (:), intent ( in ) :: idx !! the elements in this !! column of the Jacobian !! to compute (passed to function) real ( wp ), dimension ( me % m ), intent ( inout ) :: df !! the accumulated function value !! note: for the first call, this !! should be set to zero real ( wp ), dimension ( me % n ) :: xp !! the perturbed variable vector real ( wp ), dimension ( me % m ) :: f !! function evaluation if ( me % exception_raised ) return ! check for exceptions xp = x if ( dx_factor /= zero ) xp ( column ) = xp ( column ) + dx_factor * dx ( column ) call me % compute_function ( xp , f , idx ) if ( me % exception_raised ) return ! check for exceptions df ( idx ) = df ( idx ) + df_factor * f ( idx ) end subroutine perturb_x_and_compute_f !******************************************************************************* !******************************************************************************* !> !  Returns the product `J*v`, where `J` is the `m x n` Jacobian matrix !  and `v` is an `n x 1` vector. ! !@note This one will include the constant elements if the linear pattern is available. subroutine compute_jacobian_times_vector ( me , x , v , z ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), intent ( in ) :: v !! vector (size `n`) real ( wp ), dimension (:), intent ( out ) :: z !! The product `J*v` (size `m`) real ( wp ), dimension (:), allocatable :: jac !! sparse jacobian vector integer :: i !! counter integer :: r !! row number in full jacobian integer :: c !! column number in full jacobian if ( me % exception_raised ) return ! check for exceptions ! first compute the jacobian in sparse vector form: call me % compute_jacobian ( x , jac ) if ( me % exception_raised ) return ! check for exceptions ! initialize output vector: z = 0.0_wp if ( allocated ( jac )) then !   J    v   z !  ---   -   - !  X0X   X   X !  0X0 * X = X !  00X   X   X !  00X       X ! multiplication by input v: do i = 1 , me % sparsity % num_nonzero_elements r = me % sparsity % irow ( i ) c = me % sparsity % icol ( i ) z ( r ) = z ( r ) + jac ( i ) * v ( c ) end do deallocate ( jac ) end if ! linear elements if available: do i = 1 , me % sparsity % num_nonzero_linear_elements r = me % sparsity % linear_irow ( i ) c = me % sparsity % linear_icol ( i ) z ( r ) = z ( r ) + me % sparsity % linear_vals ( i ) * v ( c ) end do end subroutine compute_jacobian_times_vector !******************************************************************************* !******************************************************************************* !> !  Compute the Jacobian. ! !@note The output `jac` only includes the elements of the nonlinear Jacobian. !      If the constant elements are being handled separately (if the linear !      pattern is available), then those elements can be obtained by !      calling `get_sparsity_pattern` if required. subroutine compute_jacobian ( me , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), allocatable , intent ( out ) :: jac !! sparse jacobian vector real ( wp ), dimension ( me % n ) :: dx !! absolute perturbation (>0) for each variable if ( me % exception_raised ) return ! check for exceptions ! if we don't have a sparsity pattern yet then compute it: ! [also computes the indices vector] if (. not . me % sparsity % sparsity_computed ) call me % compute_sparsity ( x ) if ( me % sparsity % num_nonzero_elements == 0 ) return ! size the jacobian vector: allocate ( jac ( me % sparsity % num_nonzero_elements )) ! compute dx vector: if (. not . me % use_diff ) then ! only need this for the finite difference methods (not diff) call me % compute_perturbation_vector ( x , dx ) if ( me % exception_raised ) return ! check for exceptions end if ! compute the jacobian: if ( associated ( me % jacobian_function )) then call me % jacobian_function ( x , dx , jac ) else call me % raise_exception ( 22 , 'compute_jacobian' ,& 'jacobian_function has not been associated.' ) return end if end subroutine compute_jacobian !******************************************************************************* !******************************************************************************* !> !  A separate version of [[compute_jacobian]] to be used only when !  computing the sparsity pattern in [[compute_sparsity_random_2]]. !  It uses `class_meths` and the sparsity dperts and bounds. ! !@note Based on [[compute_jacobian]]. The index manipulation here could be !      greatly simplified, since we realdy know we are computed all the !      elements in one column. subroutine compute_jacobian_for_sparsity ( me , i , class_meths , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: i !! the column being computed type ( meth_array ), intent ( in ) :: class_meths !! set of finite diff methods to use real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), allocatable , intent ( out ) :: jac !! sparse jacobian vector real ( wp ), dimension ( me % n ) :: dx !! absolute perturbation (>0) for each variable integer , dimension (:), allocatable :: nonzero_elements_in_col !! the indices of the !! nonzero Jacobian !! elements in a column integer :: j !! function evaluation counter real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column if ( me % exception_raised ) return ! check for exceptions ! Note that a sparsity pattern has already been set ! size the jacobian vector: allocate ( jac ( me % sparsity % num_nonzero_elements )) ! compute the perturbation vector (really we only need dx(i)): call me % compute_sparsity_perturbation_vector ( x , dx ) if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! determine functions to compute for this column: num_nonzero_elements_in_col = count ( me % sparsity % icol == i ) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to compute nonzero_elements_in_col = pack ( me % sparsity % irow , mask = me % sparsity % icol == i ) call me % select_finite_diff_method ( x ( i ), me % xlow_for_sparsity ( i ), me % xhigh_for_sparsity ( i ),& dx ( i ), class_meths , fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then write ( error_unit , '(A,1X,I5)' ) & 'Error in compute_jacobian_for_sparsity: variable bounds violated for column: ' , i end if end if ! compute this column of the Jacobian: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( fd % df_den_factor * dx ( i )) ! put result into the output vector: jac ( pack ( me % sparsity % indices , mask = me % sparsity % icol == i )) = & df ( nonzero_elements_in_col ) end if end subroutine compute_jacobian_for_sparsity !******************************************************************************* !******************************************************************************* !> !  Compute the Jacobian using finite differences. !  (one column at a time) subroutine compute_jacobian_standard ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector (size !! `num_nonzero_elements`) integer , dimension (:), allocatable :: nonzero_elements_in_col !! the indices of the !! nonzero Jacobian !! elements in a column integer :: i !! column counter integer :: j !! function evaluation counter real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! compute Jacobian matrix column-by-column: do i = 1 , me % n ! determine functions to compute for this column: num_nonzero_elements_in_col = count ( me % sparsity % icol == i ) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to compute nonzero_elements_in_col = pack ( me % sparsity % irow , mask = me % sparsity % icol == i ) select case ( me % mode ) case ( 1 ) ! use the specified methods ! compute this column of the Jacobian: df = zero do j = 1 , size ( me % meth ( i )% dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , me % meth ( i )% dx_factors ( j ),& dx , me % meth ( i )% df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( me % meth ( i )% df_den_factor * dx ( i )) case ( 2 ) ! select the method from the class so as not to violate the bounds call me % select_finite_diff_method ( x ( i ), me % xlow ( i ), me % xhigh ( i ),& dx ( i ), me % class_meths ( i ), fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then write ( error_unit , '(A,1X,I5)' ) & 'Error in compute_jacobian_standard: variable bounds violated for column: ' , i end if end if ! compute this column of the Jacobian: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( fd % df_den_factor * dx ( i )) case default call me % raise_exception ( 23 , 'compute_jacobian_standard' ,& 'invalid mode' ) return end select ! put result into the output vector: jac ( pack ( me % sparsity % indices , mask = me % sparsity % icol == i )) = & df ( nonzero_elements_in_col ) end if end do end subroutine compute_jacobian_standard !******************************************************************************* !******************************************************************************* !> !  Compute the Jacobian one element at a time using the Neville's process !  algorithm [[diff]]. This takes a very large number of function evaluations, !  but should give a very accurate answer. subroutine compute_jacobian_with_diff ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector (size !! `num_nonzero_elements`) integer , parameter :: iord = 1 !! tells [[diff]] to compute first derivative integer :: i !! counter for nonzero elements of jacobian type ( diff_func ) :: d !! the [[diff]] class to use real ( wp ) :: x0 !! value of ith variable for [[diff]] real ( wp ) :: xmin !! ith variable lower bound real ( wp ) :: xmax !! ith variable upper bound real ( wp ) :: deriv !! derivative value df/dx from [[diff]] real ( wp ) :: error !! estimated error from [[diff]] integer :: ifail !! [[diff]] error flag real ( wp ), dimension ( me % n ) :: xp !! used by [[dfunc]]. real ( wp ), dimension ( me % m ) :: fvec !! used by [[dfunc]]. integer :: ir !! row index of next non-zero element integer :: ic !! column index of next non-zero element integer :: ic_prev !! previous column perturbed integer :: icount !! count of number of times a column has been perturbed logical :: use_info !! if we are reporting to the user if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero use_info = associated ( me % info_function ) if ( use_info ) ic_prev = - 1 ! set the function for diff: call d % set_function ( dfunc ) ! each element is computed one by one do i = 1 , me % sparsity % num_nonzero_elements ir = me % sparsity % irow ( i ) ic = me % sparsity % icol ( i ) x0 = x ( ic ) xmin = me % xlow ( ic ) xmax = me % xhigh ( ic ) ! if reporting to the user, have to keep track ! of which column is being perturbed, and how ! many times: if ( use_info ) then if ( ic /= ic_prev ) icount = 0 end if call d % compute_derivative ( iord , x0 , xmin , xmax , me % eps , me % acc , deriv , error , ifail ) if ( ifail == 0 . or . ifail == 1 ) then jac ( i ) = deriv else if ( ifail == - 1 ) then ! this indicates an exception was ! already raised, so just return. return else call me % raise_exception ( 24 , 'compute_jacobian_with_diff' ,& 'error computing derivative with DIFF.' ) return end if if ( use_info ) ic_prev = ic end do contains function dfunc ( this , xval ) result ( fx ) !! interface to user function for [[diff]] routine. implicit none class ( diff_func ), intent ( inout ) :: this real ( wp ), intent ( in ) :: xval !! input variable (`ic` variable) real ( wp ) :: fx !! derivative of `ir` function !! w.r.t. `xval` variable if ( use_info ) then icount = icount + 1 call me % info_function ([ ic ], icount , x ) end if xp = x xp ( ic ) = xval call me % compute_function ( xp , fvec , funcs_to_compute = [ ir ]) if ( me % exception_raised ) then ! check for exceptions fx = 0.0_wp call me % terminate () else fx = fvec ( ir ) end if end function dfunc end subroutine compute_jacobian_with_diff !******************************************************************************* !******************************************************************************* !> !  Compute the Jacobian using finite differences, !  (using the partitioned sparsity pattern to compute multiple columns !  at a time). subroutine compute_jacobian_partitioned ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector integer :: i !! column counter integer :: j !! function evaluation counter integer :: igroup !! group number counter integer :: n_cols !! number of columns in a group integer , dimension (:), allocatable :: cols !! array of column indices in a group integer , dimension (:), allocatable :: nonzero_rows !! the indices of the nonzero Jacobian !! elementes (row numbers) in a group integer , dimension (:), allocatable :: indices !! nonzero indices in `jac` for a group integer , dimension (:), allocatable :: col_indices !! nonzero indices in `jac` for a column real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! compute by group: do igroup = 1 , me % sparsity % maxgrp ! get the columns in this group: call me % sparsity % columns_in_partition_group ( igroup , n_cols , cols ,& nonzero_rows , indices , status_ok ) if (. not . status_ok ) then call me % raise_exception ( 25 , 'compute_jacobian_partitioned' ,& 'the partition has not been computed.' ) return end if if ( n_cols > 0 ) then if ( allocated ( nonzero_rows )) then select case ( me % mode ) case ( 1 ) ! use the specified methods ! note: all the methods must be the same within a group ! compute the columns of the Jacobian in this group: df = zero do j = 1 , size ( me % meth ( 1 )% dx_factors ) if ( associated ( me % info_function )) call me % info_function ( cols , j , x ) call me % perturb_x_and_compute_f_partitioned ( x , me % meth ( 1 )% dx_factors ( j ),& dx , me % meth ( 1 )% df_factors ( j ),& cols , nonzero_rows , df ) if ( me % exception_raised ) return ! check for exceptions end do ! divide by the denominator, which can be different for each column: do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % sparsity % icol == cols ( i )) if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) ! col_indices = pack(me%sparsity%indices,mask=me%sparsity%icol==cols(i)) block integer :: j , n n = 0 do j = 1 , size ( me % sparsity % icol ) if ( me % sparsity % icol ( j ) == cols ( i )) then n = n + 1 col_indices ( n ) = j end if end do end block df ( me % sparsity % irow ( col_indices )) = df ( me % sparsity % irow ( col_indices )) / & ( me % meth ( 1 )% df_den_factor * dx ( cols ( i ))) end do case ( 2 ) ! select the method from the class so as not to violate ! the bounds on *any* of the variables in the group ! note: all the classes must be the same within a group call me % select_finite_diff_method_for_partition_group ( & x ( cols ), me % xlow ( cols ), me % xhigh ( cols ),& dx ( cols ), me % class_meths ( 1 ), fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then ! will not consider this a fatal error for now: write ( error_unit , '(A,1X,I5,1X,A,1X,*(I5,1X))' ) & 'Error in compute_jacobian_partitioned: ' // & 'variable bounds violated for group: ' ,& igroup , '. columns: ' , cols end if end if ! compute the columns of the Jacobian in this group: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ( cols , j , x ) call me % perturb_x_and_compute_f_partitioned ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& cols , nonzero_rows , df ) if ( me % exception_raised ) return ! check for exceptions end do ! divide by the denominator, which can be different for each column: do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % sparsity % icol == cols ( i )) if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) col_indices = pack ( me % sparsity % indices , mask = me % sparsity % icol == cols ( i )) df ( me % sparsity % irow ( col_indices )) = df ( me % sparsity % irow ( col_indices )) / & ( fd % df_den_factor * dx ( cols ( i ))) end do case default call me % raise_exception ( 26 , 'compute_jacobian_partitioned' , 'invalid mode' ) return end select ! put result into the output vector: jac ( indices ) = df ( nonzero_rows ) end if end if end do end subroutine compute_jacobian_partitioned !******************************************************************************* !******************************************************************************* !> !  Perturb the specified optimization variable, and compute the function. !  This routine is designed so that `df` is accumulated as each function !  evaluation is done, to avoid having to allocate more temporary storage. subroutine perturb_x_and_compute_f_partitioned ( me , x , dx_factor , dx ,& df_factor , columns , idx , df ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! nominal variable vector real ( wp ), intent ( in ) :: dx_factor !! factor to multiply `dx` real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation value for this column real ( wp ), intent ( in ) :: df_factor !! factor to multiply function value integer , dimension (:), intent ( in ) :: columns !! the variables to perturb integer , dimension (:), intent ( in ) :: idx !! the elements in this !! column of the Jacobian !! to compute (passed to function) real ( wp ), dimension ( me % m ), intent ( inout ) :: df !! the accumulated function value !! note: for the first call, this !! should be set to zero real ( wp ), dimension ( me % n ) :: xp !! the perturbed variable vector real ( wp ), dimension ( me % m ) :: f !! function evaluation if ( me % exception_raised ) return ! check for exceptions xp = x if ( dx_factor /= zero ) xp ( columns ) = xp ( columns ) + dx_factor * dx ( columns ) call me % compute_function ( xp , f , idx ) if ( me % exception_raised ) return ! check for exceptions df ( idx ) = df ( idx ) + df_factor * f ( idx ) end subroutine perturb_x_and_compute_f_partitioned !******************************************************************************* !******************************************************************************* !> !  Compute `dx`, the perturbation vector for `x` subroutine compute_perturb_vector ( me , x , dpert , perturb_mode , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dpert integer , intent ( in ) :: perturb_mode real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) !! the smallest allowed absolute step if ( me % exception_raised ) return ! check for exceptions select case ( perturb_mode ) case ( 1 ) dx = abs ( dpert ) case ( 2 ) dx = abs ( dpert * x ) case ( 3 ) dx = abs ( dpert ) * ( 1.0_wp + abs ( x )) case default call me % raise_exception ( 27 , 'compute_perturb_vector' ,& 'invalid value for perturb_mode (must be 1, 2, or 3)' ) return end select ! make sure none are too small: where ( dx < eps ) dx = dpert end where end subroutine compute_perturb_vector !******************************************************************************* !******************************************************************************* !> !  Compute `dx`, the perturbation vector for `x` used !  when computing the gradients. subroutine compute_perturbation_vector ( me , x , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable if ( me % exception_raised ) return ! check for exceptions call me % compute_perturb_vector ( x , me % dpert , me % perturb_mode , dx ) end subroutine compute_perturbation_vector !******************************************************************************* !******************************************************************************* !> !  Compute `dx`, the perturbation vector for `x` used !  when computing the sparsity pattern. subroutine compute_sparsity_perturbation_vector ( me , x , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable if ( me % exception_raised ) return ! check for exceptions call me % compute_perturb_vector ( x , me % dpert_for_sparsity , me % sparsity_perturb_mode , dx ) end subroutine compute_sparsity_perturbation_vector !******************************************************************************* !******************************************************************************* !> !  Print the sparsity pattern. subroutine print_sparsity ( me , n , m , iunit , dense ) implicit none class ( sparsity_pattern ), intent ( in ) :: me integer , intent ( in ) :: n !! number of variables (columns of jacobian) integer , intent ( in ) :: m !! number of functions (rows of jacobian) integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) logical , intent ( in ), optional :: dense !! if present and true, the matrix form !! of the sparsity pattern is printed !! (default is vector form) logical :: print_matrix !! if the matrix form is to be printed integer :: r !! row counter character ( len = 1 ), dimension ( n ) :: row !! a row of the sparsity matrix if ( present ( dense )) then print_matrix = dense else print_matrix = . false . ! default end if write ( iunit , '(A)' ) '---Sparsity pattern---' if ( allocated ( me % irow ) . and . allocated ( me % icol )) then if ( print_matrix ) then do r = 1 , m ! print by row row = '0' row ( pack ( me % icol , mask = me % irow == r )) = 'X' write ( iunit , '(*(A1))' ) row end do else write ( iunit , '(A,1X,*(I3,\",\"))' ) 'irow:' , me % irow write ( iunit , '(A,1X,*(I3,\",\"))' ) 'icol:' , me % icol end if if ( allocated ( me % ngrp )) then write ( iunit , '(A)' ) '' write ( iunit , '(A)' ) '---Sparsity partition---' write ( iunit , '(A,1x,I5)' ) 'Number of groups:' , me % maxgrp write ( iunit , '(A,1x,*(I5,1X))' ) 'Group array:     ' , me % ngrp end if end if write ( iunit , '(A)' ) '' ! print linear pattern if available if ( me % linear_sparsity_computed ) then write ( iunit , '(A)' ) '---Linear sparsity pattern---' if ( allocated ( me % linear_icol ) . and . allocated ( me % linear_irow )) then if ( print_matrix ) then do r = 1 , m ! print by row row = '0' row ( pack ( me % linear_icol , mask = me % linear_irow == r )) = 'X' write ( iunit , '(*(A1))' ) row end do else write ( iunit , '(A,1X,*(I3,\",\"))' ) 'irow:' , me % linear_irow write ( iunit , '(A,1X,*(I3,\",\"))' ) 'icol:' , me % linear_icol write ( iunit , '(A,1X,*(E30.16,\",\"))' ) 'vals:' , me % linear_vals end if end if write ( iunit , '(A)' ) '' end if end subroutine print_sparsity !******************************************************************************* !******************************************************************************* !> !  Print the sparsity pattern in vector form (`irow`, `icol`). subroutine print_sparsity_pattern ( me , iunit ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) call me % sparsity % print ( me % n , me % m , iunit , dense = . false .) end subroutine print_sparsity_pattern !******************************************************************************* !******************************************************************************* !> !  Print the sparsity pattern in matrix form. subroutine print_sparsity_matrix ( me , iunit ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) call me % sparsity % print ( me % n , me % m , iunit , dense = . true .) end subroutine print_sparsity_matrix !******************************************************************************* !******************************************************************************* !> !  A user-callable routine. When called, it will terminate !  all computations and return. The `istat` return code will be !  set to `-1`. This can be called in the function or the info function. subroutine terminate ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me if ( me % exception_raised ) return ! check for existing exceptions me % istat = - 1 me % error_msg = 'Terminated by the user' me % exception_raised = . true . end subroutine terminate !******************************************************************************* !******************************************************************************* !> !  Raise an exception. subroutine raise_exception ( me , istat , routine , error_msg ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: istat !! error code. character ( len =* ), intent ( in ) :: routine !! the routine where the error was raised. character ( len =* ), intent ( in ) :: error_msg !! error message string. me % istat = istat me % error_msg = 'Error in ' // trim ( routine ) // ' : ' // trim ( error_msg ) me % exception_raised = . true . end subroutine raise_exception !******************************************************************************* !******************************************************************************* !> !  Clear all exceptions. subroutine clear_exceptions ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me me % istat = 0 if ( allocated ( me % error_msg )) deallocate ( me % error_msg ) me % exception_raised = . false . end subroutine clear_exceptions !******************************************************************************* !******************************************************************************* !> !  Returns True if an exception has been raised. pure logical function failed ( me ) implicit none class ( numdiff_type ), intent ( in ) :: me failed = me % exception_raised end function failed !******************************************************************************* !******************************************************************************* !> !  Returns the current error code and message. subroutine get_error_status ( me , istat , error_msg ) implicit none class ( numdiff_type ), intent ( in ) :: me integer , intent ( out ), optional :: istat !! error code (`istat=0` means no errors). character ( len = :), allocatable , intent ( out ), optional :: error_msg !! error message string. if ( present ( istat )) istat = me % istat if ( present ( error_msg )) then if ( allocated ( me % error_msg )) then error_msg = me % error_msg else error_msg = '' end if end if end subroutine get_error_status !******************************************************************************* !******************************************************************************* !> !  Convert an integer to a string. function integer_to_string ( i , with_sign ) result ( str ) implicit none integer , intent ( in ) :: i !! the integer logical , intent ( in ), optional :: with_sign !! also include the sign (default is False) character ( len = :), allocatable :: str !! integer converted to a string integer :: istat !! `iostat` code for write statement character ( len = 100 ) :: tmp !! logical :: sgn !! local copy of `with_sign` if ( present ( with_sign )) then sgn = with_sign else sgn = . false . end if if ( sgn ) then write ( tmp , '(SP,I100)' , iostat = istat ) i else write ( tmp , '(I100)' , iostat = istat ) i end if if ( istat == 0 ) then str = trim ( adjustl ( tmp )) else str = '****' end if end function integer_to_string !******************************************************************************* !******************************************************************************* end module numerical_differentiation_module !*******************************************************************************","tags":"","url":"sourcefile/numerical_differentiation_module.f90.html"},{"title":"utilities_module.f90 – NumDiff","text":"This file depends on sourcefile~~utilities_module.f90~~EfferentGraph sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~utilities_module.f90->sourcefile~kinds_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~utilities_module.f90~~AfferentGraph sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~cache_module.f90 cache_module.f90 sourcefile~cache_module.f90->sourcefile~utilities_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~utilities_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~cache_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams ! !  Utility routines. module numdiff_utilities_module use numdiff_kinds_module integer , parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. private interface expand_vector module procedure :: expand_vector_int , expand_vector_real end interface expand_vector public :: expand_vector interface unique module procedure :: unique_int , unique_real end interface unique public :: unique interface sort_ascending module procedure :: sort_ascending_int , sort_ascending_real end interface sort_ascending public :: sort_ascending interface swap module procedure :: swap_int , swap_real end interface swap public :: equal_within_tol public :: divide_interval contains !******************************************************************************* !******************************************************************************* !> !  Add elements to the integer vector in chunks. pure subroutine expand_vector_int ( vec , n , chunk_size , val , finished ) implicit none integer , dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ) :: chunk_size !! allocate `vec` in blocks of this size (>0) integer , intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) integer , dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector_int !******************************************************************************* !******************************************************************************* !> !  Add elements to the real vector in chunks. pure subroutine expand_vector_real ( vec , n , chunk_size , val , finished ) implicit none real ( wp ), dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ) :: chunk_size !! allocate `vec` in blocks of this size (>0) real ( wp ), intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) real ( wp ), dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector_real !******************************************************************************* !******************************************************************************* !> !  Returns only the unique elements of the vector (sorted in ascending order). function unique_int ( vec , chunk_size ) result ( ivec_unique ) implicit none integer , dimension (:), intent ( in ) :: vec !! a vector of integers integer , intent ( in ) :: chunk_size !! chunk size for adding to arrays integer , dimension (:), allocatable :: ivec_unique !! unique elements of `ivec` integer , dimension ( size ( vec )) :: ivec !! temp copy of vec integer :: i !! counter integer :: n !! number of unique elements ! first we sort it: ivec = vec ! make a copy call sort_ascending ( ivec ) ! add the first element: n = 1 ivec_unique = [ ivec ( 1 )] ! walk through array and get the unique ones: if ( size ( ivec ) > 1 ) then do i = 2 , size ( ivec ) if ( ivec ( i ) /= ivec ( i - 1 )) then call expand_vector ( ivec_unique , n , chunk_size , val = ivec ( i )) end if end do call expand_vector ( ivec_unique , n , chunk_size , finished = . true .) end if end function unique_int !******************************************************************************* !******************************************************************************* !> !  Returns only the unique elements of the vector (sorted in ascending order). function unique_real ( vec , chunk_size ) result ( ivec_unique ) implicit none real ( wp ), dimension (:), intent ( in ) :: vec !! a vector of integers integer , intent ( in ) :: chunk_size !! chunk size for adding to arrays real ( wp ), dimension (:), allocatable :: ivec_unique !! unique elements of `ivec` real ( wp ), dimension ( size ( vec )) :: ivec !! temp copy of vec integer :: i !! counter integer :: n !! number of unique elements ! first we sort it: ivec = vec ! make a copy call sort_ascending ( ivec ) ! add the first element: n = 1 ivec_unique = [ ivec ( 1 )] ! walk through array and get the unique ones: if ( size ( ivec ) > 1 ) then do i = 2 , size ( ivec ) if ( ivec ( i ) /= ivec ( i - 1 )) then call expand_vector ( ivec_unique , n , chunk_size , val = ivec ( i )) end if end do call expand_vector ( ivec_unique , n , chunk_size , finished = . true .) end if end function unique_real !******************************************************************************* !******************************************************************************* !> !  Sorts an integer array `ivec` in increasing order. !  Uses a basic recursive quicksort !  (with insertion sort for partitions with \\le 20 elements). subroutine sort_ascending_int ( ivec ) implicit none integer , dimension (:), intent ( inout ) :: ivec call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_int !******************************************************************************* !******************************************************************************* !> !  Sorts a real array `ivec` in increasing order. !  Uses a basic recursive quicksort !  (with insertion sort for partitions with \\le 20 elements). subroutine sort_ascending_real ( ivec ) implicit none real ( wp ), dimension (:), intent ( inout ) :: ivec call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_real !******************************************************************************* !******************************************************************************* !> !  Swap two integer values. pure elemental subroutine swap_int ( i1 , i2 ) implicit none integer , intent ( inout ) :: i1 integer , intent ( inout ) :: i2 integer :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_int !******************************************************************************* !******************************************************************************* !> !  Swap two integer values. pure elemental subroutine swap_real ( i1 , i2 ) implicit none real ( wp ), intent ( inout ) :: i1 real ( wp ), intent ( inout ) :: i2 real ( wp ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_real !******************************************************************************* !******************************************************************************* !> !  Returns true if the values in the array are the same !  (to within the specified absolute tolerance). pure function equal_within_tol ( vals , tol ) result ( equal ) implicit none real ( wp ), dimension (:), intent ( in ) :: vals !! a set of values real ( wp ), intent ( in ) :: tol !! a positive tolerance value logical :: equal !! true if they are equal !! within the tolerance equal = all ( abs ( vals - vals ( 1 )) <= abs ( tol ) ) end function equal_within_tol !******************************************************************************* !******************************************************************************* !> !  Returns a set of slightly randomized equally-spaced !  points that divide an interval. ! !### Example: ! !  for `num_points` = 3: !``` !     o---|---|---|---o !         1   2   3 !``` !  returns: `[0.25308641972530865, 0.5061728394506173, 0.759259259175926]`. function divide_interval ( num_points ) result ( points ) implicit none integer , intent ( in ) :: num_points !! the number of points in the interval real ( wp ), dimension (:), allocatable :: points !! the resultant vector real ( wp ), parameter :: noise = 1.012345678901234567_wp !! a noise value. Not a round number !! so as to avoid freak zeros in the !! jacobian real ( wp ), parameter :: min_val = 1 0.0_wp * epsilon ( 1.0_wp ) !! the minimize distance from the lower bound real ( wp ), parameter :: max_val = 1.0_wp - min_val !! the minimize distance from the upper bound integer :: i !! counter real ( wp ) :: delta !! step size real ( wp ), dimension (:), allocatable :: tmp !! a temp array to hold the values delta = 1.0_wp / ( num_points + 1 ) allocate ( tmp ( num_points )) do i = 1 , num_points tmp ( i ) = min ( max ( min_val , delta * i * noise ), max_val ) end do ! this is to protect for the min/max case if there ! are enough points so that some are duplicated near ! the bounds: points = unique ( tmp , chunk_size = 10 ) end function divide_interval !******************************************************************************* !******************************************************************************* end module numdiff_utilities_module !*******************************************************************************","tags":"","url":"sourcefile/utilities_module.f90.html"},{"title":"kinds_module.F90 – NumDiff","text":"Files dependent on this one sourcefile~~kinds_module.f90~~AfferentGraph sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~cache_module.f90 cache_module.f90 sourcefile~cache_module.f90->sourcefile~kinds_module.f90 sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~cache_module.f90->sourcefile~utilities_module.f90 sourcefile~diff_module.f90 diff_module.f90 sourcefile~diff_module.f90->sourcefile~kinds_module.f90 sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~dsm_module.f90->sourcefile~kinds_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~kinds_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~cache_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~diff_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~dsm_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~utilities_module.f90 sourcefile~utilities_module.f90->sourcefile~kinds_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> !  Numeric kinds for NumDiff. ! !@note The default real kind (`wp`) can be !      changed using optional preprocessor flags. !      This library was built with real kind: #ifdef REAL32 !      `real(kind=real32)` [4 bytes] #elif REAL64 !      `real(kind=real64)` [8 bytes] #elif REAL128 !      `real(kind=real128)` [16 bytes] #else !      `real(kind=real64)` [8 bytes] #endif module numdiff_kinds_module use iso_fortran_env private #ifdef REAL32 integer , parameter , public :: wp = real32 !! default real kind [4 bytes] #elif REAL64 integer , parameter , public :: wp = real64 !! default real kind [8 bytes] #elif REAL128 integer , parameter , public :: wp = real128 !! default real kind [16 bytes] #else integer , parameter , public :: wp = real64 !! default real kind [8 bytes] #endif end module numdiff_kinds_module !*******************************************************************************","tags":"","url":"sourcefile/kinds_module.f90.html"},{"title":"dsm_module.f90 – NumDiff","text":"This file depends on sourcefile~~dsm_module.f90~~EfferentGraph sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~dsm_module.f90->sourcefile~kinds_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~dsm_module.f90~~AfferentGraph sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~dsm_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> !  Jacobian partitioning using the DSM algorithm. ! !### Reference !  * Argonne National Laboratory. MINPACK Project. July 1983. !    Thomas F. Coleman, Burton S. Garbow, Jorge J. More !  * Thomas F. Coleman, Burton S. Garbow, Jorge J. More, \"Algorithm 618: !    FORTRAN subroutines for estimating sparse Jacobian Matrices\", !    ACM Transactions on Mathematical Software (TOMS), !    Volume 10 Issue 3, Sept. 1984, Pages 346-347 ! !### History !  * Jacob Williams, Nov. 2016, extensive refactoring into modern Fortran. module dsm_module use numdiff_kinds_module implicit none private public :: dsm public :: fdjs contains !******************************************************************************* !******************************************************************************* !> !  The purpose of `dsm` is to determine an optimal or near- !  optimal consistent partition of the columns of a sparse !  `m` by `n` matrix `a`. ! !  the sparsity pattern of the matrix `a` is specified by !  the arrays `indrow` and `indcol`. on input the indices !  for the non-zero elements of `a` are ! !  `indrow(k),indcol(k), k = 1,2,...,npairs`. ! !  the (`indrow`,`indcol`) pairs may be specified in any order. !  duplicate input pairs are permitted, but the subroutine !  eliminates them. ! !  the subroutine partitions the columns of `a` into groups !  such that columns in the same group do not have a !  non-zero in the same row position. a partition of the !  columns of `a` with this property is consistent with the !  direct determination of `a`. subroutine dsm ( m , n , Npairs , Indrow , Indcol , Ngrp , Maxgrp , Mingrp , Info , Ipntr , Jpntr ) implicit none integer , intent ( in ) :: m !! number of rows of `a` (>0) integer , intent ( in ) :: n !! number of columns of `a` (>0) integer , intent ( in ) :: npairs !! number of (`indrow`,`indcol`) pairs used !! to describe the sparsity pattern of `a` (>0) integer , intent ( out ) :: maxgrp !! the number of groups in the partition !! of the columns of `a`. integer , intent ( out ) :: mingrp !! a lower bound for the number of groups !! in any consistent partition of the !! columns of `a`. integer , intent ( out ) :: info !! for normal termination `info = 1`. !! if `m`, `n`, or `npairs` is not positive, !! then `info = 0`. if the k-th element of !! `indrow` is not an integer between !! 1 and m or the k-th element of `indcol` !! is not an integer between 1 and n, !! then `info = -k`. integer , dimension ( npairs ), intent ( inout ) :: indrow !! an integer array of length `npairs`. on input `indrow` !! must contain the row indices of the non-zero elements of `a`. !! on output `indrow` is permuted so that the corresponding !! column indices are in non-decreasing order. the column !! indices can be recovered from the array `jpntr`. integer , dimension ( npairs ), intent ( inout ) :: indcol !! an integer array of length `npairs`. on input `indcol` !! must contain the column indices of the non-zero elements of !! `a`. on output `indcol` is permuted so that the corresponding !! row indices are in non-decreasing order. the row indices !! can be recovered from the array `ipntr`. integer , dimension ( n ), intent ( out ) :: ngrp !! specifies the partition of the columns of `a`. !! column `jcol` belongs to group `ngrp(jcol)`. integer , dimension ( m + 1 ), intent ( out ) :: ipntr !! an integer output array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! note that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n + 1 ), intent ( out ) :: jpntr !! jpntr is an integer output array of length n + 1 which !! specifies the locations of the row indices in indrow. !! the row indices for column j are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! note that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( max ( m , 6 * n )) :: iwa !! an integer work array integer :: i , ir , j , jp , k , maxclq , nnz , numgrp !  check the input data. Info = 0 if ( m < 1 . or . n < 1 . or . Npairs < 1 ) return do k = 1 , Npairs Info = - k if ( Indrow ( k ) < 1 . or . Indrow ( k ) > m . or . Indcol ( k ) < 1 . or . Indcol ( k ) > n ) return enddo Info = 1 !  sort the data structure by columns. call srtdat ( n , Npairs , Indrow , Indcol , Jpntr , Iwa ) !  compress the data and determine the number of !  non-zero elements of a. do i = 1 , m Iwa ( i ) = 0 enddo nnz = 1 do j = 1 , n k = nnz do jp = Jpntr ( j ) , Jpntr ( j + 1 ) - 1 ir = Indrow ( jp ) if ( Iwa ( ir ) /= j ) then Indrow ( nnz ) = ir nnz = nnz + 1 Iwa ( ir ) = j endif enddo Jpntr ( j ) = k enddo Jpntr ( n + 1 ) = nnz !  extend the data structure to rows. call setr ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ) !  determine a lower bound for the number of groups. Mingrp = 0 do i = 1 , m Mingrp = max ( Mingrp , Ipntr ( i + 1 ) - Ipntr ( i )) enddo !  determine the degree sequence for the intersection !  graph of the columns of a. call degr ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( n + 1 )) !  color the intersection graph of the columns of a !  with the smallest-last (sl) ordering. call slo ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( 4 * n + 1 ), maxclq ,& Iwa ( 1 ), Iwa ( n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( 3 * n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Ngrp , Maxgrp , & Iwa ( n + 1 )) Mingrp = max ( Mingrp , maxclq ) !  exit if the smallest-last ordering is optimal. if ( Maxgrp == Mingrp ) return !  color the intersection graph of the columns of a !  with the incidence-degree (id) ordering. call ido ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( 4 * n + 1 ), & maxclq , Iwa ( 1 ), Iwa ( n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( 3 * n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Iwa ( 1 ), numgrp , & Iwa ( n + 1 )) Mingrp = max ( Mingrp , maxclq ) !  retain the better of the two orderings so far. if ( numgrp < Maxgrp ) then Maxgrp = numgrp do j = 1 , n Ngrp ( j ) = Iwa ( j ) enddo !  exit if the incidence-degree ordering is optimal. if ( Maxgrp == Mingrp ) return endif !  color the intersection graph of the columns of a !  with the largest-first (lf) ordering. call numsrt ( n , n - 1 , Iwa ( 5 * n + 1 ), - 1 , Iwa ( 4 * n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Iwa ( 1 ), numgrp , & Iwa ( n + 1 )) !  retain the best of the three orderings and exit. if ( numgrp < Maxgrp ) then Maxgrp = numgrp do j = 1 , n Ngrp ( j ) = Iwa ( j ) enddo endif end subroutine dsm !******************************************************************************* !******************************************************************************* !> !  Given the sparsity pattern of an `m` by `n` matrix `a`, !  this subroutine determines the degree sequence for !  the intersection graph of the columns of `a`. ! !  In graph-theory terminology, the intersection graph of !  the columns of `a` is the loopless graph `g` with vertices !  `a(j), j = 1,2,...,n` where `a(j)` is the `j`-th column of `a` !  and with edge `(a(i),a(j))` if and only if columns `i` and `j` !  have a non-zero in the same row position. ! !@note The value of `m` is not needed by `degr` and is !      therefore not present in the subroutine statement. subroutine degr ( n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , Iwa ) implicit none integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , dimension ( * ), intent ( in ) :: indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ), intent ( in ) :: jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ), intent ( in ) :: indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ), intent ( in ) :: ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ), intent ( out ) :: ndeg !! an integer output array of length `n` which !! specifies the degree sequence. the degree of the !! `j`-th column of `a` is `ndeg(j)`. integer , dimension ( n ) :: iwa !! an integer work array of length `n` integer :: ic , ip , ir , jcol , jp ! initialization block. do jp = 1 , n Ndeg ( jp ) = 0 Iwa ( jp ) = 0 enddo ! compute the degree sequence by determining the contributions ! to the degrees from the current(jcol) column and further ! columns which have not yet been considered. do jcol = 2 , n Iwa ( jcol ) = n ! determine all positions (ir,jcol) which correspond ! to non-zeroes in the matrix. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! for each row ir, determine all positions (ir,ic) ! which correspond to non-zeroes in the matrix. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! array iwa marks columns which have contributed to ! the degree count of column jcol. update the degree ! counts of these columns as well as column jcol. if ( Iwa ( ic ) < jcol ) then Iwa ( ic ) = jcol Ndeg ( ic ) = Ndeg ( ic ) + 1 Ndeg ( jcol ) = Ndeg ( jcol ) + 1 endif enddo enddo enddo end subroutine degr !******************************************************************************* !******************************************************************************* !> !  given the sparsity pattern of an `m` by `n` matrix `a`, this !  subroutine determines an incidence-degree ordering of the !  columns of `a`. ! !  the incidence-degree ordering is defined for the loopless !  graph `g` with vertices `a(j), j = 1,2,...,n` where `a(j)` is the !  `j`-th column of `a` and with edge `(a(i),a(j))` if and only if !  columns `i` and `j` have a non-zero in the same row position. ! !  the incidence-degree ordering is determined recursively by !  letting `list(k), k = 1,...,n` be a column with maximal !  incidence to the subgraph spanned by the ordered columns. !  among all the columns of maximal incidence, `ido` chooses a !  column of maximal degree. subroutine ido ( m , n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , List , Maxclq , & Iwa1 , Iwa2 , Iwa3 , Iwa4 ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of `a`. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , intent ( out ) :: Maxclq !! an integer output variable set to the size !! of the largest clique found during the ordering. integer , dimension ( * ), intent ( in ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ), intent ( in ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ), intent ( in ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( m + 1 ), intent ( in ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ), intent ( in ) :: Ndeg !! an integer input array of length `n` which specifies !! the degree sequence. the degree of the `j`-th column !! of `a` is `ndeg(j)`. integer , dimension ( n ), intent ( out ) :: List !! an integer output array of length `n` which specifies !! the incidence-degree ordering of the columns of `a`. the `j`-th !! column in this order is `list(j)`. integer , dimension ( 0 : n - 1 ) :: Iwa1 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa2 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa3 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa4 !! integer work array of length `n`. integer :: ic , ip , ir , jcol , jp , maxinc , maxlst , ncomp , & numinc , numlst , numord , numwgt ! sort the degree sequence. call numsrt ( n , n - 1 , Ndeg , - 1 , Iwa4 , Iwa2 , Iwa3 ) ! initialization block. ! ! create a doubly-linked list to access the incidences of the ! columns. the pointers for the linked list are as follows. ! ! each un-ordered column ic is in a list (the incidence list) ! of columns with the same incidence. ! ! iwa1(numinc) is the first column in the numinc list ! unless iwa1(numinc) = 0. in this case there are ! no columns in the numinc list. ! ! iwa2(ic) is the column before ic in the incidence list ! unless iwa2(ic) = 0. in this case ic is the first ! column in this incidence list. ! ! iwa3(ic) is the column after ic in the incidence list ! unless iwa3(ic) = 0. in this case ic is the last ! column in this incidence list. ! ! if ic is an un-ordered column, then list(ic) is the ! incidence of ic to the graph induced by the ordered ! columns. if jcol is an ordered column, then list(jcol) ! is the incidence-degree order of column jcol. maxinc = 0 do jp = n , 1 , - 1 ic = Iwa4 ( jp ) Iwa1 ( n - jp ) = 0 Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( 0 ) if ( Iwa1 ( 0 ) > 0 ) Iwa2 ( Iwa1 ( 0 )) = ic Iwa1 ( 0 ) = ic Iwa4 ( jp ) = 0 List ( jp ) = 0 enddo ! DETERMINE THE MAXIMAL SEARCH LENGTH FOR THE LIST ! OF COLUMNS OF MAXIMAL INCIDENCE. maxlst = 0 do ir = 1 , m maxlst = maxlst + ( Ipntr ( ir + 1 ) - Ipntr ( ir )) ** 2 enddo maxlst = maxlst / n Maxclq = 0 numord = 1 ! BEGINNING OF ITERATION LOOP. ! UPDATE THE SIZE OF THE LARGEST CLIQUE ! FOUND DURING THE ORDERING. 100 if ( maxinc == 0 ) ncomp = 0 ncomp = ncomp + 1 if ( maxinc + 1 == ncomp ) Maxclq = max ( Maxclq , ncomp ) ! CHOOSE A COLUMN JCOL OF MAXIMAL DEGREE AMONG THE ! COLUMNS OF MAXIMAL INCIDENCE MAXINC. 200 jp = Iwa1 ( maxinc ) if ( jp > 0 ) then numwgt = - 1 do numlst = 1 , maxlst if ( Ndeg ( jp ) > numwgt ) then numwgt = Ndeg ( jp ) jcol = jp endif jp = Iwa3 ( jp ) if ( jp <= 0 ) exit enddo List ( jcol ) = numord numord = numord + 1 ! TERMINATION TEST. if ( numord > n ) then ! INVERT THE ARRAY LIST. do jcol = 1 , n Iwa2 ( List ( jcol )) = jcol enddo do jp = 1 , n List ( jp ) = Iwa2 ( jp ) enddo else ! DELETE COLUMN JCOL FROM THE MAXINC LIST. if ( Iwa2 ( jcol ) == 0 ) then Iwa1 ( maxinc ) = Iwa3 ( jcol ) else Iwa3 ( Iwa2 ( jcol )) = Iwa3 ( jcol ) endif if ( Iwa3 ( jcol ) > 0 ) Iwa2 ( Iwa3 ( jcol )) = Iwa2 ( jcol ) ! FIND ALL COLUMNS ADJACENT TO COLUMN JCOL. Iwa4 ( jcol ) = n ! DETERMINE ALL POSITIONS (IR,JCOL) WHICH CORRESPOND ! TO NON-ZEROES IN THE MATRIX. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! FOR EACH ROW IR, DETERMINE ALL POSITIONS (IR,IC) ! WHICH CORRESPOND TO NON-ZEROES IN THE MATRIX. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! ARRAY IWA4 MARKS COLUMNS WHICH ARE ADJACENT TO ! COLUMN JCOL. if ( Iwa4 ( ic ) < numord ) then Iwa4 ( ic ) = numord ! UPDATE THE POINTERS TO THE CURRENT INCIDENCE LISTS. numinc = List ( ic ) List ( ic ) = List ( ic ) + 1 maxinc = max ( maxinc , List ( ic )) ! DELETE COLUMN IC FROM THE NUMINC LIST. if ( Iwa2 ( ic ) == 0 ) then Iwa1 ( numinc ) = Iwa3 ( ic ) else Iwa3 ( Iwa2 ( ic )) = Iwa3 ( ic ) endif if ( Iwa3 ( ic ) > 0 ) Iwa2 ( Iwa3 ( ic )) = Iwa2 ( ic ) ! ADD COLUMN IC TO THE NUMINC+1 LIST. Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( numinc + 1 ) if ( Iwa1 ( numinc + 1 ) > 0 ) Iwa2 ( Iwa1 ( numinc + 1 )) = ic Iwa1 ( numinc + 1 ) = ic endif enddo enddo ! END OF ITERATION LOOP. goto 100 endif else maxinc = maxinc - 1 goto 200 endif end subroutine ido !******************************************************************************* !******************************************************************************* !> !  Given a sequence of integers, this subroutine groups !  together those indices with the same sequence value !  and, optionally, sorts the sequence into either !  ascending or descending order. ! !  The sequence of integers is defined by the array `num`, !  and it is assumed that the integers are each from the set !  `0,1,...,nmax`. on output the indices `k` such that `num(k) = l` !  for any `l = 0,1,...,nmax` can be obtained from the arrays !  last and next as follows. !```fortran !  k = last(l) !  while (k /= 0) k = next(k) !``` !  Optionally, the subroutine produces an array index so that !  the sequence `num(index(i)), i = 1,2,...,n` is sorted. subroutine numsrt ( n , Nmax , Num , Mode , Index , Last , Next ) implicit none integer , intent ( in ) :: n !! a positive integer input variable. integer :: Nmax !! a positive integer input variable. integer :: Mode !! an integer input variable. the sequence `num` is !! sorted in ascending order if `mode` is positive and in !! descending order if `mode` is negative. if `mode` is 0, !! no sorting is done. integer , dimension ( n ) :: Num !! an input array of length `n` which contains the !! sequence of integers to be grouped and sorted. it !! is assumed that the integers are each from the set !! `0,1,...,nmax`. integer , dimension ( n ) :: Index !! an integer output array of length `n` set so !! that the sequence !! `num(index(i)), i = 1,2,...,n` !! is sorted according to the setting of mode. !! if `mode` is 0, `index` is not referenced. integer , dimension ( 0 : Nmax ) :: Last !! an integer output array of length `nmax + 1`. the !! index of `num` for the last occurrence of `l` is `last(l)` !! for any `l = 0,1,...,nmax` unless `last(l) = 0`. in !! this case `l` does not appear in `num`. integer , dimension ( n ) :: Next !! an integer output array of length `n`. if !! `num(k) = l`, then the index of `num` for the previous !! occurrence of `l` is `next(k)` for any `l = 0,1,...,nmax` !! unless `next(k) = 0`. in this case there is no previous !! occurrence of `l` in `num`. integer :: i , j , jinc , jl , ju , k , l ! determine the arrays next and last. do i = 0 , Nmax Last ( i ) = 0 enddo do k = 1 , n l = Num ( k ) Next ( k ) = Last ( l ) Last ( l ) = k enddo if ( Mode /= 0 ) then ! store the pointers to the sorted array in index. i = 1 if ( Mode > 0 ) then jl = 0 ju = Nmax jinc = 1 else jl = Nmax ju = 0 jinc = - 1 endif do j = jl , ju , jinc k = Last ( j ) do if ( k == 0 ) exit Index ( i ) = k i = i + 1 k = Next ( k ) enddo enddo end if end subroutine numsrt !******************************************************************************* !******************************************************************************* !> !  given the sparsity pattern of an `m` by `n` matrix `a`, this !  subroutine determines a consistent partition of the !  columns of `a` by a sequential algorithm. ! !  a consistent partition is defined in terms of the loopless !  graph `g` with vertices `a(j), j = 1,2,...,n` where `a(j)` is the !  `j`-th column of `a` and with edge `(a(i),a(j))` if and only if !  columns `i` and `j` have a non-zero in the same row position. ! !  a partition of the columns of a into groups is consistent !  if the columns in any group are not adjacent in the graph `g`. !  in graph-theory terminology, a consistent partition of the !  columns of a corresponds to a coloring of the graph `g`. ! !  the subroutine examines the columns in the order specified !  by the array list, and assigns the current column to the !  group with the smallest possible number. ! !  note that the value of `m` is not needed by `seq` and is !  therefore not present in the subroutine statement. subroutine seq ( n , Indrow , Jpntr , Indcol , Ipntr , List , Ngrp , Maxgrp , Iwa ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Maxgrp !! an integer output variable which specifies the !! number of groups in the partition of the columns of `a`. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ) :: List !! an integer input array of length `n` which specifies !! the order to be used by the sequential algorithm. !! the `j`-th column in this order is `list(j)`. integer , dimension ( n ) :: Ngrp !! an integer output array of length `n` which specifies !! the partition of the columns of `a`. column `jcol` belongs !! to group `ngrp(jcol)`. integer , dimension ( n ) :: Iwa !! an integer work array of length `n` integer :: ic , ip , ir , j , jcol , jp ! initialization block. Maxgrp = 0 do jp = 1 , n Ngrp ( jp ) = n Iwa ( jp ) = 0 enddo ! beginning of iteration loop. do j = 1 , n jcol = List ( j ) ! find all columns adjacent to column jcol. ! ! determine all positions (ir,jcol) which correspond ! to non-zeroes in the matrix. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! for each row ir, determine all positions (ir,ic) ! which correspond to non-zeroes in the matrix. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! array iwa marks the group numbers of the ! columns which are adjacent to column jcol. Iwa ( Ngrp ( ic )) = j enddo enddo ! assign the smallest un-marked group number to jcol. do jp = 1 , Maxgrp if ( Iwa ( jp ) /= j ) then Maxgrp = Maxgrp - 1 exit end if enddo Maxgrp = Maxgrp + 1 Ngrp ( jcol ) = jp enddo ! end of iteration loop. end subroutine seq !******************************************************************************* !******************************************************************************* !> !  given a column-oriented definition of the sparsity pattern !  of an `m` by `n` matrix `a`, this subroutine determines a !  row-oriented definition of the sparsity pattern of `a`. ! !  on input the column-oriented definition is specified by !  the arrays `indrow` and `jpntr`. on output the row-oriented !  definition is specified by the arrays `indcol` and `ipntr`. subroutine setr ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of `a`. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer output array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( m + 1 ) :: Ipntr !! an integer output array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(1)` is set to 1 and that `ipntr(m+1)-1` is !! then the number of non-zero elements of the matrix `a`. integer , dimension ( m ) :: Iwa !! an integer work array of length `m`. integer :: ir , jcol , jp ! store in array iwa the counts of non-zeroes in the rows. do ir = 1 , m Iwa ( ir ) = 0 enddo do jp = 1 , Jpntr ( n + 1 ) - 1 Iwa ( Indrow ( jp )) = Iwa ( Indrow ( jp )) + 1 enddo ! set pointers to the start of the rows in indcol. Ipntr ( 1 ) = 1 do ir = 1 , m Ipntr ( ir + 1 ) = Ipntr ( ir ) + Iwa ( ir ) Iwa ( ir ) = Ipntr ( ir ) enddo ! fill indcol. do jcol = 1 , n do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) Indcol ( Iwa ( ir )) = jcol Iwa ( ir ) = Iwa ( ir ) + 1 enddo enddo end subroutine setr !******************************************************************************* !******************************************************************************* !> !  given the sparsity pattern of an `m` by `n` matrix `a`, this !  subroutine determines the smallest-last ordering of the !  columns of `a`. ! !  the smallest-last ordering is defined for the loopless !  graph `g` with vertices `a(j), j = 1,2,...,n` where `a(j)` is the !  `j`-th column of `a` and with edge `(a(i),a(j))` if and only if !  columns `i` and `j` have a non-zero in the same row position. ! !  the smallest-last ordering is determined recursively by !  letting `list(k), k = n,...,1` be a column with least degree !  in the subgraph spanned by the un-ordered columns. ! !  note that the value of `m` is not needed by `slo` and is !  therefore not present in the subroutine statement. subroutine slo ( n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , List , Maxclq , Iwa1 , & Iwa2 , Iwa3 , Iwa4 ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Maxclq !! an integer output variable set to the size !! of the largest clique found during the ordering. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ) :: Ndeg !! an integer input array of length `n` which specifies !! the degree sequence. the degree of the `j`-th column !! of `a` is `ndeg(j)`. integer , dimension ( n ) :: List !! an integer output array of length `n` which specifies !! the smallest-last ordering of the columns of `a`. the `j`-th !! column in this order is `list(j)`. integer , dimension ( 0 : n - 1 ) :: Iwa1 !! integer work array of length `n` integer , dimension ( n ) :: Iwa2 !! integer work array of length `n` integer , dimension ( n ) :: Iwa3 !! integer work array of length `n` integer , dimension ( n ) :: Iwa4 !! integer work array of length `n` integer :: ic , ip , ir , jcol , jp , mindeg , numdeg , numord ! INITIALIZATION BLOCK. mindeg = n do jp = 1 , n Iwa1 ( jp - 1 ) = 0 Iwa4 ( jp ) = n List ( jp ) = Ndeg ( jp ) mindeg = min ( mindeg , Ndeg ( jp )) enddo ! CREATE A DOUBLY-LINKED LIST TO ACCESS THE DEGREES OF THE ! COLUMNS. THE POINTERS FOR THE LINKED LIST ARE AS FOLLOWS. ! ! EACH UN-ORDERED COLUMN IC IS IN A LIST (THE DEGREE LIST) ! OF COLUMNS WITH THE SAME DEGREE. ! ! IWA1(NUMDEG) IS THE FIRST COLUMN IN THE NUMDEG LIST ! UNLESS IWA1(NUMDEG) = 0. IN THIS CASE THERE ARE ! NO COLUMNS IN THE NUMDEG LIST. ! ! IWA2(IC) IS THE COLUMN BEFORE IC IN THE DEGREE LIST ! UNLESS IWA2(IC) = 0. IN THIS CASE IC IS THE FIRST ! COLUMN IN THIS DEGREE LIST. ! ! IWA3(IC) IS THE COLUMN AFTER IC IN THE DEGREE LIST ! UNLESS IWA3(IC) = 0. IN THIS CASE IC IS THE LAST ! COLUMN IN THIS DEGREE LIST. ! ! IF IC IS AN UN-ORDERED COLUMN, THEN LIST(IC) IS THE ! DEGREE OF IC IN THE GRAPH INDUCED BY THE UN-ORDERED ! COLUMNS. IF JCOL IS AN ORDERED COLUMN, THEN LIST(JCOL) ! IS THE SMALLEST-LAST ORDER OF COLUMN JCOL. do jp = 1 , n numdeg = Ndeg ( jp ) Iwa2 ( jp ) = 0 Iwa3 ( jp ) = Iwa1 ( numdeg ) if ( Iwa1 ( numdeg ) > 0 ) Iwa2 ( Iwa1 ( numdeg )) = jp Iwa1 ( numdeg ) = jp enddo Maxclq = 0 numord = n !  BEGINNING OF ITERATION LOOP. ! ! ! MARK THE SIZE OF THE LARGEST CLIQUE ! FOUND DURING THE ORDERING. 100 if ( mindeg + 1 == numord . and . Maxclq == 0 ) Maxclq = numord ! CHOOSE A COLUMN JCOL OF MINIMAL DEGREE MINDEG. 200 jcol = Iwa1 ( mindeg ) if ( jcol > 0 ) then List ( jcol ) = numord numord = numord - 1 ! TERMINATION TEST. if ( numord == 0 ) then ! INVERT THE ARRAY LIST. do jcol = 1 , n Iwa2 ( List ( jcol )) = jcol enddo do jp = 1 , n List ( jp ) = Iwa2 ( jp ) enddo else ! DELETE COLUMN JCOL FROM THE MINDEG LIST. Iwa1 ( mindeg ) = Iwa3 ( jcol ) if ( Iwa3 ( jcol ) > 0 ) Iwa2 ( Iwa3 ( jcol )) = 0 ! FIND ALL COLUMNS ADJACENT TO COLUMN JCOL. Iwa4 ( jcol ) = 0 ! DETERMINE ALL POSITIONS (IR,JCOL) WHICH CORRESPOND ! TO NON-ZEROES IN THE MATRIX. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! FOR EACH ROW IR, DETERMINE ALL POSITIONS (IR,IC) ! WHICH CORRESPOND TO NON-ZEROES IN THE MATRIX. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! ARRAY IWA4 MARKS COLUMNS WHICH ARE ADJACENT TO ! COLUMN JCOL. if ( Iwa4 ( ic ) > numord ) then Iwa4 ( ic ) = numord ! UPDATE THE POINTERS TO THE CURRENT DEGREE LISTS. numdeg = List ( ic ) List ( ic ) = List ( ic ) - 1 mindeg = min ( mindeg , List ( ic )) ! DELETE COLUMN IC FROM THE NUMDEG LIST. if ( Iwa2 ( ic ) == 0 ) then Iwa1 ( numdeg ) = Iwa3 ( ic ) else Iwa3 ( Iwa2 ( ic )) = Iwa3 ( ic ) endif if ( Iwa3 ( ic ) > 0 ) Iwa2 ( Iwa3 ( ic )) = Iwa2 ( ic ) ! ADD COLUMN IC TO THE NUMDEG-1 LIST. Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( numdeg - 1 ) if ( Iwa1 ( numdeg - 1 ) > 0 ) Iwa2 ( Iwa1 ( numdeg - 1 )) = ic Iwa1 ( numdeg - 1 ) = ic endif enddo enddo ! END OF ITERATION LOOP. goto 100 endif else mindeg = mindeg + 1 goto 200 endif end subroutine slo !******************************************************************************* !******************************************************************************* !> !  given the non-zero elements of an `m` by `n` matrix `a` in !  arbitrary order as specified by their row and column !  indices, this subroutine permutes these elements so !  that their column indices are in non-decreasing order. ! !  on input it is assumed that the elements are specified in ! !  `indrow(k),indcol(k), k = 1,...,nnz`. ! !  on output the elements are permuted so that `indcol` is !  in non-decreasing order. in addition, the array `jpntr` !  is set so that the row indices for column `j` are ! !  `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. ! !  note that the value of `m` is not needed by srtdat and is !  therefore not present in the subroutine statement. subroutine srtdat ( n , Nnz , Indrow , Indcol , Jpntr , Iwa ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Nnz !! a positive integer input variable set to the number !! of non-zero elements of `a`. integer , dimension ( Nnz ) :: Indrow !! an integer array of length `nnz`. on input `indrow` !! must contain the row indices of the non-zero elements of `a`. !! on output `indrow` is permuted so that the corresponding !! column indices of `indcol` are in non-decreasing order. integer , dimension ( Nnz ) :: Indcol !! an integer array of length `nnz`. on input `indcol` !! must contain the column indices of the non-zero elements !! of `a`. on output `indcol` is permuted so that these indices !! are in non-decreasing order. integer , dimension ( n + 1 ) :: Jpntr !! an integer output array of length `n + 1` which !! specifies the locations of the row indices in the output !! `indrow`. the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(1)` is set to 1 and that `jpntr(n+1)-1` !! is then `nnz`. integer , dimension ( n ) :: Iwa !! an integer work array of length `n`. integer :: i , j , k , l ! store in array iwa the counts of non-zeroes in the columns. do j = 1 , n Iwa ( j ) = 0 enddo do k = 1 , Nnz Iwa ( Indcol ( k )) = Iwa ( Indcol ( k )) + 1 enddo ! set pointers to the start of the columns in indrow. Jpntr ( 1 ) = 1 do j = 1 , n Jpntr ( j + 1 ) = Jpntr ( j ) + Iwa ( j ) Iwa ( j ) = Jpntr ( j ) enddo k = 1 ! begin in-place sort. do j = Indcol ( k ) if ( k >= Jpntr ( j ) ) then ! current element is in position. now examine the ! next element or the first un-sorted element in ! the j-th group. k = max ( k + 1 , Iwa ( j )) else ! current element is not in position. place element ! in position and make the displaced element the ! current element. l = Iwa ( j ) Iwa ( j ) = Iwa ( j ) + 1 i = Indrow ( k ) Indrow ( k ) = Indrow ( l ) Indcol ( k ) = Indcol ( l ) Indrow ( l ) = i Indcol ( l ) = j endif if ( k > Nnz ) exit end do end subroutine srtdat !******************************************************************************* !******************************************************************************* !> !  Given a consistent partition of the columns of an `m` by `n` !  jacobian matrix into groups, this subroutine computes !  approximations to those columns in a given group.  the !  approximations are stored into either a column-oriented !  or a row-oriented pattern. ! !  a partition is consistent if the columns in any group !  do not have a non-zero in the same row position. ! !  approximations to the columns of the jacobian matrix in a !  given group can be obtained by specifying a difference !  parameter array `d` with `d(jcol)` non-zero if and only if !  `jcol` is a column in the group, and an approximation to !  `jac*d` where `jac` denotes the jacobian matrix of a mapping f. ! !  `d` can be defined with the following segment of code. !```fortran !  do jcol = 1, n !  d(jcol) = 0.0 !  if (ngrp(jcol) == numgrp) d(jcol) = eta(jcol) !  end do !``` !  in the above code `numgrp` is the given group number, !  `ngrp(jcol)` is the group number of column `jcol`, and !  `eta(jcol)` is the difference parameter used to !  approximate column `jcol` of the jacobian matrix. !  suitable values for the array `eta` must be provided. ! !  as mentioned above, an approximation to `jac*d` must !  also be provided. for example, the approximation !```fortran !  f(x+d) - f(x) !``` !  corresponds to the forward difference formula at `x`. subroutine fdjs ( m , n , Col , Ind , Npntr , Ngrp , Numgrp , d , Fjacd , Fjac ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of the jacobian matrix. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of the jacobian matrix. integer :: Numgrp !! a positive integer input variable set to a group !! number in the partition. the columns of the jacobian !! matrix in this group are to be estimated on this call. integer , dimension ( * ) :: Ind !! an integer input array which contains the row !! indices for the non-zeroes in the jacobian matrix !! if `col` is true, and contains the column indices for !! the non-zeroes in the jacobian matrix if `col` is false. integer , dimension ( * ) :: Npntr !! an integer input array which specifies the !! locations of the row indices in `ind` if `col` is true, and !! specifies the locations of the column indices in `ind` if !! `col` is false. if `col` is true, the indices for column `j` are !!       `ind(k), k = npntr(j),...,npntr(j+1)-1`. !! if `col` is false, the indices for row `i` are !!       `ind(k), k = npntr(i),...,npntr(i+1)-1`. !! ***Note*** that `npntr(n+1)-1` if `col` is true, or `npntr(m+1)-1` !! if `col` is false, is then the number of non-zero elements !! of the jacobian matrix. integer , dimension ( n ) :: Ngrp !! an integer input array of length `n` which specifies !! the partition of the columns of the jacobian matrix. !! column `jcol` belongs to group `ngrp(jcol)`. real ( wp ), dimension ( n ) :: d !! an input array of length `n` which contains the !! difference parameter vector for the estimate of !! the jacobian matrix columns in group `numgrp`. real ( wp ), dimension ( m ) :: Fjacd !! an input array of length `m` which contains !! an approximation to the difference vector `jac*d`, !! where `jac` denotes the jacobian matrix. real ( wp ), dimension ( * ) :: Fjac !! an output array of length `nnz`, where `nnz` is the !! number of its non-zero elements. at each call of `fdjs`, !! `fjac` is updated to include the non-zero elements of the !! jacobian matrix for those columns in group `numgrp`. `fjac` !! should not be altered between successive calls to `fdjs`. logical , intent ( in ) :: Col !! a logical input variable. if `col` is set true, then the !! jacobian approximations are stored into a column-oriented !! pattern. if `col` is set false, then the jacobian !! approximations are stored into a row-oriented pattern. integer :: ip , irow , jcol , jp ! compute estimates of jacobian matrix columns in group ! numgrp. the array fjacd must contain an approximation ! to jac*d, where jac denotes the jacobian matrix and d ! is a difference parameter vector with d(jcol) non-zero ! if and only if jcol is a column in group numgrp. if ( Col ) then ! column orientation. do jcol = 1 , n if ( Ngrp ( jcol ) == Numgrp ) then do jp = Npntr ( jcol ) , Npntr ( jcol + 1 ) - 1 irow = Ind ( jp ) Fjac ( jp ) = Fjacd ( irow ) / d ( jcol ) enddo endif enddo else ! row orientation. do irow = 1 , m do ip = Npntr ( irow ) , Npntr ( irow + 1 ) - 1 jcol = Ind ( ip ) if ( Ngrp ( jcol ) == Numgrp ) then Fjac ( ip ) = Fjacd ( irow ) / d ( jcol ) exit endif enddo enddo endif end subroutine fdjs !******************************************************************************* !******************************************************************************* end module dsm_module !*******************************************************************************","tags":"","url":"sourcefile/dsm_module.f90.html"}]}